
{{alias}}( ord, uplo, N, k, α, A, lda, x, sx, β, y, sy )
    Perform the matrix-vector operation `y = α*A*x + β*y` where `α` and `β` are
    scalars, `x` and `y` are `N` element vectors, and `A` is an `N` by `N`
    symmetric band matrix with `k` super-/sub-diagonals.

    The stride parameters determine how elements in the strided arrays are
    accessed at runtime.

    Indexing is relative to the first index. To introduce an offset, use typed
    array views.

    If `N` is equal to `0`, the function returns `y` unchanged.

    If `α` equals `0.0` and β equals `1.0`, the function returns `y` unchanged.

    Parameters
    ----------
    ord: string
        Row-major (C-style) or column-major (Fortran-style) order. Must be
        either 'row-major' or 'column-major'.

    uplo: string
        Specifies whether the upper or lower triangular part of `A` is provided.
        Must be either 'upper' or 'lower'.

    N: integer
        Number of elements along each dimension of `A`.

    k: integer
        Specifies the number of super-/sub-diagonals.

    α: number
        Scalar constant.

    A: Float32Array
        Symmetric band matrix stored in band storage.

    lda: integer
        Stride of the first dimension of `A` (a.k.a., leading dimension of the
        matrix `A`).

    x: Float32Array
        Input vector.

    sx: integer
        Index increment for `x`.

    β: number
        Scalar constant.

    y: Float32Array
        Output vector .

    sy: integer
        Index increment for `y`.

    Returns
    -------
    y: Float32Array
        Output vector.

    Examples
    --------
    // Standard usage:
    > var x = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > var y = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > var A = new {{alias:@stdlib/array/float32}}( [ 1.0, 2.0, 3.0, 4.0 ] );
    > {{alias}}( 'row-major', 'upper', 2, 1, 1.0, A, 2, x, 1, 1.0, y, 1 )
    <Float32Array>[ ~4.0, ~6.0 ]

    // Advanced indexing:
    > x = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > y = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > A = new {{alias:@stdlib/array/float32}}( [ 1.0, 2.0, 3.0, 4.0 ] );
    > {{alias}}( 'row-major', 'upper', 2, 1, 1.0, A, 2, x, -1, 1.0, y, -1 )
    <Float32Array>[ ~6.0, ~4.0 ]

    // Using typed array views:
    > var x0 = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > var y0 = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > A = new {{alias:@stdlib/array/float32}}( [ 1.0, 2.0, 0.0, 3.0 ] );
    > var x1 = new {{alias:@stdlib/array/float32}}( x0.buffer, x0.BYTES_PER_ELEMENT*0 );
    > var y1 = new {{alias:@stdlib/array/float32}}( y0.buffer, y0.BYTES_PER_ELEMENT*0 );
    > {{alias}}( 'row-major', 'upper', 2, 1, 1.0, A, 2, x1, 1, 1.0, y1, 1 );
    > y0
    <Float32Array>[ ~4.0, ~3.0 ]


{{alias}}.ndarray( ord, uplo, N, k, α, A, lda, x, sx, ox, β, y, sy, oy )
    Perform the matrix-vector operations `y = α*A*x + β*y` using alternative
    indexing semantics and where `α` and `β` are scalars, `x` and `y` are `N`
    element vectors, and `A` is an `N` by `N` symmetric band matrix with `k`
    super-/sub-diagonals.

    While typed array views mandate a view offset based on the underlying
    buffer, the offset parameters support indexing semantics based on starting
    indices.

    Parameters
    ----------
    ord: string
        Row-major (C-style) or column-major (Fortran-style) order. Must be
        either 'row-major' or 'column-major'.

    uplo: string
        Specifies whether the upper or lower triangular part of `A` is supplied.
        Must be either 'upper' or 'lower'.

    N: integer
        Number of elements along each dimension of `A`.

    k: integer
        Specifies the number of super-/sub-diagonals.

    α: number
        Scalar constant.

    A: Float32Array
        Symmetric band matrix stored in band storage.

    lda: integer
        Stride of the first dimension of `A` (a.k.a., leading dimension of the
        matrix `A`).

    x: Float32Array
        Input vector.

    sx: integer
        Index increment for `x`.

    ox: integer
        Starting index for `x`.

    β: number
        Scalar.

    y: Float32Array
        Output vector.

    sy: integer
        Index increment for `y`.

    oy: integer
        Starting index for `y`.

    Returns
    -------
    y: Float32Array
        Output vector.

    Examples
    --------
    // Standard usage:
    > var x = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > var y = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > var A = new {{alias:@stdlib/array/float32}}( [ 1.0, 2.0, 3.0, 4.0 ] );
    > var ord = 'row-major';
    > var uplo = 'upper';
    > {{alias}}.ndarray( ord, uplo, 2, 1, 1.0, A, 2, x, 1, 0, 1.0, y, 1, 0 )
    <Float32Array>[ ~4.0, ~6.0 ]

    // Advanced indexing:
    > x = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > y = new {{alias:@stdlib/array/float32}}( [ 1.0, 1.0 ] );
    > A = new {{alias:@stdlib/array/float32}}( [ 1.0, 2.0, 3.0, 4.0 ] );
    > {{alias}}.ndarray( ord, uplo, 2, 1, 1.0, A, 2, x, -1, 1, 1.0, y, -1, 1 )
    <Float32Array>[ ~6.0, ~4.0 ]

    See Also
    --------
