'use strict';

// MODULES //

var ndarray = require( '@stdlib/ndarray' );
var linspace = require( '@stdlib/math/utils/linspace' );
var pdf = require( '@stdlib/math/base/dists/normal/pdf' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isNumericArray = require( '@stdlib/assert/is-numeric-array' );
var isObject = require( '@stdlib/assert/is-object' );
var pickBandwidth = require( './pick-bandwidth.js' );
var range = require( './range.js' );
var validate = require( './validate.js' );


// MAIN //

/**
* Computes 2-dimensional normal kernel density estimate.
*
* @param {NumericArray} x - array of X values
* @param {NumericArray} y - array of Y values
* @param {Options} [options] - function options
* @param {NumericArray} [options.h] - array of length 2 containing the bandwidth values for X and Y respectively.
* @param {number} [options.n] - The number of partitions on the X and Y axises
* @param {NumericArray} [options.xLim] - Array of length 2 containing the lower and upper limits of X upon which to create the grid
* @param {NumericArray} [options.yLim] - Array of length 2 containing the lower and upper limits of Y upon which to create the grid
* @throws {TypeError} first argument must be an array
* @throws {TypeError} second argument must be an array
* @throws {Error} first and second arguments must be same length
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Object} Object containing the gx, gy and z estimates
* @example
* var x = [ 0.6333, 0.8643, 1.0952, 1.3262, 1.5571, 1.7881, 2.019, 2.25, 2.481, 2.7119 ];
* var y = [ -0.0468, 0.8012, 1.6492, 2.4973, 3.3454, 4.1934, 5.0415, 5.8896, 6.7376, 7.5857 ];
* var out = kde2d( x, y );
*/
function kde2d(x, y) {
	var zScoreX;
	var zScoreY;
	var gridX;
	var gridY;
	var xLim;
	var yLim;
	var subX;
	var subY;
	var opts;
	var err;
	var ans;
	var out;
	var gx;
	var gy;
	var hX;
	var hY;
	var ix;
	var iy;
	var i;
	var n;
	var z;

	opts = {};

	if (arguments.length > 2) {
		err = validate(opts, arguments[2]);
		if ( err ) {
			throw err;
		}
	}

	if (opts.h) {
		hX = opts.h[0];
		hY = opts.h[1];
	} else {
		hX = pickBandwidth(x);
		hY = pickBandwidth(y);
	}
	n = opts.n || 25; // Default

	xLim = opts.xLim || range(x);
	yLim = opts.yLim || range(y);

	// X is a numeric array
	if ( !isNumericArray(x) ) {
		throw new TypeError('x must be a non-empty numeric array');
	}

	// Y is a numeric array
	if ( !isNumericArray(y) ) {
		throw new TypeError('y must be a non-empty numeric array');
	}

	// Both have same length
	if (x.length !== y.length) {
		throw new Error('x and y must have the same length');
	}

	// Opts is an object ONLY IF IT IS PASSED
	if ( arguments.length > 2) {
		if ( !isObject(opts) ) {
			throw new TypeError('opts must be an object');
		}
	}

	// Make the variables
	z = ndarray({
		'shape': [n, n]
	} );

	// Now make the grid
	gridX = linspace(xLim[0], xLim[1], n);
	gridY = linspace(yLim[0], yLim[1], n);

	// Loop throufh x and y indices
	for ( ix = 0; ix < gridX.length; ix++ ) {
		gx = gridX[ix];
		for ( iy = 0; iy < gridY.length; iy++ ) {
			gy = gridY[iy];

			ans = 0;

			// Now loop through the data
			for ( i = 0; i < x.length; i++ ) {
				zScoreX = ((x[i] - gx) / hX);
				zScoreY = ((y[i] - gy) / hY);

				subX = (1 / hX) * pdf(zScoreX, 0, 1);
				subY = (1 / hY) * pdf(zScoreY, 0, 1);
				ans += (subX * subY);
			}
			// Place it in z
			z.set(ix, iy, ans / x.length);
		}
	}

	// Make the return object
	out = {};
	setReadOnly( out, 'x', gridX );
	setReadOnly( out, 'y', gridY );
	setReadOnly( out, 'z', z );

	return out;
}


// EXPORTS //

module.exports = kde2d;

