'use strict';

// MODULES //

var tape = require( 'tape' );
var EPS = require( '@stdlib/constants/math/float64-eps' );
var abs = require( '@stdlib/math/base/special/abs' );
var kde2d = require( './../lib' );
var dataX = require( './fixtures/r/datay.json' );
var dataY = require( './fixtures/r/datay.json' );
var expected = require( './fixtures/r/expected.json' );
var dataX2 = require( './fixtures/r/datax2.json' );
var dataY2 = require( './fixtures/r/datay2.json' );
var expected2 = require( './fixtures/r/expected2.json' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof kde2d, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function throws an error if the `x` argument is not a numeric array', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		5,
		[ 1, 2, '5' ],
		true,
		undefined,
		null,
		NaN,
		function noop() {},
		{}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			// Make the factor the same
			kde2d( value, [1, 2, 3, 4, 5] );
		};
	}
});

tape( 'the function throws an error if the `y` argument is not a numeric array', function test( t ) {
	var values;
	var i;

	values = [
		5,
		true,
		NaN,
		null,
		[NaN, NaN, null],
		['frank', 'frank', 'philipp', 'philipp']
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), Error, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			kde2d( [1, 2, 3, 4, 5], value );
		};
	}
});

tape( 'the function throws an error if the arguments have unequal lengths', function test( t ) {
	// Two unique arguments for x and factor
	var valuesX;
	var valuesY;
	var i;

	valuesX = [
		[1, 2, 3, 4, 5, 6, 7, 8],
		[5, 6, 7, 4],
		[1, 2]
	];

	valuesY = [
		[113, 310, 209, 203, 101],
		[4, 5, 6, 7, 8, 9, 10],
		[9000, 3, 1]
	];

	for ( i = 0; i < valuesX.length; i++ ) {
		t.throws( badValue( valuesX[i], valuesY[i] ), Error, 'throws an error when provided '+valuesX[i]+valuesY[i] );
	}
	t.end();

	function badValue( valueX, valueY ) {
		return function badValue() {
			kde2d( valueX, valueY );
		};
	}
});

tape( 'the function evaluates the pdf for `x` given parameters `mu` and `sigma`', function test( t ) {
	var actual;
	var delta;
	var tol;
	var i;
	var j;

	actual = kde2d(dataX, dataY);

	// Check x
	for (i = 0; i < actual.x.length; i++) {
		if ( actual.x[i] === expected.x[i] ) {
			t.equal( actual.x[i], expected.x[i], 'x: '+actual.x[i]+', expected: '+expected.x[i] );
		} else {
			delta = abs( actual.x[i] - expected.x[ i ] );
			tol = 200.0 * EPS * abs( expected.x[ i ] );
			t.ok( delta <= tol, 'within tolerance. x: '+actual.x[ i ]+'. E: '+expected.x[ i ]+'. Δ: '+delta+'. tol: '+tol+'.' );
		}
	}

	// Check y
	for (i = 0; i < actual.y.length; i++) {
		if ( actual.y[i] === expected.y[i] ) {
			t.equal( actual.y[i], expected.y[i], 'y: '+actual.y[i]+', expected: '+expected.y[i] );
		} else {
			delta = abs( actual.y[i] - expected.y[ i ] );
			tol = 200.0 * EPS * abs( expected.y[ i ] );
			t.ok( delta <= tol, 'within tolerance. y: '+actual.y[ i ]+'. E: '+expected.y[ i ]+'. Δ: '+delta+'. tol: '+tol+'.' );
		}
	}

	for (i = 0; i < actual.x.length; i++) {
		for (j = 0; j < actual.y.length; j++) {
			if ( actual.z.get(i, j) === expected.z[i][j] ) {
				t.equal( actual.z.get(i, j), expected.z[i][j], 'z: '+actual.z.get(i, j)+', expected: '+expected.z[i][j] );
			} else {
				delta = abs( actual.z.get(i, j) - expected.z[i][j] );
				tol = 1500.0 * EPS * abs( expected.z[i][j] );
				t.ok( delta <= tol, 'within tolerance. z: '+actual.z.get(i, j)+'. E: '+expected.z[i][j]+'. Δ: '+delta+'. tol: '+tol+'.' );
			}
		}
	}

	// Do it again with new values
	actual = kde2d(dataX2, dataY2);

	// Check x
	for (i = 0; i < actual.x.length; i++) {
		if ( actual.x[i] === expected2.x[i] ) {
			t.equal( actual.x[i], expected2.x[i], 'x: '+actual.x[i]+', expected: '+expected2.x[i] );
		} else {
			delta = abs( actual.x[i] - expected2.x[ i ] );
			tol = 200.0 * EPS * abs( expected2.x[ i ] );
			t.ok( delta <= tol, 'within tolerance. x: '+actual.x[ i ]+'. E: '+expected2.x[ i ]+'. Δ: '+delta+'. tol: '+tol+'.' );
		}
	}

	// Check y
	for (i = 0; i < actual.y.length; i++) {
		if ( actual.y[i] === expected2.y[i] ) {
			t.equal( actual.y[i], expected2.y[i], 'y: '+actual.y[i]+', expected: '+expected2.y[i] );
		} else {
			delta = abs( actual.y[i] - expected2.y[ i ] );
			tol = 200.0 * EPS * abs( expected2.y[ i ] );
			t.ok( delta <= tol, 'within tolerance. y: '+actual.y[ i ]+'. E: '+expected2.y[ i ]+'. Δ: '+delta+'. tol: '+tol+'.' );
		}
	}

	for (i = 0; i < actual.x.length; i++) {
		for (j = 0; j < actual.y.length; j++) {
			if ( actual.z.get(i, j) === expected2.z[i][j] ) {
				t.equal( actual.z.get(i, j), expected2.z[i][j], 'z: '+actual.z.get(i, j)+', expected: '+expected2.z[i][j] );
			} else {
				delta = abs( actual.z.get(i, j) - expected2.z[i][j] );
				tol = 1500.0 * EPS * abs( expected2.z[i][j] );
				t.ok( delta <= tol, 'within tolerance. z: '+actual.z.get(i, j)+'. E: '+expected2.z[i][j]+'. Δ: '+delta+'. tol: '+tol+'.' );
			}
		}
	}


	t.end();
});
