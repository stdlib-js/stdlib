'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/tools/roots.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var abs = require( '@stdlib/math/base/special/abs');
var ldexp = require( '@stdlib/math/base/special/ldexp');
var sign = require( '@stdlib/math/base/special/signum');
var MAX_VALUE = Number.MAX_VALUE;


// FUNCTIONS //

var max = Math.max;


// HALLEY ITERATE //

function halley_iterate( fun, guess, minimum, maximum, digits, max_iter ) {
	var convergence;
	var outOfBounds;
	var delta1;
	var delta2;
	var factor;
	var result;
	var count;
	var delta;
	var denom;
	var diff;
	var num;
	var res;
	var f0;
	var last_f0;
	var f1;
	var f2;

	f0 = 0.0;
	outOfBounds = false;
	result = guess;
	factor = ldexp( 1.0, 1.0 - digits );
	delta = max( 10000000 * guess, 10000000 );  // arbitarily large delta
	last_f0 = 0;
	delta1 = delta;
	delta2 = delta;

	count = max_iter;
	do {
		last_f0 = f0;
		delta2 = delta1;
		delta1 = delta;
		res = fun( result);
		f0 = res[ 0 ];
		f1 = res[ 1 ];
		f2 = res[ 2 ];

		if ( f0 === 0.0 ) {
			break;
		}
		if ( f1 === 0.0 && f2 === 0.0 ) {
			// Oops zero derivative!!!
			if ( last_f0 === 0.0 ) {
				// this must be the first iteration, pretend that we had a
				// previous one at either min or max:
				if ( result === minimum ) {
					guess = maximum;
				} else {
					guess = minimum;
				}
				last_f0 = fun( guess );
				delta = guess - result;
			}
			if ( sign( last_f0 ) * sign( f0 ) < 0 ) {
				// we've crossed over so move in opposite direction to last step:
				if ( delta < 0 ) {
					delta = ( result - minimum ) / 2;
				} else {
					delta = ( result - maximum ) / 2;
				}
			} else {
				// move in same direction as last step:
				if ( delta < 0 ) {
					delta = (result - maximum) / 2;
				} else {
					delta = (result - minimum) / 2;
				}
			}
		} else {
			if ( f2 !== 0.0 ) {
				denom = 2.0 * f0;
				num = 2.0 * f1 - f0 * (f2 / f1);
				if ( abs(num) < 1 && ( abs(denom) >= abs(num) * MAX_VALUE ) ) {
					// Possible overflow, use Newton step:
					delta = f0 / f1;
				} else {
					delta = denom / num;
				}
				if ( delta * f1 / f0 < 0.0 ) {
					// Probably cancellation error, try a Newton step instead:
					delta = f0 / f1;
				}
			} else {
				delta = f0 / f1;
			}
		}
		convergence = abs( delta / delta2 );
		if ( convergence > 0.8 && convergence < 2.0 ) {
			// Last two steps haven't converged, try bisection:
			delta = delta > 0.0 ? (result - minimum) / 2.0 : (result - maximum) / 2.0;
			if ( abs(delta) > result ) {
				delta = sign( delta ) * result; // protect against huge jumps!
			}
			// reset delta2 so that this branch will *not* be taken on the
			// next iteration:
			delta2 = delta * 3;
		}
		guess = result;
		result -= delta;

		// check for out of bounds step:
		if ( result < minimum ) {
			diff = ( (abs(minimum) < 1) && (abs(result) > 1) && ( MAX_VALUE / abs(result) < abs(minimum)) ) ? 1000  : result / minimum;
			if ( abs(diff) < 1.0 ) {
				diff = 1.0 / diff;
			}
			if ( !outOfBounds && diff > 0.0 && diff < 3.0 ) {
				// Only a small out of bounds step, lets assume that the result
				// is probably approximately at minimum:
				delta = 0.99 * (guess - minimum);
				result = guess - delta;
				outOfBounds = true; // only take this branch once!
			} else {
				delta = (guess - minimum) / 2.0;
				result = guess - delta;
				if ( result === minimum || result === maximum ) {
					break;
				}
			}
		}
		else if ( result > maximum ) {
			diff = ( abs(maximum) < 1.0 && abs(result) > 1.0 && MAX_VALUE / abs(result) < abs(maximum) ) ? 1000 : result / maximum;
			if ( abs(diff) < 1 ) {
				diff = 1 / diff;
			}
			if ( !outOfBounds && diff > 0.0 && diff < 3.0 ) {
				// Only a small out of bounds step, lets assume that the result
				// is probably approximately at minimum:
				delta = 0.99 * (guess  - maximum);
				result = guess - delta;
				outOfBounds = true; // only take this branch once!
			} else {
				delta = ( guess - maximum ) / 2.0;
				result = guess - delta;
				if ( result === minimum || result === maximum ) {
					break;
				}
			}
		}
		// Update brackets:
		if ( delta > 0.0 ) {
			maximum = guess;
		} else {
			minimum = guess;
		}
	} while ( --count && ( abs(result * factor) < abs(delta) ) );

	return result;
} // end FUNCTION halley_iterate()


// EXPORTS //

module.exports = halley_iterate;
