'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/gamma.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006-7, 2013-14.
* Copyright Paul A. Bristow 2007, 2013-14.
* Copyright Nikhar Agrawal 2013-14
* Copyright Christopher Kormanyos 2013-14
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var evalrational = require( '@stdlib/math/base/tools/evalrational' ).factory;
var factorial = require( '@stdlib/math/base/special/factorial' );
var floor = require( '@stdlib/math/base/special/floor' );
var gamma = require( '@stdlib/math/base/special/gamma' );
var log1p = require( '@stdlib/math/base/special/log1p' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var EPSILON = require( '@stdlib/math/constants/float64-eps' );
var E = require( '@stdlib/math/constants/float64-e' );


// CONSTANTS //

var MAX_FACTORIAL = 170;

// LANCZOS APPROXIMATION CONSTANTS //

var G = 10.90051099999999983936049829935654997826;
var NUM = [
	38474670393.31776828316099004518914832218,
	36857665043.51950660081971227404959150474,
	15889202453.72942008945006665994637853242,
	4059208354.298834770194507810788393801607,
	680547661.1834733286087695557084801366446,
	78239755.00312005289816041245285376206263,
	6246580.776401795264013335510453568106366,
	341986.3488721347032223777872763188768288,
	12287.19451182455120096222044424100527629,
	261.6140441641668190791708576058805625502,
	2.506628274631000502415573855452633787834
];
var DENOM = [
	0,
	362880,
	1026576,
	1172700,
	723680,
	269325,
	63273,
	9450,
	870,
	45,
	1
];


// FUNCTIONS //

/**
* Calculate the Lanczos sum approximation.
*
* @private
* @param {number} z - input value
* @returns {number} Lanczos approximation
*/
var lanczos_sum = evalrational( NUM, DENOM );



/**
* Calculate the ratio of two gamma functions.
*
* @private
*/
function tgamma_delta_ratio_imp_lanczos( z, delta ) {
	var result;
	var ratio;
	var zgh;
	if ( z < EPSILON ) {
		//
		// We get spurious numeric overflow unless we're very careful, this
		// can occur either inside Lanczos::lanczos_sum(z) or in the
		// final combination of terms, to avoid this, split the product up
		// into 2 (or 3) parts:
		//
		// G(z) / G(L) = 1 / (z * G(L)) ; z < eps, L = z + delta = delta
		//    z * G(L) = z * G(lim) * (G(L)/G(lim)) ; lim = largest factorial
		//
		if ( MAX_FACTORIAL < delta ) {
			ratio = tgamma_delta_ratio_imp_lanczos( delta, MAX_FACTORIAL - delta );
			ratio *= z;
			ratio *= factorial( MAX_FACTORIAL - 1 );
			return 1.0 / ratio;
		} else {
			return 1.0 / ( z * gamma( z + delta ) );
		}
	}
	zgh = z + G - 0.5;
	if ( abs(delta) < 10 ) {
		result = exp( ( 0.5 - z ) * log1p( delta / zgh ));
	} else {
		result = pow( zgh / (zgh + delta), z - 0.5 );
	}
	// Split the calculation up to avoid spurious overflow:
	result *= lanczos_sum( z ) / lanczos_sum( z + delta );
	result *= pow( E / ( zgh + delta ), delta );
	return result;
} // end FUNCTION tgamma_delta_ratio_imp_lanczos()

function tgamma_delta_ratio_imp( z, delta ) {
	var result;

	if ( z <= 0.0 || z + delta <= 0.0 ) {
		// This isn't very sofisticated, or accurate, but it does work:
		return gamma( z ) / gamma( z + delta );
	}
	if ( floor(delta) === delta ) {
		if ( floor(z) === z ) {
			//
			// Both z and delta are integers, see if we can just use table lookup
			// of the factorials to get the result:
			//
			if( (z <= MAX_FACTORIAL ) && (z + delta <= MAX_FACTORIAL ) ) {
				return factorial( floor(z) - 1 ) / factorial( floor(z+delta) - 1 );
			}
		}
		if ( abs(delta) < 20 ) {
			// Delta is a small integer, we can use a finite product:
			if ( delta === 0 ) {
				return 1.0;
			}
			if ( delta < 0 ) {
				z -= 1.0;
			}
			result = z;
			while ( 0 !== ( delta -= 1 ) ) {
				z -= 1.0;
				result *= z;
			}
			return result;
		} else {
			result = 1.0 / z;
			while ( 0 !== ( delta -= 1 ) ) {
				z += 1;
				result /= z;
			}
			return result;
		}
	}
	return tgamma_delta_ratio_imp_lanczos( z, delta );
} // end FUNCTION tgamma_delta_ratio_imp()


// EXPORTS //

module.exports = tgamma_delta_ratio_imp;
