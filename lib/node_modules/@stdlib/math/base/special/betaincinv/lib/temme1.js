'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/detail/ibeta_inverse.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var evalpoly = require( '@stdlib/math/base/tools/evalpoly' );
var erfcinv = require( '@stdlib/math/base/special/erfcinv' );
var sqrt = require( '@stdlib/math/base/special/sqrt');
var exp = require( '@stdlib/math/base/special/exp');


//
// See:
// "Asymptotic Inversion of the Incomplete Beta Function"
// N.M. Temme
// Journal of Computation and Applied Mathematics 41 (1992) 145-157.
// Section 2.
//
function temme_method_1_ibeta_inverse( a, b, z ) {
	var workspace;
	var terms;
	var eta0;
	var eta;
	var eta_2;
	var r2;
	var B;
	var B_2;
	var B_3;
	var c;
	var x;

	r2 = sqrt( 2 );
	// Get the first approximation for eta from the inverse error function (Eq: 2.9 and 2.10):
	eta0 = erfcinv( 2 * z );
	eta0 /= -sqrt(a / 2);

	terms = [ 0.0, 0.0, 0.0, 0.0 ];
	workspace = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ];

	terms[ 0 ] = eta0;

	// Calculate powers:
	B = b - a;
	B_2 = B * B;
	B_3 = B_2 * B;

	// Calculate correction terms:

	// See eq following 2.15:
	workspace[0] = -B * r2 / 2;
	workspace[1] = (1 - 2 * B) / 8;
	workspace[2] = -(B * r2 / 48);
	workspace[3] = -1 / 192;
	workspace[4] = -B * r2 / 3840;
	terms[1] = evalpoly( workspace, eta0 );
	// Eq Following 2.17:
	workspace[0] = B * r2 * (3 * B - 2) / 12;
	workspace[1] = (20 * B_2 - 12 * B + 1) / 128;
	workspace[2] = B * r2 * (20 * B - 1) / 960;
	workspace[3] = (16 * B_2 + 30 * B - 15) / 4608;
	workspace[4] = B * r2 * (21 * B + 32) / 53760;
	workspace[5] = (-32 * B_2 + 63) / 368640;
	workspace[6] = -B * r2 * (120 * B + 17) / 25804480;
	terms[2] = evalpoly( workspace, eta0 );
	// Eq Following 2.17:
	workspace[0] = B * r2 * (-75 * B_2 + 80 * B - 16) / 480;
	workspace[1] = (-1080 * B_3 + 868 * B_2 - 90 * B - 45) / 9216;
	workspace[2] = B * r2 * (-1190 * B_2 + 84 * B + 373) / 53760;
	workspace[3] = (-2240 * B_3 - 2508 * B_2 + 2100 * B - 165) / 368640;
	terms[3] = evalpoly( workspace, eta0 );

	// Bring them together to get a final estimate for eta:
	eta = evalpoly( terms, 1/a );

	// Now we need to convert eta to x, by solving the appropriate quadratic equation:
	eta_2 = eta * eta;
	c = -exp( -eta_2 / 2 );
	if ( eta_2 === 0 ) {
		x = 0.5;
	} else {
		x = ( 1 + eta * sqrt( (1 + c) / eta_2) ) / 2;
	}
	return x;
} // end FUNCTION temme_method_1_ibeta_inverse()


// EXPORTS //

module.exports = temme_method_1_ibeta_inverse;
