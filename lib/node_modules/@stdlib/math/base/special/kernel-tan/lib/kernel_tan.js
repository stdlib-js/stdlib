'use strict';

/*
* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/k_tan.c?view=co}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/*
* ====================================================
* Copyright 2004 Sun Microsystems, Inc.  All Rights Reserved.
*
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ====================================================
*/

// MODULES //

var getHighWord = require( '@stdlib/math/base/utils/float64-get-high-word' );
var setLowWord = require( '@stdlib/math/base/utils/float64-set-low-word' );
var evalpoly = require( '@stdlib/math/base/tools/evalpoly' ).factory;


// VARIABLES //

var PIO4 = 7.85398163397448278999e-01;
var PIO4LO = 3.06161699786838301793e-17;
var T0 = 3.33333333333334091986e-01; // 3FD55555, 55555563
var T_ODD = [
	1.33333333333201242699e-01, // T1 => 3FC11111, 1110FE7A
	2.18694882948595424599e-02, // T3 => 3FABA1BA, 1BB341FE
	3.59207910759131235356e-03, // T5 => 3F6D6D22, C9560328
	5.88041240820264096874e-04, // T7 => 3F4344D8, F2F26501
	7.81794442939557092300e-05, // T9 => 3F147E88, A03792A6
	-1.85586374855275456654e-05 // T11 => BEF375CB, DB605373
];
var T_EVEN = [
	5.39682539762260521377e-02, // T2 => 3FABA1BA, 1BB341FE
	8.86323982359930005737e-03, // T4 => 3F8226E3, E96E8493
	1.45620945432529025516e-03, // T6 => 3F57DBC8, FEE08315
	2.46463134818469906812e-04, // T8 => 3F3026F7, 1A8D1068
	7.14072491382608190305e-05, // T10 => 3F12B80F, 32F0A7E9
	2.59073051863633712884e-05  // T12 => 3EFB2A70, 74BF7AD4
];

// Absolute value mask: 2147483647 => 0x7fffffff => 01111111111111111111111111111111
var HIGH_WORD_ABS_MASK = 0x7fffffff|0; // asm type annotation


// FUNCTIONS //

// Create polynomial functions based on above coefficients...
var polyvalOdd = evalpoly( T_ODD );
var polyvalEven = evalpoly( T_EVEN );


// MAIN //

/**
* Computes the tangent on \\( \approx[-\pi/4, \pi/4] \\) (except on -0), \\( \pi/4 \approx 0.7854 \\)
*
* ## Method
*
* * Since \\( \tan(-x) = -\tan(x) \\), we need only to consider positive \\( x \\).
*
* * Callers must return \\( \tan(-0) = -0 \\) without calling here since our odd polynomial is not evaluated in a way that preserves \\( -0 \\). Callers may do the optimization \\( \tan(x) \approx x \\) for tiny \\( x \\).
*
* * \\( \tan(x) \\) is approximated by a odd polynomial of degree 27 on \\( [0, 0.67434] \\)
*
*   ``` tex
*   \tan(x) \approx x + T_1 x^3 + \ldots + T_{13} x^{27}
*   ```
*   where
*
*   ``` tex
*   \left| \frac{\tan(x)}{x} - \left( 1 + T_1 x^2 + T_2 x^4 + \ldots + T_{13} x^{26} \right) \right|  \le 2^{-59.2}
*   ```
*
* * Note: \\( \tan(x+y) = \tan(x) + \tan'(x) \cdot y \approx \tan(x) + ( 1 + x \cdot x ) \cdot y \\). Therefore, for better accuracy in computing \\( \tan(x+y) \\), let
*
*   ``` tex
*    r = x^3 \cdot \left( T_2+x^2 \cdot (T_3+x^2 \cdot (\ldots+x^2 \cdot (T_{12}+x^2 \cdot T_{13}))) \right)
*   ```
*
*   then
*
*   ``` tex
*   \tan(x+y) = x^3 + \left( T_1 \cdot x^2 + (x \cdot (r+y)+y) \right)
*   ```
*
* * For \\( x \\) in \\( [0.67434, \pi/4] \\),  let \\( y = \pi/4 - x \\), then
*
*   ``` tex
*   \tan(x) = \tan\left(\tfrac{\pi}{4}-y\right) = \frac{1-\tan(y)}{1+\tan(y)} \\
*   = 1 - 2 \cdot \left( \tan(y) - \tfrac{\tan(y)^2}{1+\tan(y)} \right)
*   ```
*
*
* @param {number} x - input value (in radians, assumed to be bounded by ~Ï€/4 in magnitude)
* @param {number} y - tail of x
* @param {integer} k - indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned
* @returns {number} tangent
*
* @example
* var out = kernelTan( Math.PI/4.0, 0.0, 1 );
* // returns ~1.0
*
* @example
* var out = kernelTan( Math.PI/4.0, 0.0, -1 );
* // returns ~-1.0
*
* @example
* var out = kernelTan( Math.PI/6.0, 0.0, 1 );
* // returns ~0.577
*
* @example
* var out = kernelTan( 0.664, 5.288e-17, 1 );
* // returns ~0.783
*
* @example
* var out = kernelTan( NaN, 0.0, 1 );
* // returns NaN
*
* @example
* var out = kernelTan( 3.0, NaN, 1 );
* // returns NaN
*
* @example
* var out = kernelTan( NaN, NaN, 1 );
* // returns NaN
*/
function kernelTan( x, y, k ) {
	var hx;
	var ix;
	var a;
	var r;
	var s;
	var t;
	var v;
	var w;
	var z;

	hx = getHighWord( x );

	// High word of |x|:
	ix = hx & HIGH_WORD_ABS_MASK;

	// Case: |x| >= 0.6744
	if ( ix >= 0x3FE59428 ) {
		if ( x < 0 ) {
			x = -x;
			y = -y;
		}
		z = PIO4 - x;
		w = PIO4LO - y;
		x = z + w;
		y = 0.0;
	}
	z = x * x;
	w = z * z;

	// Break x^5*(T[1]+x^2*T[2]+...) into x^5(T[1]+x^4*T[3]+...+x^20*T[11]) + x^5(x^2*(T[2]+x^4*T[4]+...+x^22*T[12]))...
	r = polyvalOdd( w );
	v = z * polyvalEven( w );
	s = z * x;
	r = y + (z * ((s * (r + v)) + y));
	r += T0 * s;
	w = x + r;
	if ( ix >= 0x3FE59428 ) {
		v = k;
		return ( 1.0 - ( (hx >> 30) & 2 ) ) * ( v - (2.0 * (x - ((w * w / (w + v)) - r)) )); // eslint-disable-line max-len
	}
	if ( k === 1 ) {
		return w;
	}
	// Compute -1/(x+r) accurately...
	z = w;
	setLowWord( z, 0 );
	v = r - (z - x); // z + v = r + x
	a = -1.0 / w; // a = -1/w
	t = a;
	setLowWord( t, 0 );
	s = 1.0 + (t * z);
	return t + (a * (s + (t * v)));
} // end FUNCTION kernelTan()


// EXPORTS //

module.exports = kernelTan;
