'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link https://github.com/boostorg/math/blob/develop/include/boost/math/special_functions/detail/bessel_y1.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright Xiaogang Zhang, 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var ln = require( '@stdlib/math/base/special/ln' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var PI = require( '@stdlib/constants/math/float64-pi' );
var SQRT_PI = require( '@stdlib/constants/math/float64-sqrt-pi' );
var NINF = require( '@stdlib/constants/math/float64-ninf' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var sincos = require( '@stdlib/math/base/special/sincos' );
var besselj1 = require( '@stdlib/math/base/special/besselj1' );
var evalrational = require( '@stdlib/math/base/tools/evalrational' ).factory;


// VARIABLES //

var ONE_DIV_SQRT_PI = 1.0 / SQRT_PI;
var TWO_DIV_PI = 2.0 / PI;

var P1 = [
	4.0535726612579544093e+13,
	5.4708611716525426053e+12,
	-3.7595974497819597599e+11,
	7.2144548214502560419e+09,
	-5.9157479997408395984e+07,
	2.2157953222280260820e+05,
	-3.1714424660046133456e+02
];

var Q1 = [
	3.0737873921079286084e+14,
	4.1272286200406461981e+12,
	2.7800352738690585613e+10,
	1.2250435122182963220e+08,
	3.8136470753052572164e+05,
	8.2079908168393867438e+02,
	1.0
];

var P2 = [
	1.1514276357909013326e+19,
	-5.6808094574724204577e+18,
	-2.3638408497043134724e+16,
	4.0686275289804744814e+15,
	-5.9530713129741981618e+13,
	3.7453673962438488783e+11,
	-1.1957961912070617006e+09,
	1.9153806858264202986e+06,
	-1.2337180442012953128e+03
];

var Q2 = [
	5.3321844313316185697e+20,
	5.6968198822857178911e+18,
	3.0837179548112881950e+16,
	1.1187010065856971027e+14,
	3.0221766852960403645e+11,
	6.3550318087088919566e+08,
	1.0453748201934079734e+06,
	1.2855164849321609336e+03,
	1.0
];

var PC = [
	-4.4357578167941278571e+06,
	-9.9422465050776411957e+06,
	-6.6033732483649391093e+06,
	-1.5235293511811373833e+06,
	-1.0982405543459346727e+05,
	-1.6116166443246101165e+03,
	0.0
];

var QC = [
	-4.4357578167941278568e+06,
	-9.9341243899345856590e+06,
	-6.5853394797230870728e+06,
	-1.5118095066341608816e+06,
	-1.0726385991103820119e+05,
	-1.4550094401904961825e+03,
	1.0
];

var PS = [
	3.3220913409857223519e+04,
	8.5145160675335701966e+04,
	6.6178836581270835179e+04,
	1.8494262873223866797e+04,
	1.7063754290207680021e+03,
	3.5265133846636032186e+01,
	0.0
];

var QS = [
	7.0871281941028743574e+05,
	1.8194580422439972989e+06,
	1.4194606696037208929e+06,
	4.0029443582266975117e+05,
	3.7890229745772202641e+04,
	8.6383677696049909675e+02,
	1.0
];

var x1 = 2.1971413260310170351e+00;
var x2 = 5.4296810407941351328e+00;
var x11 = 5.620e+02;
var x12 = 1.8288260310170351490e-03;
var x21 = 1.3900e+03;
var x22 = -6.4592058648672279948e-06;

var sc = [ 0.0, 0.0 ];


// FUNCTIONS //

var poly1 = evalrational( P1, Q1 );
var poly2 = evalrational( P2, Q2 );
var polyC = evalrational( PC, QC );
var polyS = evalrational( PS, QS );


// MAIN //

/**
* Computes the Bessel function of the second kind of order zero.
*
* ## Notes
*
* -   Accuracy for subnormal `x` is very poor. Full accuracy is achieved at `1.0e-308` but trends progressively to zero at `5e-324`. This suggests that underflow (or overflow, perhaps due to a reciprocal) is effectively cutting off digits of precision until the computation loses all accuracy at `5e-324`.
*
* @param {number} x - input value
* @returns {number} evaluated Bessel function
*
* @example
* var v = y1( 0.0 );
* // returns -Infinity
*
* v = y1( 1.0 );
* // returns ~-0.781
*
* v = y1( -1.0 );
* // returns NaN
*
* v = y1( Infinity );
* // returns 0.0
*
* v = y1( -Infinity );
* // returns NaN
*
* v = y1( NaN );
* // returns NaN
*/
function y1( x ) {
	var rc;
	var rs;
	var y2;
	var r;
	var y;
	var z;
	var f;

	if ( x < 0.0 ) {
		return NaN;
	}
	if ( x === 0.0 ) {
		return NINF;
	}
	if ( x === PINF ) {
		return 0.0;
	}
	if ( x <= 4.0 ) {
		y = x * x;
		z = ( ln( x / x1 ) * besselj1( x ) ) * TWO_DIV_PI;
		r = poly1( y );
		f = ( ( x + x1 ) * ( ( x - (x11/256.0) ) - x12 ) ) / x;
		return z + ( f * r );
	}
	if ( x <= 8.0 ) {
		y = x * x;
		z = ( ln( x / x2 ) * besselj1( x ) ) * TWO_DIV_PI;
		r = poly2( y );
		f = ( ( x + x2 ) * ( ( x - (x21/256.0) ) - x22 ) ) / x;
		return z + ( f * r );
	}
	y = 8.0 / x;
	y2 = y * y;
	rc = polyC( y2 );
	rs = polyS( y2 );
	f = ONE_DIV_SQRT_PI / sqrt( x );

	/*
	* This code is really just:
	*
	* ```
	* z = x - 0.75 * PI;
	* return f * (rc * sin(z) + y * rs * cos(z));
	* ```
	*
	* But using the sin/cos addition rules, plus constants for sin/cos of `3PI/4` which then cancel out with corresponding terms in "f".
	*/
	sincos( sc, x );
	return f * ( ( ( (y*rs) * (sc[0]-sc[1]) ) - ( rc * (sc[0]+sc[1]) ) ) );
} // end FUNCTION y1()


// EXPORTS //

module.exports = y1;
