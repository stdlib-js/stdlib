'use strict';

// MODULES //

var pow = require( '@stdlib/math/base/special/pow' );
var powm1 = require( '@stdlib/math/base/special/powm1' );


// VARIABLES //

// -ln(eps)/2 => -ln(2.220446049250313e-16)/2 = 18.021826694558577
var N = 18|0; // asm type annotation

// 2**N
var TWO_N = 262144|0; // asm type annotation
var NEG_TWO_N = -TWO_N;


// MAIN //

/**
* Evaluates the Riemann zeta function using a polynomial series.
*
* #### References
*
* * P. Borwein. "An Efficient Algorithm for the Riemann Zeta Function". Canadian Mathematical Society, Conference Proceedings. See algorithm [3]{@link http://www.cecm.sfu.ca/personal/pborwein/PAPERS/P155.pdf}.
*
*
* @private
* @param {number} s - input value
* @returns {number} function value
*
* @example
* var v = zeta( 3.0 );
* // returns ~1.202
*/
function series( s ) {
	var sign;
	var term;
	var sum;
	var tmp;
	var N2;
	var i;

	sum = 0.0;
	sign = 1;
	for ( i = 0; i < N; i++ ) {
		sum += sign * NEG_TWO_N / pow(i+1, s);
		sign *= -1; // flip the sign
	}
	tmp = 1.0;
	term = 1.0;
	N2 = 2 * N;
	for ( i = N; i <= N2-1; i++ ) {
		sum += sign * (tmp - TWO_N) / pow(i+1, s);
		sign *= -1; // flip the sign
		term *= N2 - i;
		term /= i - N + 1.0;
		tmp += term;
	}
	return sum / (TWO_N * powm1(2.0, 1.0-s));
}


// EXPORTS //

module.exports = series;
