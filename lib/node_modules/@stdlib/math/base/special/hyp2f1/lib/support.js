/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var abs = require( '@stdlib/math/base/special/abs' );
var round = require( '@stdlib/math/base/special/round' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var isnan = require( '@stdlib/math/base/assert/is-nan' );
var floor = require( '@stdlib/math/base/special/floor' );
var gammaln = require( '@stdlib/math/base/special/gammaln' );
var exp = require( '@stdlib/math/base/special/exp' );
var gamma = require( '@stdlib/math/base/special/gamma' );
var log = require( '@stdlib/math/base/special/log' );
var digamma = require( '@stdlib/math/base/special/digamma' );
var pow = require( '@stdlib/math/base/special/pow' );
var isNegInt = require( '@stdlib/math/base/assert/is-negative-integer' );


// VARIABLES //

var EPS = 1.0e-13;
var MAX_ITERATIONS = 10000;
var MACHEP = 1.0e-12;
var ETHRESH = 1.0e-12;

/**
* Evaluates the Gaussian hypergeometric function.
*
* @private
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @param {Object} loss - loss
* @returns {number} function value
*
*/
function hys2f1( a, b, c, x, loss ) {
	var intflag;
	var umax;
	var ib;
	var u;
	var s;
	var m;
	var k;
	var h;
	var g;
	var f;
	var i;

	ib = 0;
	intflag = 0;

	if ( abs( b ) > abs( a ) ) {
		f = b;
		b = a;
		a = f;
	}

	ib = round( b );

	if ( abs( b - ib ) < EPS && ib <= 0 && abs( b ) < abs( a ) ) {
		f = b;
		b = a;
		a = f;
		intflag = 1;
	}

	// eslint-disable-next-line max-len
	if ( ( abs( a ) > ( abs( c ) + 1 ) || intflag === 1 ) && abs( c-a ) > 2 && abs( a ) > 2 ) {
		return hyp2f1ra( a, b, c, x, loss );
	}

	i = 0;
	umax = 0.0;
	f = a;
	g = b;
	h = c;
	s = 1.0;
	u = 1.0;
	k = 0.0;

	do {
		if ( abs( h ) < EPS ) {
			loss.v = 1.0;
			return PINF;
		}
		m = k + 1.0;
		u *= ( ( f + k ) * ( g + k ) * x / ( ( h + k ) * m ) );
		s += u;
		k = abs( u );
		if ( k > umax ) {
			umax = k;
		}
		i += 1;
		if ( i > MAX_ITERATIONS ) {
			loss.v = 1.0;
			return s;
		}
	} while ( s === 0 || abs( u / s ) > MACHEP );

	loss.v = ( ( MACHEP * umax ) / abs( s ) ) + ( MACHEP * i );

	return s;
}

/**
* Evaluates the Gaussian hypergeometric function.
*
* @private
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @param {Object} loss - loss
* @returns {number} function value
*
*/
function hyp2f1ra( a, b, c, x, loss ) {
	var err;
	var da;
	var f0;
	var f1;
	var f2;
	var n;
	var t;

	err = {
		'v': 0.0
	};

	if ( (c < 0 && a <= c) || ( c >= 0 && a >= c ) ) {
		da = round( a - c );
	} else {
		da = round( a );
	}
	t = a - da;

	loss.v = 0.0;

	// Assert: assert ( da != 0 )
	if ( abs( da ) > MAX_ITERATIONS ) {
		// Give up, too expensive to compute
		loss.v = 1.0;
		return NaN;
	}

	if ( da < 0 ) {
		// Recurse down
		f2 = 0.0;
		f1 = hys2f1( t, b, c, x, err );
		loss.v += err.v;
		f0 = hys2f1( t-1.0, b, c, x, err );
		loss.v += err.v;
		t -= 1.0;
		for (n = 1; n < -da; n++ ) {
			f2 = f1;
			f1 = f0;
			f0 = -(((2.0*t)-c-(t*x)+(b*x))/(c-t)*f1) - (t*(x-1)/(c-t)*f2);
			t -= 1.0;
		}
	} else {
		// Recurse up
		f2 = 0.0;
		f1 = hys2f1( t, b, c, x, err );
		loss.v += err.v;
		f0 = hys2f1( t + 1, b, c, x, err );
		loss.v += err.v;
		t += 1.0;
		for ( n = 1; n < da; n++ ) {
			f2 = f1;
			f1 = f0;
			f0 = -(((((2*t)-c-(t*x)+(b*x))*f1)+(c-t))*f2)/(t*(x-1.0));
			t += 1.0;
		}
	}
	return f0;
}

/**
* Evaluates the Gaussian hypergeometric function.
*
* @private
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @param {Object} loss - loss
* @returns {number} function value
*
*/
function hyt2f1( a, b, c, x, loss ) {
	var negIntA;
	var negIntB;
	var sign;
	var err1;
	var aid;
	var err;
	var d1;
	var d2;
	var ax;
	var id;
	var y1;
	var p;
	var q;
	var r;
	var s;
	var t;
	var y;
	var w;
	var d;
	var e;
	var i;

	y1 = 0.0;
	negIntA = isNegInt( a );
	negIntB = isNegInt( b );
	err = {
		'v': 0.0
	};
	err1 = {
		'v': 0.0
	};
	s = 1.0 - x;

	if ( x < -0.5 && !( negIntA || negIntB ) ) {
		if ( b > a ) {
			y = pow( s, -a ) * hys2f1( a, c - b, c, -x / s, err );
		}
		y = pow( s, -b ) * hys2f1( c - a, b, c, -x / s, err );

		// CEPHES: goto done
		loss.v = err.v;
		return y;
	}

	d = c - a - b;
	id = round( d );

	if ( x > 0.9 && !( negIntA || negIntB) ) {
		if ( abs( d - id ) > EPS ) {
			y = hys2f1( a, b, c, x, err );
			if ( err < ETHRESH ) { // CEPHES: goto done
				loss.v = err.v;
				return y;
			}
			q = hys2f1( a, b, 1.0-d, s, err);
			sign = 1;
			w = gammaln( d );
			sign *= logGammaSgn( d );
			w -= gammaln( c - a );
			sign *= logGammaSgn( c - a );
			w -= gammaln( c - b );
			sign *= logGammaSgn( c - b );
			q *= sign * exp( w );
			r = pow( s, d ) * hys2f1( c-a, c-b, d+1.0, s, err1);
			sign = 1;
			w = gammaln( -d );
			sign *= logGammaSgn( -d );
			w -= gammaln( a );
			sign *= logGammaSgn( a );
			w -= gammaln( b );
			sign *= logGammaSgn( b );
			r *= sign * exp( w );
			y = q + r;

			q = abs( q );
			r = abs( r );
			if ( q > r ) {
				r = q;
			}
			err.v += err1.v + ( ( MACHEP * r ) / y );
			y *= gamma( c );

			// CEPHES: goto done
			loss.v = err.v;
			return y;
		}

		if ( id >= 0.0 ) {
			e = d;
			d1 = d;
			d2 = 0.0;
			aid = id;
		} else {
			e = -d;
			d1 = 0.0;
			d2 = d;
			aid = -id;
		}
		ax = log( s );

		y = digamma( 1.0 )+
			digamma( 1.0+e )-
			digamma( a+d1 )-
			digamma( b+d1 )-
			ax;
		y /= gamma( e+1.0 );

		p = ( a+d1 )*( b+d1 )*s / gamma( e+2.0 );
		t = 1.0;
		do {
			r = digamma( 1.0+t )+
				digamma( 1.0+t+e )-
				digamma( a+t+d1 )-
				digamma( b+t+d1 )-
				ax;
			q = p * r;
			y += q;
			p *= s * ( a+t+d1 ) / ( t+1.0 );
			p *= ( b+t+d1 ) / ( t+1.0+e );
			t += 1.0;
			if ( t > MAX_ITERATIONS ) {
				loss.v = 1.0;
				return NaN;
			}
		} while ( y === 0 || abs( q/y ) > EPS );

		if ( id === 0.0 ) {
			y *= gamma( c ) / ( gamma( a ) * gamma( b ) );

			// CEPHES: goto psidon
			loss.v = err.v;
			return y;
		}

		y1 = 1.0;

		if ( aid === 1 ) {
			p = gamma(c);
			y1 *= gamma(e) * p / (gamma(a + d1) * gamma(b + d1));
			y *= p / (gamma(a + d2) * gamma(b + d2));
			if ((aid & 1) !== 0) {
				y = -y;
			}

			q = pow(s, id);	/* s to the id power */
			if (id > 0.0) {
				y *= q;
			} else {
				y1 *= q;
			}
			y += y1;
		}

		t = 0.0;
		p = 1.0;
		for ( i=1; i< aid; i++ ) {
			r = 1.0 - e + t;
			p *= s * ( a+t+d2 ) * ( b+t+d2 ) / r;
			t += 1.0;
			p /= t;
			y1 += p;
		}
	}

	y = hys2f1(a, b, c, x, err);
	loss.v = err.v;
	return y;
}

/**
* Evaluates the sign of log of gamma function.
*
* @private
* @param {number} x - input value
* @returns {number} function value
*
*/
function logGammaSgn( x ) {
	var fx;
	if ( isnan( x ) ) {
		return x;
	}
	if ( x > 0 ) {
		return 1.0;
	}

	fx = floor( x );
	if ( x - fx === 0.0 ) {
		return 0.0;
	}

	if ( fx % 2 === 0 ) {
		return -1.0;
	}

	return 1.0;
}

module.exports = {
	'hyt2f1': hyt2f1,
	'hys2f1': hys2f1
};
