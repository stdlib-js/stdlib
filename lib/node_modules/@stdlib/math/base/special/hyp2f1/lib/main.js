/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var abs = require( '@stdlib/math/base/special/abs' );
var gamma = require( '@stdlib/math/base/special/gamma' );
var round = require( '@stdlib/math/base/special/round' );
var isNegInt = require( '@stdlib/math/base/assert/is-negative-integer' );
var pow = require( '@stdlib/math/base/special/pow' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var max = require( '@stdlib/math/base/special/max' );
var hys2f1 = require( './support.js' ).hys2f1;
var hyt2f1 = require( './support.js' ).hyt2f1;


// VARIABLES //

var EPS = 1.0e-13;
var ETHRESH = 1.0e-12;


// MAIN //

/**
* Evaluates the Gaussian hypergeometric function.
*
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @returns {number} function value
*
* @example
* var v = hyp2f1( 1.0, 1.0, 1.0, 0.0 );
* // returns 1.0
*/
function hyp2f1( a, b, c, x ) {
	var negIntCaOrCb;
	var negIntA;
	var negIntB;
	var err;
	var aid;
	var ax;
	var ia;
	var ib;
	var ic;
	var id;
	var t1;
	var d1;
	var d2;
	var i;
	var d;
	var e;
	var p;
	var q;
	var r;
	var s;
	var y;

	if ( x === 0.0 ) {
		return 1.0;
	}

	if ( ( a === 0 || b === 0 ) && c !== 0 ) {
		return 1.0;
	}

	negIntA = isNegInt(a);
	negIntB = isNegInt(b);

	negIntCaOrCb = 0;
	err = {
		'v': 0.0
	};
	ax = abs( x );
	s = 1.0 - x;
	ia = round( a );
	ib = round( b );

	d = c - a - b;
	id = round( d );

	// eslint-disable-next-line max-len
	if ( d <= -1 && !( abs( d - id ) > EPS && s < 0) && !( negIntA || negIntB ) ) {
		return pow( s, d ) * hyp2f1( c-a, c-b, c, x );
	}

	if ( d <= 0 && x === 1 && !( negIntA || negIntB )) {
		// CEPHES: goto hypdiv
		return PINF;
	}
	if ( ax < 1.0 || x === -1.0 ) { // 2F1(a,b;b;x) = (1-x)**(-a)
		if ( abs( b-c ) < EPS ) { // b = c
			if ( negIntB ) {
				y = hyp2f1NegCEqualBC( a, b, x );
			} else {
				y = pow( s, -a );
			}
			// CEPHES: goto hypdon
			return y;
		}
		if ( abs( a - c ) < EPS ) { // a = c
			y = pow( s, -b );
			return y;
		}
	}
	if ( c <= 0.0 ) {
		ic = round( c );
		if ( abs( c - ic ) < EPS ) { // c is negative integer
			// Check termination before explosion
			if ( negIntA && ( ia > ic ) ) {
				// CEPHES: goto hypok
				y = hyt2f1( a, b, c, x, err );
				return y;
			}
			if ( negIntB && ( ib > ic ) ) {
				// CEPHES: goto hypok
				y = hyt2f1( a, b, c, x, err );
				return y;
			}
			// CEPHES: goto hypdiv
			return PINF;
		}
	}

	if ( negIntA || negIntB ) { // function in polynomial
		// CEPHES: goto hypok
		y = hyt2f1( a, b, c, x, err );
		return y;
	}
	t1 = abs( b - a );
	if ( x < -2.0 && abs( t1 - round(t1) ) > EPS ) {
		// This transform has a pole for b-a integer, and may produce large cancellation errors for |1/x| close to 1
		p = hyp2f1(	a, 1 - c + a, 1 - b + a, 1.0 / x );
		q = hyp2f1(	b, 1 - c + b, 1 - a + b, 1.0 / x );
		p *= pow( -x, -a );
		q *= pow( -x, -b );
		t1 = gamma( c );
		s = t1 * gamma( b - a ) / (gamma( b ) * gamma( c - a ) );
		y = t1 * gamma( a - b ) / (gamma( a ) * gamma( c - b ) );
		return ( s * p ) + ( y * q );
	}
	if ( x < -1.0 ) {
		if ( abs( a ) < abs( b ) ) {
			return pow( s, -a ) * hyp2f1( a, c-b, c, x / ( x-1 ) );
		}
		return pow( s, -b ) * hyp2f1( b, c-a, c, x / ( x-1 ) );
	}
	if ( ax > 1.0 ) { // series diverges
		// CEPHES: goto hypdiv
		return PINF;
	}

	p = c - a;
	ia = round( p ); // Nearest integer to c-a
	if ( ( ia <= 0.0 ) && ( abs( p - ia ) < EPS ) ) { // negative int c-a
		negIntCaOrCb = 1;
	}

	r = c - b;
	ib = round( r ); // Nearest integer to c-b
	if ( ( ib <= 0.0 ) && ( abs( r - ib ) < EPS ) ) { // negative int c-b
		negIntCaOrCb = 1;
	}

	id = round( d );
	q = abs( d - id );

	if ( abs( ax - 1.0 ) < EPS ) { // |x| = 1.0
		if ( x > 0.0 ) {
			if ( negIntCaOrCb === 1 ) {
				if ( d >= 0.0 ) { // goto hypf
					y = pow( s, d ) * hys2f1( c-a, c-b, c, x, err );
					return y;
				}
				// CEPHES: goto hypdiv
				return PINF;
			}
			if ( d <= 0.0 ) { // goto hypdiv
				return PINF;
			}
			y = gamma( c ) * gamma( d ) / ( gamma( p ) * gamma( r ) );
			return y;
		}
		if ( d <= -1.0 ) {
			return PINF;
		}
		if ( d < 0.0 ) {
			y = hyt2f1( a, b, c, x, err );
			if ( err.v < ETHRESH ) {
				return y;
			}
			err.v = 0.0;
			aid = 2 - id;
			e = c + aid;
			d2 = hyp2f1( a, b, e, x );
			d1 = hyp2f1( a, b, e+1.0, x );
			q = a + b + 1.0;
			for (i = 0; i < aid; i++) {
				r = e - 1.0;

				// eslint-disable-next-line max-len
				y = ( e * ( r - ( ( ( 2.0 * e ) - q ) * x ) ) * d2 ) + ( ( ( e - a ) * ( e - b ) * x * d1 ) / ( e * r * s ) );
				e = r;
				d1 = d2;
				d2 = y;
			}
			return y;
		}

		if ( negIntCaOrCb ) {
			y = pow( s, d ) * hys2f1( c - a, c - b, c, x, err );
			return y;
		}
	}
}

/**
* Evaluates the Gaussian hypergeometric function.
*
* @param {number} a - input value
* @param {number} b - input value
* @param {number} x - input value
* @returns {number} function value
*
*/
function hyp2f1NegCEqualBC( a, b, x ) {
	var collectorMax;
	var collector;
	var sum;
	var k;

	sum = 1;
	collector = 1;
	collectorMax = 1;

	if ( !( abs( b ) < 1e5 ) ) {
		return NaN;
	}

	for ( k = 1; k <= -b; k++ ) {
		collector *= ( a + k - 1) * (x / k);
		collectorMax = max( abs( collector ), collectorMax );
		sum += collector;
	}

	if ( 1e-16 * (1 + ( collectorMax / abs( sum ) ) ) > 1e-7 ) {
		return NaN;
	}

	return sum;
}


// EXPORTS //

module.exports = hyp2f1;
