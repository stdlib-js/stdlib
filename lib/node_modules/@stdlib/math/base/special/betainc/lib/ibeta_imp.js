'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/beta.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* (C) Copyright John Maddock 2006.
* (C) Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var expm1 = require( '@stdlib/math/base/special/expm1' );
var floor = require( '@stdlib/math/base/special/floor' );
var log1p = require( '@stdlib/math/base/special/log1p' );
var asin = require( '@stdlib/math/base/special/asin' );
var beta = require( '@stdlib/math/base/special/beta' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var MAX_FLOAT64 = require( '@stdlib/math/constants/float64-max' );
var MIN_FLOAT64 = require( '@stdlib/math/constants/float64-smallest-normal' );
var MAX_INT32 = require( '@stdlib/math/constants/int32-max' );
var HALF_PI = require( '@stdlib/math/constants/float64-half-pi' );
var PI = require( '@stdlib/math/constants/float64-pi' );
var beta_small_b_large_a_series = require( './beta_small_b_large_a_series.js' );
var rising_factorial_ratio = require( './rising_factorial_ratio.js' );
var ibeta_power_terms = require( './ibeta_power_terms.js' );
var ibeta_fraction2 = require( './ibeta_fraction2.js');
var binomial_ccdf = require( './binomial_ccdf.js' );
var ibeta_a_step = require( './ibeta_a_step.js' );
var ibeta_series = require( './ibeta_series.js' );


// FUNCTIONS //

var max = Math.max;
var min = Math.min;


// IBETA IMPLEMENTATION //

/**
* Evaluates the incomplete beta function. This function divides up the input range and selects the right implementation method for each domain.
*
* @private
* @param {NonNegativeNumber} a - function parameter
* @param {NonNegativeNumber} b - function parameter
* @param {Probability} x - function input
* @param {boolean} invert - boolean indicating if the function should return the upper tail of the incomplete beta function instead
* @param {boolean} normalised - boolean indicating if the function should evaluate the regularized incomplete beta function
* @param {Object} [pderiv] - derivative container
* @returns {number} function value
*/
function ibeta_imp( a, b, x, invert, normalised, pderiv ) {
	// jshint maxstatements: 400
	var lambda;
	var prefix;
	var fract;
	var bbar;
	var div;
	var tmp;
	var k;
	var n;
	var p;
	var y;
	y = 1.0 - x;
	if ( pderiv ) {
		// Value not set...
		pderiv.value = -1;
	}
	if ( x < 0.0 || x > 1.0 ) {
		return NaN;
	}
	if ( normalised ) {
		if ( a < 0.0 || b < 0.0 ) {
			return NaN;
		}
		// Extend to a few very special cases...
		if ( a === 0.0 ) {
			if ( b === 0.0 ) {
				return NaN;
			}
			if ( b > 0.0 ) {
				return invert ? 0.0 : 1.0;
			}
		} else if ( b === 0.0 ) {
			if ( a > 0.0 ) {
				return invert ? 1.0 : 0.0;
			}
		}
	} else {
		if ( a <= 0 || b <= 0 ) {
			return NaN;
		}
	 }
	if ( x === 0 ) {
		if ( pderiv ) {
			pderiv.value = (a === 1) ? 1 : (a < 1) ? MAX_FLOAT64 / 2 : MIN_FLOAT64 * 2;
		}
		return invert ? (normalised ? 1.0 : beta(a, b) ) : 0.0;
	}
	if ( x === 1 ) {
		if ( pderiv ) {
			pderiv.value = (b === 1) ? 1 : (b < 1) ? MAX_FLOAT64 / 2 : MIN_FLOAT64 * 2;
		}
		return invert === 0 ? (normalised ? 1.0 : beta(a, b)) : 0.0;
	}
	if ( a === 0.5 && b === 0.5 ) {
		if ( pderiv ) {
			pderiv.value = 1.0 / PI * sqrt( y * x );
		}
		// We have an arcsine distribution:
		p = invert ? asin( sqrt(y) ) : asin( sqrt(x) );
		p /= HALF_PI;
		if ( !normalised ) {
			p *= PI;
		}
		return p;
	}
	if ( a === 1.0 ) {
		tmp = b;
		b = a;
		a = tmp;

		tmp = y;
		y = x;
		x = tmp;

		invert = !invert;
	}
	if ( b === 1.0 ) {
		// Special case see: http://functions.wolfram.com/GammaBetaErf/BetaRegularized/03/01/01/
		if ( a === 1.0 ) {
			if ( pderiv ) {
				pderiv.value = 1.0;
			}
			return invert ? y : x;
		}
		if ( pderiv ) {
			pderiv.value = a * pow( x, a - 1.0 );
		}
		if ( y < 0.5 ) {
			p = invert ? -expm1(a * log1p(-y)) : exp(a * log1p(-y));
		} else {
			p = invert ? -( pow( x, a ) - 1 ) : pow( x, a );
	 	}
		if( !normalised ) {
			p /= a;
		}
		return p;
	}
	if ( min(a, b) <= 1.0 ) {
		if ( x > 0.5 ) {
			tmp = b;
			b = a;
			a = tmp;

			tmp = y;
			y = x;
			x = tmp;

			invert = !invert;
		}
		if ( max( a, b ) <= 1.0 ) {
			// Both a,b < 1:
			if( (a >= min( 0.2, b ) ) || ( pow(x, a) <= 0.9 ) ) {
				if ( !invert ) {
					fract = ibeta_series(a, b, x, 0, normalised, pderiv, y );
				} else {
					fract = -(normalised ? 1 : beta( a, b ) );
					invert = false;
					fract = -ibeta_series(a, b, x, fract, normalised, pderiv, y );
				}
			} else {
				tmp = b;
				b = a;
				a = tmp;

				tmp = y;
				y = x;
				x = tmp;

				invert = !invert;
				if ( y >= 0.3 ) {
					if ( !invert ) {
						fract = ibeta_series( a, b, x, 0, normalised, pderiv, y );
					} else {
						fract = -( normalised ? 1.0 : beta( a, b ) );
						invert = false;
						fract = -ibeta_series( a, b, x, fract, normalised, pderiv, y );
					}
				} else {
					// Sidestep on a, and then use the series representation:
					if ( !normalised ) {
						prefix = rising_factorial_ratio( a + b, a, 20 );
					} else {
						prefix = 1;
					}
					fract = ibeta_a_step( a, b, x, y, 20, normalised, pderiv );
					if ( !invert ) {
						fract = beta_small_b_large_a_series( a + 20, b, x, y, fract, prefix, normalised );
					} else {
						fract -= ( normalised ? 1 : beta( a, b ) );
						invert = false;
						fract = -beta_small_b_large_a_series( a + 20, b, x, y, fract, prefix, normalised );
					}
				}
			}
		} else {
			// One of a, b < 1 only:
			if ( b <= 1 || (x < 0.1) && ( pow(b * x, a) <= 0.7 ) ) {
				if ( !invert ) {
					fract = ibeta_series( a, b, x, 0, normalised, pderiv, y );
				} else {
					fract = -( normalised ? 1 : beta( a, b ) );
					invert = false;
					fract = -ibeta_series( a, b, x, fract, normalised, pderiv, y );
				}
			} else {
				tmp = b;
				b = a;
				a = tmp;

				tmp = y;
				y = x;
				x = tmp;
				invert = !invert;

				if ( y >= 0.3 ) {
					if (!invert) {
						fract = ibeta_series(a, b, x, 0, normalised, pderiv, y );
					} else {
						fract = -(normalised ? 1 : beta( a, b ));
						invert = false;
						fract = -ibeta_series(a, b, x, fract, normalised, pderiv, y );
					}
				}
				else if ( a >= 15 ) {
					if(!invert) {
						fract = beta_small_b_large_a_series( a, b, x, y, 0, 1, normalised );
					} else {
						fract = -(normalised ? 1 : beta( a, b ));
						invert = false;
						fract = -beta_small_b_large_a_series( a, b, x, y, fract, 1, normalised );
					}
				}
				else {
					// Sidestep to improve errors:
					if ( !normalised ) {
						prefix = rising_factorial_ratio( a + b, a, 20 );
					} else {
						prefix = 1;
					}
					fract = ibeta_a_step( a, b, x, y, 20, normalised, pderiv );
					if ( !invert ) {
						fract = beta_small_b_large_a_series( a + 20, b, x, y, fract, prefix, normalised );
					} else {
						fract -= ( normalised ? 1 : beta( a, b ) );
						invert = false;
						fract = -beta_small_b_large_a_series( a + 20, b, x, y, fract, prefix, normalised );
					}
				}
			}
		}
	} else {
		// Both a,b >= 1:
		if ( a < b ) {
			lambda = a - (a + b) * x;
		} else {
			lambda = (a + b) * y - b;
		}
		if ( lambda < 0.0 ) {
			tmp = b;
			b = a;
			a = tmp;

			tmp = y;
			y = x;
			x = tmp;
			invert = !invert;
		}
		if ( b < 40.0 ) {
			if (
				floor(a) === a &&
				floor(b) === b &&
				a < MAX_INT32 - 100
			) {
				// Relate to the binomial distribution and use a finite sum:
				k = a - 1;
				n = b + k;
				fract = binomial_ccdf( n, k, x, y );
				if (!normalised) {
					fract *= beta( a, b );
				}
			}
			else if ( b * x <= 0.7 ) {
				if( !invert ) {
					fract = ibeta_series( a, b, x, 0, normalised, pderiv, y );
				} else {
					fract = -( normalised ? 1 : beta( a, b ) );
					invert = false;
					fract = -ibeta_series( a, b, x, fract, normalised, pderiv, y );
				}
			}
			else if ( a > 15.0 ) {
				// Sidestep so we can use the series representation:
				n = floor( b );
				if ( n === b ) {
					--n;
				}
				bbar = b - n;
				if ( !normalised ) {
					prefix = rising_factorial_ratio( a + bbar, bbar, n );
				} else {
					prefix = 1;
				}
				fract = ibeta_a_step( bbar, a, y, x, n, normalised );
				fract = beta_small_b_large_a_series( a, bbar, x, y, fract, 1.0, normalised );
				fract /= prefix;
			}
			else if ( normalised ) {
				n = floor( b );
				bbar = b - n;
				if ( bbar <= 0 ) {
					--n;
					bbar += 1;
				}
				fract = ibeta_a_step( bbar, a, y, x, n, normalised );
				fract += ibeta_a_step( a, bbar, x, y, 20, normalised );
				if ( invert ) {
					fract -= 1;
				}
				fract = beta_small_b_large_a_series( a + 20.0, bbar, x, y, fract, 1, normalised );
				if ( invert ) {
					fract = -fract;
					invert = false;
				}
			}
			else {
				fract = ibeta_fraction2( a, b, x, y, normalised, pderiv );
			}
		} else {
			fract = ibeta_fraction2( a, b, x, y, normalised, pderiv );
		}
	}
	if ( pderiv ) {
		if ( pderiv.value < 0.0 ) {
			pderiv.value = ibeta_power_terms( a, b, x, y, true );
		}
		div = y * x;
		if( pderiv.value !== 0.0 ) {
			if( ( MAX_FLOAT64 * div < pderiv.value ) ) {
				// Overflow, return an arbitarily large value:
				pderiv.value = MAX_FLOAT64 / 2.0;
			} else {
				pderiv.value /= div;
			}
		}
	}
	return invert ? ( normalised ? 1.0 : beta( a, b ) ) - fract : fract;
} // end FUNCTION ibeta_imp()


// EXPORTS //

module.exports = ibeta_imp;
