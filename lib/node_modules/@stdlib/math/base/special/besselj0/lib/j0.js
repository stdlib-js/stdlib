'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link https://github.com/boostorg/math/blob/develop/include/boost/math/special_functions/detail/bessel_j0.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright Xiaogang Zhang, 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var sqrt = require( '@stdlib/math/base/special/sqrt' );
var sincos = require( '@stdlib/math/base/special/sincos' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var evalrational = require( '@stdlib/math/base/tools/evalrational' ).factory;


// VARIABLES //

var ONE_DIV_SQRT_PI = 0.5641895835477563;

var P1 = [
	-4.1298668500990866786e+11,
	2.7282507878605942706e+10,
	-6.2140700423540120665e+08,
	6.6302997904833794242e+06,
	-3.6629814655107086448e+04,
	1.0344222815443188943e+02,
	-1.2117036164593528341e-01
];

var Q1 = [
	2.3883787996332290397e+12,
	2.6328198300859648632e+10,
	1.3985097372263433271e+08,
	4.5612696224219938200e+05,
	9.3614022392337710626e+02,
	1.0,
	0.0
];

var P2 = [
	-1.8319397969392084011e+03,
	-1.2254078161378989535e+04,
	-7.2879702464464618998e+03,
	1.0341910641583726701e+04,
	1.1725046279757103576e+04,
	4.4176707025325087628e+03,
	7.4321196680624245801e+02,
	4.8591703355916499363e+01
];

var Q2 = [
	-3.5783478026152301072e+05,
	2.4599102262586308984e+05,
	-8.4055062591169562211e+04,
	1.8680990008359188352e+04,
	-2.9458766545509337327e+03,
	3.3307310774649071172e+02,
	-2.5258076240801555057e+01,
	1.0
];

var PC = [
	2.2779090197304684302e+04,
	4.1345386639580765797e+04,
	2.1170523380864944322e+04,
	3.4806486443249270347e+03,
	1.5376201909008354296e+02,
	8.8961548424210455236e-01
];

var QC = [
	2.2779090197304684318e+04,
	4.1370412495510416640e+04,
	2.1215350561880115730e+04,
	3.5028735138235608207e+03,
	1.5711159858080893649e+02,
	1.0
];

var PS = [
	-8.9226600200800094098e+01,
	-1.8591953644342993800e+02,
	-1.1183429920482737611e+02,
	-2.2300261666214198472e+01,
	-1.2441026745835638459e+00,
	-8.8033303048680751817e-03
];

var QS = [
	5.7105024128512061905e+03,
	1.1951131543434613647e+04,
	7.2642780169211018836e+03,
	1.4887231232283756582e+03,
	9.0593769594993125859e+01,
	1.0
];

var x1 = 2.4048255576957727686e+00;
var x2 = 5.5200781102863106496e+00;
var x11 = 6.160e+02;
var x12 = -1.42444230422723137837e-03;
var x21 = 1.4130e+03;
var x22 = 5.46860286310649596604e-04;

var sc = [ 0.0, 0.0 ];


// FUNCTIONS //

var poly1 = evalrational( P1, Q1 );
var poly2 = evalrational( P2, Q2 );
var polyC = evalrational( PC, QC );
var polyS = evalrational( PS, QS );


// MAIN //

/**
* Computes the Bessel function of the first kind of order zero.
*
* @param {number} x - input value
* @returns {number} evaluated Bessel function
*
* @example
* var v = j0( 0.0 );
* // returns 1.0
*
* v = j0( 1.0 );
* // returns ~0.765
*
* v = j0( Infinity );
* // returns 0.0
*
* v = j0( -Infinity );
* // returns 0.0
*
* v = j0( NaN );
* // returns NaN
*/
function j0( x ) {
	var rc;
	var rs;
	var y2;
	var r;
	var y;
	var f;

	if ( x < 0 ) {
		x = -x;
	}
	if ( x === PINF ) {
		return 0.0;
	}
	if ( x === 0 ) {
		return 1.0;
	}
	if ( x <= 4.0 ) {
		y = x * x;
		r = poly1( y );
		f = ( x + x1 ) * ( (x - ( x11 / 256.0 ) ) - x12 );
		return f * r;
	}
	if ( x <= 8.0 ) {
		y = 1.0 - ( ( x * x ) / 64.0 );
		r = poly2( y );
		f = ( x + x2 ) * ( (x - ( x21 / 256.0 ) ) - x22 );
		return f * r;
	}
	y = 8.0 / x;
	y2 = y * y;
	rc = polyC( y2 );
	rs = polyS( y2 );
	f = ONE_DIV_SQRT_PI / sqrt(x);

	/*
	* What follows is really just:
	*
	* ```
	* var z = x - pi/4;
	* return f * (rc * cos(z) - y * rs * sin(z));
	* ```
	*
	* But using the addition formulae for sin and cos, plus the special values for sin/cos of `pi/4`.
	*/
	sincos( sc, x );
	return f * ( ( rc * (sc[1]+sc[0]) ) - ( (y*rs) * (sc[0]-sc[1]) ) );
} // end FUNCTION j0()


// EXPORTS //

module.exports = j0;
