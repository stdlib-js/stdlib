'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link https://github.com/boostorg/math/blob/develop/include/boost/math/special_functions/detail/bessel_j0.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright (c) 2007, 2013 John Maddock
* Copyright Christopher Kormanyos 2013.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var sqrt = require( '@stdlib/math/base/special/sqrt' );
var sincos = require( '@stdlib/math/base/special/sincos' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var evaluateRational = require( './evaluate_rational.js' );


// VARIABLES //

var ONE_DIV_SQRT_PI = 0.5641895835477563;

var P1 = [
	-4.1298668500990866786e+11,
	2.7282507878605942706e+10,
	-6.2140700423540120665e+08,
	6.6302997904833794242e+06,
	-3.6629814655107086448e+04,
	1.0344222815443188943e+02,
	-1.2117036164593528341e-01
];

var Q1 = [
	2.3883787996332290397e+12,
	2.6328198300859648632e+10,
	1.3985097372263433271e+08,
	4.5612696224219938200e+05,
	9.3614022392337710626e+02,
	1.0,
	0.0
];

var P2 = [
	-1.8319397969392084011e+03,
	-1.2254078161378989535e+04,
	-7.2879702464464618998e+03,
	1.0341910641583726701e+04,
	1.1725046279757103576e+04,
	4.4176707025325087628e+03,
	7.4321196680624245801e+02,
	4.8591703355916499363e+01
];

var Q2 = [
	-3.5783478026152301072e+05,
	2.4599102262586308984e+05,
	-8.4055062591169562211e+04,
	1.8680990008359188352e+04,
	-2.9458766545509337327e+03,
	3.3307310774649071172e+02,
	-2.5258076240801555057e+01,
	1.0
];

var PC = [
	2.2779090197304684302e+04,
	4.1345386639580765797e+04,
	2.1170523380864944322e+04,
	3.4806486443249270347e+03,
	1.5376201909008354296e+02,
	8.8961548424210455236e-01
];

var QC = [
	2.2779090197304684318e+04,
	4.1370412495510416640e+04,
	2.1215350561880115730e+04,
	3.5028735138235608207e+03,
	1.5711159858080893649e+02,
	1.0
];

var PS = [
	-8.9226600200800094098e+01,
	-1.8591953644342993800e+02,
	-1.1183429920482737611e+02,
	-2.2300261666214198472e+01,
	-1.2441026745835638459e+00,
	-8.8033303048680751817e-03
];

var QS = [
	5.7105024128512061905e+03,
	1.1951131543434613647e+04,
	7.2642780169211018836e+03,
	1.4887231232283756582e+03,
	9.0593769594993125859e+01,
	1.0
];

var x1 = 2.4048255576957727686e+00;
var x2 = 5.5200781102863106496e+00;
var x11 = 6.160e+02;
var x12 = -1.42444230422723137837e-03;
var x21 = 1.4130e+03;
var x22 = 5.46860286310649596604e-04;

var sc = [];

// MAIN //

/**
* Computes the Bessel function of the first kind of order zero.
*
* @private
* @param {number} x - input value
* @returns {number} evaluated Bessel function
*
* @example
* var v = besselj0( 0.0 );
* // returns 1.0
*
* v = besselj0( 1.0 );
* // returns 0.76519768655796649
*
* v = besselj0( NaN );
* // returns NaN
*/
function besselj0( x ) {
	var rc;
	var rs;
	var y2;
	var r;
	var y;
	var f;

	if ( x < 0 ) {
		x = -x;
	}
	if ( x === PINF ) {
		return 0.0;
	}
	if ( x === 0 ) {
		return 1.0;
	}
	if ( x <= 4.0 ) {
		y = x * x;
		r = evaluateRational( P1, Q1, y );
		f = ( x + x1 ) * ( (x - ( x11 / 256.0 ) ) - x12 );
		return f * r;
	} else if ( x <= 8.0 ) {
		y = 1 - ( ( x * x ) / 64.0 );
		r = evaluateRational( P2, Q2, y );
		f = ( x + x2 ) * ( (x - ( x21 / 256.0 ) ) - x22 );
		return f * r;
	}

	y = 8.0 / x;
	y2 = y * y;
	rc = evaluateRational( PC, QC, y2 );
	rs = evaluateRational( PS, QS, y2 );
	f = ONE_DIV_SQRT_PI / sqrt(x);
	//
	// What follows is really just:
	//
	// var z = x - pi/4;
	// return f * (rc * cos(z) - y * rs * sin(z));
	//
	// But using the addition formulae for sin and cos, plus
	// the special values for sin/cos of pi/4.
	//
	sincos(sc, x);
	return f * ( ( rc * ( sc[1] + sc[0] ) ) - ( ( y*rs ) * (sc[0] - sc[1]) ) );
} // end FUNCTION besselj0()


// EXPORTS //

module.exports = besselj0;
