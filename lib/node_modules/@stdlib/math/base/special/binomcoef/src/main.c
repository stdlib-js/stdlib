/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/math/base/special/binomcoef.h"
#include "stdlib/math/base/special/floor.h"
#include "stdlib/math/base/special/gcd.h"
#include "stdlib/math/base/assert/is_odd.h"
#include "stdlib/constants/float64/pinf.h"
#include "stdlib//constants/float64/max_safe_integer.h"
#include <stdint.h>

/**
* Computes the binomial coefficient of two integers.
*
* @param n    input value
* @param k    second input value
* @return     function value
*
* @example
* double out = stdlib_base_binomcoef( 8, 2 );
* // returns 28.0
*/
double stdlib_base_binomcoef( const int32_t n, const int32_t k ) {
	double res;
    int8_t sgn;
    int32_t nc;
    int32_t kc;
    int32_t d;
    double b;
    double c;
    double g;
    double s;

    // printf("Initial values: n: %d, k: %d\n", n, k);

    if (k < 0) {
        return 0;
    }
    sgn = 1;
    nc = n;
    if (nc < 0) {
        nc = -nc + k - 1;
        if (stdlib_base_is_odd((double)k)) {
            sgn *= -1;
        }
    }
    // printf("After handling negative n: nc: %d, sgn: %d\n", nc, sgn);

    if (k > nc) {
        return 0;
    }
    if (k == 0 || k == nc) {
        return sgn;
    }
    if (k == 1 || k == nc - 1) {
        return sgn * nc;
    }

    // Minimize the number of computed terms by leveraging symmetry:
    kc = k;
    if (nc - kc < kc) {
        kc = nc - kc;
    }
    // printf("After symmetry adjustment: kc: %d\n", kc);

    s = stdlib_base_floor((double)STDLIB_CONSTANT_FLOAT64_MAX_SAFE_INTEGER / (double)nc);
    // printf("s (MAX_SAFE_INTEGER / nc): %.15g\n", s);

    // Use a standard algorithm for computing the binomial coefficient
    res = 1.0;
    for (d = 1; d <= kc; d++) {
        // Check for potential overflow...
        if (res > s) {
            break;
        }
        res *= nc;
        res /= d;
        nc -= 1;
        // printf("Intermediate res: %.15g, nc: %d, d: %d\n", res, nc, d);
    }

    // If we did not early exit from the previous loop, the answer is exact, and we can simply return...
    if (d > kc) {
        // printf("Final result before returning: res: %.15g, sgn: %d\n", res, sgn);
        // printf("Final value to return: sgn * res: %.15g\n", sgn*res);
        return sgn * res;
    }

    b = stdlib_base_binomcoef(nc, kc - d + 1);
    if (b == STDLIB_CONSTANT_FLOAT64_PINF) {
        return sgn * b;
    }
    c = stdlib_base_binomcoef(kc, kc - d + 1);

    // printf("Recursive calls: b: %d, c: %d\n", b, c);

    // Calculate the greatest common divisor (gcd)
    g = stdlib_base_gcd((double)b, (double)c);
    b /= g;
    c /= g;
    res /= c;

    // printf("Final result: res: %.15g, sgn: %d, b: %d\n", res, sgn, b);

    return sgn * res * b;
}
