'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_37_0/boost/math/special_functions/gamma.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* (C) Copyright John Maddock 2006.
* (C) Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var gammaln = require( '@stdlib/math/base/special/gammaln' );
var floor = require( '@stdlib/math/base/special/floor' );
var gamma = require( '@stdlib/math/base/special/gamma' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var ln = require( '@stdlib/math/base/special/ln' );
var SQRT_EPSILON = require( '@stdlib/math/constants/float64-sqrt-eps' );
var FLOAT64_MAX = require( '@stdlib/math/constants/float64-max' );
var SQRT_TWO_PI = require( '@stdlib/math/constants/float64-sqrt-two-pi' );
var MAX_LN = require( '@stdlib/math/constants/float64-max-ln' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var finite_gamma_q = require( './finite_gamma_q.js' );
var finite_half_gamma_q = require( './finite_half_gamma_q.js' );
var full_igamma_prefix = require( './full_igamma_prefix.js' );
var igamma_temme_large = require( './igamma_temme_large.js' );
var lower_gamma_series = require( './lower_gamma_series.js' );
var regularised_gamma_prefix = require( './regularised_gamma_prefix.js' );
var tgamma_small_upper_part = require( './tgamma_small_upper_part.js' );
var upper_gamma_fraction = require( './upper_gamma_fraction.js' );


// CONSTANTS //

var MAX_FACTORIAL = 170; // TODO: consider extracting as a constant


// INCOMPLETE GAMMA FUNCTION //

/**
* Computes the regularized incomplete gamma function. The upper tail is calculated via the modified Lentz's method for computing continued fractions, the lower tail using a power expansion.
*
* @param {NonNegativeNumber} x - function parameter
* @param {PositiveNumber} s - function parameter
* @param {boolean} [regularized=true] - boolean indicating if the function should evaluate the regularized or non-regularized incomplete gamma functions
* @param {boolean} [upper=false] - boolean indicating if the function should return the upper tail of the incomplete gamma function
* @returns {number} function value
*/
function gammainc( x, a, regularized, upper ) {
	var normalised;
	var invert;
	var initValue;
	var optimised_invert;
	var result;
	var sigma;
	var eval_method;
	var gam;
	var use_temme;
	var fa;
	var is_int;
	var is_half_int;
	var is_small_a;
	var res;
	var g;

	if ( x < 0.0 || a <= 0.0 ) {
		return NaN;
	}
	normalised = ( regularized !== undefined ) ? regularized : true;
	invert = upper ? true : false;
	result = 0.0;

	if ( a >= MAX_FACTORIAL && !normalised ) {
		//
		// When we're computing the non-normalized incomplete gamma
		// and a is large the result is rather hard to compute unless
		// we use logs.  There are really two options - if x is a long
		// way from a in value then we can reliably use methods 2 and 4
		// below in logarithmic form and go straight to the result.
		// Otherwise we let the regularized gamma take the strain
		// (the result is unlikely to unerflow in the central region anyway)
		// and combine with lgamma in the hopes that we get a finite result.
		//
		if ( invert && ( a * 4.0 < x ) ) {
			// This is method 4 below, done in logs:
			result = a * ln(x) - x;
			result += ln( upper_gamma_fraction( a, x ) );
		}
		else if ( !invert && ( a > 4.0 * x ) ) {
			// This is method 2 below, done in logs:
			result = a * ln(x) - x;
			initValue = 0;
			result += ln( lower_gamma_series( a, x, initValue ) / a );
		}
		else {
			result = gammainc( a, x, true, invert );
			if ( result === 0.0 ) {
				if ( invert ) {
					// Try http://functions.wolfram.com/06.06.06.0039.01
					result = 1 + 1 / (12 * a) + 1 / (288 * a * a);
					result = ln( result ) - a + (a - 0.5) * ln(a) + ln( SQRT_TWO_PI );
				} else {
					// This is method 2 below, done in logs, we're really outside the
					// range of this method, but since the result is almost certainly
					// infinite, we should probably be OK:
					result = a * ln( x ) - x;
					initValue = 0.0;
					result += ln( lower_gamma_series( a, x, initValue ) / a);
				}
			}
			else {
				result = ln( result ) + gammaln( a );
			}
		}
		if ( result > MAX_LN ) {
			return PINF;
		}
		return exp( result );
	}

	is_small_a = (a < 30) && (a <= x + 1.0 ) && (x < MAX_LN );
	if ( is_small_a ) {
		fa = floor( a );
		is_int = ( fa === a );
		is_half_int = is_int ? false : ( abs( fa - a ) === 0.5 );
	} else {
		is_int = is_half_int = false;
	}
	if ( is_int && x > 0.6 )
	// Calculate Q via finite sum:
	{
		invert = !invert;
		eval_method = 0;
	}
	else if ( is_half_int && x > 0.2 )
	// Calculate Q via finite sum for half integer a:
	{
		invert = !invert;
		eval_method = 1;
	}
	else if ( x < SQRT_EPSILON && a > 1.0 )
	{
		eval_method = 6;
	}
	else if ( x < 0.5 )
	{
		// Changeover criterion chosen to give a changeover at Q ~ 0.33:
		if ( -0.4 / ln( x ) < a ) {
			eval_method = 2;
		} else {
			eval_method = 3;
		}
	}
	else if ( x < 1.1 )
	{
		// Changover here occurs when P ~ 0.75 or Q ~ 0.25:
		if ( x * 0.75 < a ) {
			eval_method = 2;
		} else {
			eval_method = 3;
		}
	}
	else
	{
		/* Begin by testing whether we're in the "bad" zone
		where the result will be near 0.5 and the usual
		series and continued fractions are slow to converge: */
		use_temme = false;
		if ( normalised && a > 20 ) {
			sigma = abs( (x-a)/a );
			if ( a > 200 ) {
				// This limit is chosen so that we use Temme's expansion
				// only if the result would be larger than about 10^-6.
				// Below that the regular series and continued fractions
				// converge OK, and if we use Temme's method we get increasing
				// errors from the dominant erfc term as it's (inexact) argument
				// increases in magnitude.
				if ( 20 / a > sigma * sigma ) {
					use_temme = true;
				}
			} else {
				if ( sigma < 0.4 ) {
					use_temme = true;
				}
			}
		}
		if ( use_temme ) {
			eval_method = 5;
		}
		// Regular case where the result will not be too close to 0.5.
		else
		{
			// Changeover here occurs at P ~ Q ~ 0.5
			// Note that series computation of P is about x2 faster than continued fraction
			// calculation of Q, so try and use the CF only when really necessary, especially
			// for small x.
			if ( x - ( 1.0 / (3.0 * x) ) < a ) {
				eval_method = 2;
			} else {
				eval_method = 4;
				invert = !invert;
			}
		}
	}

	switch( eval_method ) {
	case 0:
		result = finite_gamma_q( a, x );
		if (normalised === false ) {
			result *= gamma( a );
		}
	break;
	case 1:
		result = finite_half_gamma_q( a, x );
		if ( normalised === false ) {
			result *= gamma( a );
		}
	break;
	case 2:
		// Compute P:
		result = normalised ? regularised_gamma_prefix( a, x ) : full_igamma_prefix( a, x );
		if ( result !== 0.0 ) {
			initValue = 0.0;
			optimised_invert = false;
			if ( invert ) {
				initValue = normalised ? 1.0 : gamma(a);
				if ( normalised || result >= 1.0 || FLOAT64_MAX * result > initValue ) {
					initValue /= result;
					if ( normalised || a < 1.0 || ( FLOAT64_MAX / a > initValue ) ) {
						initValue *= -a;
						optimised_invert = true;
					}
					else {
						initValue = 0.0;
					}
				}
				else {
					initValue = 0.0;
				}
			}
		}
		result *= lower_gamma_series( a, x, initValue ) / a;
		if ( optimised_invert ) {
			invert = false;
			result = -result;
		}
	break;
	case 3:
		// Compute Q:
		invert = !invert;
		res = tgamma_small_upper_part( a, x, invert );
		result = res[ 0 ];
		g = res[ 1 ];
		invert = false;
		if ( normalised ) {
			result /= g;
		}
	break;
	case 4:
		// Compute Q:
		result = normalised ? regularised_gamma_prefix( a, x ) : full_igamma_prefix( a, x );
		if ( result !== 0 ) {
			result *= upper_gamma_fraction( a, x );
		}
	break;
	case 5:
		result = igamma_temme_large( a, x );
		if ( x >= a ) {
			invert = !invert;
		}
	break;
	case 6:
		// x is so small that P is necessarily very small too,
		// use http://functions.wolfram.com/GammaBetaErf/GammaRegularized/06/01/05/01/01/
		result = !normalised ? pow( x, a ) / a : pow(x, a) / gamma( a + 1.0 );
		result *= 1.0 - a * x / ( a + 1.0 );
	break;
	}
	if ( normalised && result > 1.0 ) {
		result = 1.0;
	}
	if ( invert ) {
		gam = normalised ? 1.0 : gamma( a );
		result = gam - result;
	}
	return result;
} // end FUNCTION gammainc()


// EXPORTS //

module.exports = gammainc;
