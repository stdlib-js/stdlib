'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link https://github.com/boostorg/math/blob/develop/include/boost/math/special_functions/detail/bessel_j1.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright Xiaogang Zhang, 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
var sincos = require( '@stdlib/math/base/special/sincos' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var SQRT_PI = require( '@stdlib/constants/math/float64-sqrt-pi' );
var evalrational = require( '@stdlib/math/base/tools/evalrational' ).factory;


// VARIABLES //

var P1 = [
	-1.4258509801366645672e+11,
	6.6781041261492395835e+09,
	-1.1548696764841276794e+08,
	9.8062904098958257677e+05,
	-4.4615792982775076130e+03,
	1.0650724020080236441e+01,
	-1.0767857011487300348e-02
];

var Q1 = [
	4.1868604460820175290e+12,
	4.2091902282580133541e+10,
	2.0228375140097033958e+08,
	5.9117614494174794095e+05,
	1.0742272239517380498e+03,
	1.0,
	0.0
];

var P2 = [
	-1.7527881995806511112e+16,
	1.6608531731299018674e+15,
	-3.6658018905416665164e+13,
	3.5580665670910619166e+11,
	-1.8113931269860667829e+09,
	5.0793266148011179143e+06,
	-7.5023342220781607561e+03,
	4.6179191852758252278e+00
];

var Q2 = [
	1.7253905888447681194e+18,
	1.7128800897135812012e+16,
	8.4899346165481429307e+13,
	2.7622777286244082666e+11,
	6.4872502899596389593e+08,
	1.1267125065029138050e+06,
	1.3886978985861357615e+03,
	1.0
];

var PC = [
	-4.4357578167941278571e+06,
	-9.9422465050776411957e+06,
	-6.6033732483649391093e+06,
	-1.5235293511811373833e+06,
	-1.0982405543459346727e+05,
	-1.6116166443246101165e+03,
	0.0
];

var QC = [
	-4.4357578167941278568e+06,
	-9.9341243899345856590e+06,
	-6.5853394797230870728e+06,
	-1.5118095066341608816e+06,
	-1.0726385991103820119e+05,
	-1.4550094401904961825e+03,
	1.0
];

var PS = [
	3.3220913409857223519e+04,
	8.5145160675335701966e+04,
	6.6178836581270835179e+04,
	1.8494262873223866797e+04,
	1.7063754290207680021e+03,
	3.5265133846636032186e+01,
	0.0
];

var QS = [
	7.0871281941028743574e+05,
	1.8194580422439972989e+06,
	1.4194606696037208929e+06,
	4.0029443582266975117e+05,
	3.7890229745772202641e+04,
	8.6383677696049909675e+02,
	1.0
];

var x1 = 3.8317059702075123156e+00;
var x2 = 7.0155866698156187535e+00;
var x11 = 9.810e+02;
var x12 = -3.2527979248768438556e-04;
var x21 = 1.7960e+03;
var x22 = -3.8330184381246462950e-05;

var sc = [ 0.0, 0.0 ];


// FUNCTIONS //

var poly1 = evalrational( P1, Q1 );
var poly2 = evalrational( P2, Q2 );
var polyC = evalrational( PC, QC );
var polyS = evalrational( PS, QS );


// MAIN //

/**
* Computes the Bessel function of the first kind of order one.
*
* ## Notes
*
* -   Accuracy for subnormal `x` is very poor. Full accuracy is achieved at `1.0e-308` but trends progressively to zero at `5e-324`. This suggests that underflow (or overflow, perhaps due to a reciprocal) is effectively cutting off digits of precision until the computation loses all accuracy at `5e-324`.
*
* @param {number} x - input value
* @returns {number} evaluated Bessel function
*
* @example
* var v = j1( 0.0 );
* // returns 0.0
*
* v = j1( 1.0 );
* // returns ~0.440
*
* v = j1( Infinity );
* // returns 0.0
*
* v = j1( -Infinity );
* // returns 0.0
*
* v = j1( NaN );
* // returns NaN
*/
function j1( x ) {
	var value;
	var rc;
	var rs;
	var y2;
	var r;
	var y;
	var f;
	var w;

	w = abs( x );
	if ( x === 0.0 ) {
		return 0.0;
	}
	if ( w === PINF ) {
		return 0.0;
	}
	if ( w <= 4.0 ) {
		y = x * x;
		r = poly1( y );
		f = w * ( w + x1 ) * ( ( w - (x11/256.0) ) - x12 );
		value = f * r;
	} else if ( w <= 8.0 ) {
		y = x * x;
		r = poly2( y );
		f = w * ( w + x2 ) * ( ( w - (x21/256.0) ) - x22 );
		value = f * r;
	} else {
		y = 8.0 / w;
		y2 = y * y;
		rc = polyC( y2 );
		rs = polyS( y2 );
		f = 1.0 / ( sqrt( w ) * SQRT_PI );

		/*
		* What follows is really just:
		*
		* ```
		* z = w - 0.75 * pi;
		* value = f * ( rc * cos( z ) - y * rs * sin( z ) );
		* ```
		*
		* but using the sin/cos addition rules plus constants for the values of sin/cos of `3PI/4` which then cancel out with corresponding terms in "f".
		*/
		sincos( sc, w );
		value = f * ( ( rc * (sc[0]-sc[1]) ) + ( (y*rs) * (sc[0]+sc[1]) ) );
	}
	if ( x < 0.0 ) {
		value *= -1.0;
	}
	return value;
} // end FUNCTION j1()


// EXPORTS //

module.exports = j1;
