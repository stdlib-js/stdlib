/* eslint-disable no-underscore-dangle */
'use strict';

// MODULES //

var getKeys = require( 'object-keys' ).shim();
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );


// MAIN //

/**
* Returns a JavaScript wrapper for a C function.
*
* @private
* @param {Module} Module - Module
* @returns {Function} wrapper
*/
function cwrap( Module ) {
	var wrapper;
	var CACHE;
	var LIMIT;
	var COUNT;

	// Rather than an allocate a chunk of memory (e.g., via an array), assume a sparse data structure for the heap cache:
	CACHE = {};

	// Number of freed buffers before cleaning the heap cache:
	LIMIT = 10000;

	// Freed buffer counter:
	COUNT = 0;

	// Create the wrapper:
	wrapper = Module.cwrap( 'c_daxpy', null, [ 'number', 'number', 'number', 'number', 'number', 'number' ] );

	// Set methods:
	setReadOnly( daxpy, 'malloc', malloc );
	setReadOnly( daxpy, 'free', free );

	return daxpy;

	/**
	* Cleans a heap cache, preventing the cache from continuously accumulating keys which no longer hold references to buffer objects.
	*
	* @private
	*/
	function cleanCache() {
		var keys;
		var key;
		var tmp;
		var i;

		keys = getKeys( CACHE );

		// Note: we copy to a new object, rather than `delete` old keys, in order to ensure that the cache continues to have "fast" keys...
		tmp = {};
		for ( i = 0; i < keys.length; i++ ) {
			key = keys[ i ];
			if ( CACHE[ key ] !== null ) {
				tmp[ key ] = CACHE[ key ];
			}
		}
		CACHE = tmp;
		COUNT = 0;
	} // end FUNCTION cleanCache()

	/**
	* Allocates space on the heap.
	*
	* ## Notes
	*
	* * This function provides guarded access to the module buffer. Otherwise, if the underlying buffer were directly exposed, users may be encouraged to modify buffer values outside their allotted space. By only returning a view, we encourage users to only modify values corresponding to that view.
	* * The underlying buffer may still be obtained via `bytes.buffer`.
	*
	* @private
	* @param {PositiveInteger} nbytes - number of bytes to allocate
	* @returns {Uint8Array} bytes-view of the newly allocated buffer
	*
	* @example
	* var bytes = malloc( 10 );
	* // returns <Uint8Array>
	*/
	function malloc( nbytes ) {
		var byteOffset;
		var bytes;

		// Allocate space on the heap:
		byteOffset = Module._malloc( nbytes );

		// Generate a bytes-wise view of the allocated buffer:
		bytes = new Uint8Array( Module.HEAPU8.buffer, byteOffset, nbytes );

		// Add methods for setting and getting buffer values:
		setReadOnly( bytes, 'getValue', getValue );
		setReadOnly( bytes, 'setValue', setValue );

		// Cache a reference to the buffer:
		CACHE[ byteOffset ] = bytes;

		return bytes;

		/**
		* Returns a value at a specific memory address.
		*
		* ## Notes
		*
		* * The memory address is relative to the view, not the underlying buffer. The function handles mapping the view memory address to an underlying buffer memory address.
		*
		* @private
		* @param {NonNegativeInteger} ptr - memory address (number)
		* @param {string} [type="double"] - LLVM IR type ('i8', 'i16', 'i32', 'i64', 'float', 'double')
		* @returns {number} value
		*/
		function getValue( ptr, type ) {
			type = type || 'double';
			return Module.getValue( byteOffset+ptr, type );
		} // end FUNCTION getValue()

		/**
		* Sets a value at a specific memory address.
		*
		* ## Notes
		*
		* * The memory address is relative to the view, not the underlying buffer. The function handles mapping the view memory address to an underlying buffer memory address.
		*
		* @private
		* @param {NonNegativeInteger} ptr - memory address (number)
		* @param {number} value to set
		* @param {string} [type="double"] - LLVM IR type ('i8', 'i16', 'i32', 'i64', 'float', 'double')
		*/
		function setValue( ptr, value, type ) {
			type = type || 'double';
			Module.setValue( byteOffset+ptr, value, type );
		} // end FUNCTION setValue()
	} // end FUNCTION malloc()

	/**
	* Frees space on the heap.
	*
	* ## Notes
	*
	* * Calling this function repeatedly will incur a periodic performance hit in order to clear out old references to allocated buffers maintained in an internal cache. The performance hit can be avoided by judicious reuse of allocated buffers.
	*
	* @private
	* @throws {Error} must provide an active heap buffer
	* @param {Uint8Array} bytes - allocated buffer
	*
	* @example
	* // Allocate space:
	* var bytes = malloc( 10 );
	*
	* // Free allocated space:
	* free( bytes );
	*/
	function free( bytes ) {
		if ( CACHE[ bytes.byteOffset ] !== bytes ) {
			throw new Error( 'invalid input argument. Unrecognized heap buffer. Either the heap buffer was already freed or the input value was not allocated and returned by `malloc`.' );
		}
		Module._free( bytes.byteOffset );

		CACHE[ bytes.byteOffset ] = null;
		COUNT += 1;
		if ( COUNT === LIMIT ) {
			cleanCache();
		}
	} // end FUNCTION free()

	/**
	* Multiplies `x` by a constant and adds the result to `y`.
	*
	* @private
	* @param {PositiveInteger} N - number of elements
	* @param {number} alpha - scalar
	* @param {Float64Array} bytesX - allocated heap buffer
	* @param {integer} strideX - `x` stride length
	* @param {Float64Array} bytesY - allocated destination heap buffer
	* @param {integer} strideY - `y` stride length
	* @returns {Float64Array} `ybytes`
	*
	* @example
	* var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
	* var y = new Float64Array( [ 1.0, 1.0, 1.0, 1.0, 1.0 ] );
	* var alpha = 5.0;
	*
	* // Determine the number of bytes:
	* var nbytes = x.length * x.BYTES_PER_ELEMENT;
	*
	* // Allocate space on the heap:
	* var xbytes = daxpy.malloc( nbytes );
	* var ybytes = daxpy.malloc( nbytes );
	*
	* // Copy data to the heap:
	* xbytes.set( new Uint8Array( x.buffer ) );
	* ybytes.set( new Uint8Array( y.buffer ) );
	*
	* // Multiply and add:
	* daxpy( x.length, alpha, xbytes, 1, ybytes, 1 );
	*
	* // Extract the data from the heap:
	* y = new Float64Array( ybytes.buffer, ybytes.byteOffset, y.length );
	* // <Float64Array>[ 6.0, 11.0, 16.0, 21.0, 26.0 ]
	*
	* // Free the memory:
	* daxpy.free( xbytes );
	* daxpy.free( ybytes );
	*/
	function daxpy( N, alpha, bytesX, strideX, bytesY, strideY ) {
		if ( CACHE[ bytesX.byteOffset ] !== bytesX ) {
			throw new Error( 'invalid input argument. Unrecognized `x` heap buffer. Either the heap buffer was already freed or the heap buffer input value was not allocated and returned by `malloc`.' );
		}
		if ( CACHE[ bytesY.byteOffset ] !== bytesY ) {
			throw new Error( 'invalid input argument. Unrecognized `y` heap buffer. Either the heap buffer was already freed or the heap buffer input value was not allocated and returned by `malloc`.' );
		}
		// eslint-disable-next-line max-len
		wrapper( N, alpha, bytesX.byteOffset, strideX, bytesY.byteOffset, strideY );
		return bytesY;
	} // end FUNCTION daxpy()
} // end FUNCTION cwrap()


// EXPORTS //

module.exports = cwrap;
