/* eslint-disable no-underscore-dangle */
'use strict';

// MODULES //

var getKeys = require( 'object-keys' ).shim();
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );


// MAIN //

/**
* Returns a JavaScript wrapper for a C function.
*
* @private
* @param {Module} Module - Module
* @returns {Function} wrapper
*/
function cwrap( Module ) {
	var wrapper;
	var CACHE;
	var LIMIT;
	var COUNT;

	// Rather than an allocate a chunk of memory (e.g., via an array), assume a sparse data structure for the heap cache:
	CACHE = {};

	// Number of freed buffers before cleaning the heap cache:
	LIMIT = 10000;

	// Freed buffer counter:
	COUNT = 0;

	// Create the wrapper:
	wrapper = Module.cwrap( 'c_dasum', 'number', [ 'number', 'number', 'number' ] );

	// Set methods:
	setReadOnly( dasum, 'malloc', malloc );
	setReadOnly( dasum, 'free', free );

	return dasum;

	/**
	* Cleans a heap cache, preventing the cache from continuously accumulating keys which no longer hold references to buffer objects.
	*
	* @private
	*/
	function cleanCache() {
		var keys;
		var key;
		var tmp;
		var i;

		keys = getKeys( CACHE );

		// Note: we copy to a new object, rather than `delete` old keys, in order to ensure that the cache continues to have "fast" keys...
		tmp = {};
		for ( i = 0; i < keys.length; i++ ) {
			key = keys[ i ];
			if ( CACHE[ key ] !== null ) {
				tmp[ key ] = CACHE[ key ];
			}
		}
		CACHE = tmp;
		COUNT = 0;
	} // end FUNCTION cleanCache()

	/**
	* Allocates space on the heap.
	*
	* ## Notes
	*
	* * This function provides guarded access to the module buffer. Otherwise, if the underlying buffer were directly exposed, users may be encouraged to modify buffer values outside their allotted space. By only returning a view, we encourage users to only modify values corresponding to that view.
	* * The underlying buffer may still be obtained via `bytes.buffer`.
	*
	* @private
	* @param {PositiveInteger} nbytes - number of bytes to allocate
	* @returns {Uint8Array} bytes-view of the newly allocated buffer
	*
	* @example
	* var bytes = malloc( 10 );
	* // returns <Uint8Array>
	*/
	function malloc( nbytes ) {
		var byteOffset;
		var bytes;

		// Allocate space on the heap:
		byteOffset = Module._malloc( nbytes );

		// Generate a bytes-wise view of the allocated buffer:
		bytes = new Uint8Array( Module.HEAPU8.buffer, byteOffset, nbytes );

		// Add methods for setting and getting buffer values:
		setReadOnly( bytes, 'getValue', getValue );
		setReadOnly( bytes, 'setValue', setValue );

		// Cache a reference to the buffer:
		CACHE[ byteOffset ] = bytes;

		return bytes;

		/**
		* Returns a value at a specific memory address.
		*
		* ## Notes
		*
		* * The memory address is relative to the view, not the underlying buffer. The function handles mapping the view memory address to an underlying buffer memory address.
		*
		* @private
		* @param {NonNegativeInteger} ptr - memory address (number)
		* @param {string} [type="double"] - LLVM IR type ('i8', 'i16', 'i32', 'i64', 'float', 'double')
		* @returns {number} value
		*/
		function getValue( ptr, type ) {
			type = type || 'double';
			return Module.getValue( byteOffset+ptr, type );
		} // end FUNCTION getValue()

		/**
		* Sets a value at a specific memory address.
		*
		* ## Notes
		*
		* * The memory address is relative to the view, not the underlying buffer. The function handles mapping the view memory address to an underlying buffer memory address.
		*
		* @private
		* @param {NonNegativeInteger} ptr - memory address (number)
		* @param {number} value to set
		* @param {string} [type="double"] - LLVM IR type ('i8', 'i16', 'i32', 'i64', 'float', 'double')
		*/
		function setValue( ptr, value, type ) {
			type = type || 'double';
			Module.setValue( byteOffset+ptr, value, type );
		} // end FUNCTION setValue()
	} // end FUNCTION malloc()

	/**
	* Frees space on the heap.
	*
	* ## Notes
	*
	* * Calling this function repeatedly will incur a periodic performance hit in order to clear out old references to allocated buffers maintained in an internal cache. The performance hit can be avoided by judicious reuse of allocated buffers.
	*
	* @private
	* @throws {Error} must provide an active heap buffer
	* @param {Uint8Array} bytes - allocated buffer
	*
	* @example
	* // Allocate space:
	* var bytes = malloc( 10 );
	*
	* // Free allocated space:
	* free( bytes );
	*/
	function free( bytes ) {
		if ( CACHE[ bytes.byteOffset ] !== bytes ) {
			throw new Error( 'invalid input argument. Unrecognized heap buffer. Either the heap buffer was already freed or the input value was not allocated and returned by `malloc`.' );
		}
		Module._free( bytes.byteOffset );

		CACHE[ bytes.byteOffset ] = null;
		COUNT += 1;
		if ( COUNT === LIMIT ) {
			cleanCache();
		}
	} // end FUNCTION free()

	/**
	* Computes the sum of absolute values.
	*
	* @private
	* @param {PositiveInteger} N - number of values to sum
	* @param {Uint8Array} bytes - allocated heap buffer
	* @param {PositiveInteger} stride - `x` stride length
	* @throws {Error} must provide an active heap buffer
	* @returns {number} sum
	*
	* @example
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0 ] );
	*
	* // Determine the number of bytes:
	* var nbytes = x.length * x.BYTES_PER_ELEMENT;
	*
	* // Allocate space on the heap:
	* var bytes = dasum.malloc( nbytes );
	*
	* // Copy the data to the heap:
	* bytes.set( new Uint8Array( x.buffer ) );
	*
	* // Compute the sum:
	* var s = dasum( x.length, bytes, 1 );
	* // returns 15.0
	*
	* // Free the memory:
	* dasum.free( bytes );
	*/
	function dasum( N, bytes, stride ) {
		if ( CACHE[ bytes.byteOffset ] !== bytes ) {
			throw new Error( 'invalid input argument. Unrecognized heap buffer. Either the heap buffer was already freed or the heap buffer input value was not allocated and returned by `malloc`.' );
		}
		return wrapper( N, bytes.byteOffset, stride );
	} // end FUNCTION dasum()
} // end FUNCTION cwrap()


// EXPORTS //

module.exports = cwrap;
