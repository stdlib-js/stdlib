# dasum

> Compute the sum of [absolute values][@stdlib/math/base/special/abs] ([_L1_ norm][l1norm]).

<section class="intro">

The [_L1_ norm][l1norm] is defined as

<!-- <equation class="equation" label="eq:l1norm" align="center" raw="\|\mathbf{x}\|_1 = \sum_{i=0}^{n-1} \vert x_i \vert" alt="L1 norm definition."> -->

<div class="equation" align="center" data-raw-text="\|\mathbf{x}\|_1 = \sum_{i=0}^{n-1} \vert x_i \vert" data-equation="eq:l1norm">
    <img src="https://cdn.rawgit.com/stdlib-js/stdlib/15a1a60070db1b591d75f6b110e0e8387e550637/lib/node_modules/@stdlib/math/base/blas/dasum/docs/img/equation_l1norm.svg" alt="L1 norm definition.">
    <br>
</div>

<!-- </equation> -->

</section>

<!-- /.intro -->

<section class="usage">

## Usage

```javascript
var dasum = require( '@stdlib/math/base/blas/dasum' );
```

#### dasum( N, x, stride )

Computes the sum of [absolute values][@stdlib/math/base/special/abs].

```javascript
var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );

var sum = dasum( x.length, x, 1 );
// returns 19.0
```

The function accepts the following parameters:

-   **N**: number of elements to sum.
-   **x**: input [`Float64Array`][mdn-float64array].
-   **stride**: index increment.

The `N` and `stride` parameters determine which elements in `x` are used to compute the sum. For example, to sum every other value,

```javascript
var floor = require( '@stdlib/math/base/special/floor' );

var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );

var N = floor( x.length / 2 );
var stride = 2;

var sum = dasum( N, x, stride );
// returns 10.0
```

Note that indexing is relative to the first index. To introduce an offset, use [`typed array`][mdn-typed-array] views.

```javascript
var floor = require( '@stdlib/math/base/special/floor' );

// Initial array...
var x0 = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ] );

// Create an offset view...
var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 ); // start at 2nd element

var N = floor( x0.length / 2 );

// Sum every other value...
var sum = dasum( N, x1, 2 );
// returns 12.0
```

If either `N` or `stride` is less than or equal to `0`, the function returns `0`.

#### dasum.ndarray( N, x, stride, offset )

Computes the sum of [absolute values][@stdlib/math/base/special/abs], with alternative indexing semantics.

```javascript
var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );

var sum = dasum.ndarray( x.length, x, 1, 0 );
// returns 19.0
```

The function accepts the following additional parameters:

-   **offset**: starting index.

While [`typed array`][mdn-typed-array] views mandate a view offset based on the underlying `buffer`, the `offset` parameter supports indexing semantics based on a starting index. For example, to sum the last three elements,

```javascript
var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ] );

var sum = dasum.ndarray( 3, x, 1, x.length-3 );
// returns 15.0

// Using a negative stride to sum from the last element:
sum = dasum.ndarray( 3, x, -1, x.length-1 );
// returns 15.0
```

#### dasum.wasm( \[options] )

Returns a memory managed function to compute the sum of [absolute values][@stdlib/math/base/special/abs].

```javascript
var wasm = dasum.wasm();

// Number of data elements:
var N = 5;

// Allocate space on the heap:
var bytes = wasm.malloc( N * 8 ); // 8 bytes per double

// Create a Float64Array view:
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

// Copy data to the heap:
view.set( [ 1.0, -2.0, 3.0, -4.0, 5.0 ] );

// Compute the sum:
var s = wasm( N, bytes, 1 );
// returns 15.0

// Free the memory:
wasm.free( bytes );
```

For externally defined [typed arrays][mdn-typed-array], data must be copied to the heap.

```javascript
var wasm = dasum.wasm();

// Externally defined data array:
var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0 ] );

// Allocate space on the heap:
var bytes = wasm.malloc( x.length * x.BYTES_PER_ELEMENT );

// Copy data to the heap:
bytes.set( new Uint8Array( x.buffer ) );

// Compute the sum:
var s = wasm( x.length, bytes, 1 );
// returns 15.0

// Free the memory:
wasm.free( bytes );
```

The method accepts the following `options`:

-   **memory**: total memory. If not provided a `buffer`, setting the `memory` option instructs the returned function to allocate an internal memory store of the specified size.
-   **stack**: total stack size. Must be less than the `memory` option and large enough for a program's needs. Default: `1024` bytes.
-   **buffer**: `ArrayBuffer` serving as the underlying memory store. If not provided, each returned function will allocate and manage its own memory. If provided a `memory` option, the buffer `byteLength` must equal the specified total memory.

To create a function using an externally defined memory buffer, set the `buffer` option.

```javascript
var buffer = new ArrayBuffer( 16777216 ); // ~16MB

var wasm = dasum.wasm({
    'buffer': buffer
});
```

Providing external memory can be advantageous when wanting to a) centrally manage memory allocation, b) share memory between multiple memory managed functions, and/or c) limit the total amount of allocated memory within an application or library. 

##### wasm.malloc( nbytes )

Allocates space on the heap and returns a bytes-wise [`typed array`][mdn-typed-array] view ([`Uint8Array`][mdn-uint8array]).

```javascript
var wasm = dasum.wasm();

// Allocate 64 bytes:
var bytes = wasm.malloc( 64 );
```

##### bytes.getValue( ptr\[, type] )

Returns a value at a specific memory address (represented by a byte index). By default, the function returns a `double`. Possible types include: `'i8'`, `'i16'`, `'i32'`, `'i64'`, `'float'`, and `'double'`.

```javascript
var wasm = dasum.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var ptr = 1 * 8; // 8 bytes per double
var y = bytes.getValue( ptr );
// returns -2.0

wasm.free( bytes );
```

While this method may be convenient when interacting with the bytes view directly, using a [`typed array`][mdn-typed-array] view is likely to be more performant.

```javascript
var wasm = dasum.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var y = view[ 1 ];
// returns -2.0

wasm.free( bytes );
```

##### bytes.setValue( ptr, value\[, type] )

Sets a value at a specific memory address (represented by a byte index). By default, the function sets a `double`. Possible types include: `'i8'`, `'i16'`, `'i32'`, `'i64'`, `'float'`, and `'double'`.

```javascript
var wasm = dasum.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var ptr = 1 * 8; // 8 bytes per double
var y = bytes.getValue( ptr );
// returns -2.0

bytes.setValue( ptr, -10.0 );

y = bytes.getValue( ptr );
// returns -10.0

wasm.free( bytes );
```

While this method may be convenient when interacting with the bytes view directly, using a [`typed array`][mdn-typed-array] view is likely to be more performant.

```javascript
var wasm = dasum.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var y = view[ 1 ];
// returns -2.0

view[ 1 ] = -10.0;

y = view[ 1 ];
// returns -10.0

wasm.free( bytes );
```

##### wasm.free( heap )

Frees allocated space.

```javascript
var wasm = dasum.wasm();

var bytes = wasm.malloc( 64 );

// ...

// Free the space and allow reallocation:
wasm.free( bytes );
```

</section>

<!-- /.usage -->

<section class="notes">

## Notes

-   If `N <= 0`, the sum is `0`.
-   `dasum()` corresponds to the [BLAS][blas] level 1 function [`dasum`][dasum].

</section>

<!-- /.notes -->

<section class="examples">

## Examples

```javascript
var randu = require( '@stdlib/math/base/random/randu' );
var dasum = require( '@stdlib/math/base/blas/dasum' );

var rand;
var sign;
var x;
var i;

x = new Float64Array( 100 );
for ( i = 0; i < x.length; i++ ) {
    rand = round( randu()*100.0 );
    sign = randu();
    if ( sign < 0.5 ) {
        sign = -1.0;
    } else {
        sign = 1.0;
    }
    x[ i ] = sign * rand;
}
console.log( dasum( x.length, x, 1 ) );
```

</section>

<!-- /.examples -->

<section class="links">

[blas]: http://www.netlib.org/blas

[dasum]: http://www.netlib.org/lapack/explore-html/de/da4/group__double__blas__level1.html

[mdn-float64array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array

[mdn-typed-array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray

[mdn-uint8array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array

[l1norm]: http://en.wikipedia.org/wiki/Norm_%28mathematics%29

[@stdlib/math/base/special/abs]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/math/base/special/abs

</section>

<!-- /.links -->
