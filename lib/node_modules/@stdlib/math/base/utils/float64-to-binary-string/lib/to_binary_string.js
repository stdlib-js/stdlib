'use strict';

// MODULES //

var PINF = require( '@stdlib/math/constants/float64-pinf' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var abs = require( '@stdlib/math/base/special/abs' );
var floor = require( '@stdlib/math/base/special/floor' );
var rpad = require( '@stdlib/utils/right-pad-string' );
var lpad = require( '@stdlib/utils/left-pad-string' );
var repeat = require( '@stdlib/utils/repeat-string' );
var div2 = require( './div2.js' );
var mult2 = require( './mult2.js' );


// CONSTANTS //

// FIXME: constant
var BIAS = 1023; // exponent bias => (2**11)/2 - 1


// TO BINARY STRING //

/**
* Returns a string giving the literal bit representation of a double-precision floating-point number.
*
* @param {number} x - input value
* @returns {string} bit representation
*
* @example
* var str = binaryString( 4 );
* // returns '0100000000010000000000000000000000000000000000000000000000000000'
* @example
* var str = binaryString( Math.PI );
* // returns '0100000000001001001000011111101101010100010001000010110100011000'
* @example
* var str = binaryString( -1e308 );
* // returns '1111111111100001110011001111001110000101111010111100100010100000'
* @example
* var str = binaryString( -3.14e-320 );
* // returns '1000000000000000000000000000000000000000000000000001100011010011'
* @example
* var str = binaryString( 5e-324 );
* // returns '0000000000000000000000000000000000000000000000000000000000000001'
* @example
* var str = binaryString( 0 );
* // returns '0000000000000000000000000000000000000000000000000000000000000000'
* @example
* var str = binaryString( -0 );
* // returns '1000000000000000000000000000000000000000000000000000000000000000'
* @example
* var str = binaryString( NaN );
* // returns '0111111111111000000000000000000000000000000000000000000000000000'
* @example
* var str = binaryString( Number.POSITIVE_INFINITY );
* // returns '0111111111110000000000000000000000000000000000000000000000000000'
* @example
* var str = binaryString( Number.NEGATIVE_INFINITY );
* // returns '1111111111110000000000000000000000000000000000000000000000000000'
*/
function toBinaryString( x ) {
	var nbits;
	var sign;
	var str;
	var exp;
	var n;
	var f;
	var i;

	// Check for a negative value or negative zero...
	if ( x < 0 || 1/x === NINF ) {
		sign = '1';
	} else {
		sign = '0';
	}
	// Special case: +-infinity
	if ( x === PINF || x === NINF ) {
		// Based on IEEE754-1985...
		exp = repeat( '1', 11 ); // all 1s
		str = repeat( '0', 52 ); // all 0s
		return sign + exp + str;
	}
	// Special case: NaN
	if ( isnan( x ) ) {
		// Based on IEEE754-1985...
		exp = repeat( '1', 11 ); // all 1s
		str = '1' + repeat( '0', 51 ); // can't be all 0s
		return sign + exp + str;
	}
	// Special case: +-0
	if ( x === 0 ) {
		// Based on IEEE754-1985...
		exp = repeat( '0', 11 ); // all 0s
		str = repeat( '0', 52 ); // all 0s
		return sign + exp + str;
	}
	x = abs( x );

	// Isolate the integer part (digits before the decimal):
	n = floor( x );

	// Isolate the fractional part (digits after the decimal):
	f = x - n;

	// Convert the integer and fractional parts to bit strings:
	n = div2( n );
	f = mult2( f );

	// Determine the exponent needed to normalize the integer+fractional parts...
	if ( n ) {
		// Move the decimal `d` digits to the left:
		exp = n.length - 1;
	} else {
		// Find the first '1' bit...
		for ( i = 0; i < f.length; i++ ) {
			if ( f[ i ] === '1' ) {
				nbits = i + 1;
				break;
			}
		}
		// Move the decimal `d` digits to the right:
		exp = -nbits;
	}
	// Normalize the combined integer+fractional string...
	str = n + f;
	if ( exp < 0 ) {
		// Handle subnormals...
		if ( exp <= -BIAS ) {
			// Cap the number of bits removed:
			nbits = BIAS - 1;
		}
		// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:
		str = str.substring( nbits );
	} else {
		// Remove the leading '1' (implicit/hidden bit):
		str = str.substring( 1 );
	}
	// Convert the exponent to a bit string:
	exp = div2( exp + BIAS );
	exp = lpad( exp, 11, '0' );

	// Fill in any trailing zeros and ensure we have only 52 fraction bits:
	str = rpad( str, 52, '0' ).substring( 0, 52 );

	// Return a bit representation:
	return sign + exp + str;
} // end FUNCTION toBinaryString()


// EXPORTS //

module.exports = toBinaryString;
