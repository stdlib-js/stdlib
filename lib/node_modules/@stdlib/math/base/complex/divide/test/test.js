'use strict';

// MODULES //

var tape = require( 'tape' );
var isnan = require( '@stdlib/math/base/assert/is-nan' );
var isinfinite = require( '@stdlib/math/base/assert/is-infinite' );
var abs = require( '@stdlib/math/base/special/abs' );
var pow = require( '@stdlib/math/base/special/pow' );
var EPS = require( '@stdlib/math/constants/float64-eps' );
var numberBitsCorrect = require( './fixtures/number_bits_correct.js' );
var cdiv = require( './../lib' );


// FIXTURES //

var quotients = require( './fixtures/julia/quotients.json' );


// HELPERS


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof cdiv, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function accepts an optional output array', function test( t ) {
	var out = new Array( 2 );
	var result = cdiv( out, 2.0, 4.0, 1.0, 2.0 );
	t.deepEqual( out, [ 2.0, 0.0 ], 'values are correct' );
	t.equal( out, result, 'array reference is identical' );
	t.end();
});

tape( 'the function works without output array specified', function test( t ) {
	var result = cdiv( 2.0, 4.0, 1.0, 2.0 );
	t.deepEqual( result, [ 2.0, 0.0 ], 'values are correct' );
	t.end();
});

tape( 'the function solves hard problems', function test( t ) {
	var bits;
	var q;

	// Test case #1
	q = cdiv( 1.0, 1.0, 1.0, pow( 2.0, 1023.0 ) );

	bits = numberBitsCorrect( q[0], pow( 2.0, -1023.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], -pow( 2.0, -1023.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #2
	q = cdiv( 1.0, 1.0, pow( 2.0, -1023.0 ), pow( 2.0, -1023.0 ) );

	bits = numberBitsCorrect( q[0], pow( 2.0, 1023.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], 0.0 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #3
	q = cdiv( pow( 2.0, 1023.0 ), pow( 2.0, -1023.0 ),
		pow( 2.0, 677.0 ), pow( 2.0, -677.0 ) );

	bits = numberBitsCorrect( q[0], pow( 2.0, 346.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], -pow( 2.0, -1008.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #4
	q = cdiv( pow( 2.0, 1023.0 ), pow( 2.0, 1023.0 ), 1.0, 1.0 );

	bits = numberBitsCorrect( q[0], pow( 2.0, 1023.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], 0.0 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #5
	q = cdiv( pow( 2.0, 1020.0 ), pow( 2.0, -844.0 ),
		pow( 2.0, 656.0 ), pow( 2.0, -780.0 ) );

	bits = numberBitsCorrect( q[0], pow( 2.0, 364.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], -pow( 2.0, -1072.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #6
	q = cdiv( pow( 2.0, -71.0 ), pow( 2.0, 1021.0 ),
		pow( 2.0, 1001.0 ), pow( 2.0, -323.0 ) );

	bits = numberBitsCorrect( q[0], pow( 2.0, -1072.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], pow( 2.0, 20.0 ) );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #7
	q = cdiv( pow( 2.0, -347.0 ), pow( 2.0, -54.0 ),
		pow( 2.0, -1037.0 ), pow( 2.0, -1058.0 ) );

	bits = numberBitsCorrect( q[0], 3.898125604559113300e289 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], 8.174961907852353577e295 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #8
	q = cdiv( pow( 2.0, -1074.0 ), pow( 2.0, -1074.0 ),
		pow( 2.0, -1073.0 ), pow( 2.0, -1074.0 ) );

	bits = numberBitsCorrect( q[0], 0.6 );
	t.deepEqual( bits, [1, 11, 49], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], 0.2 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #9
	q = cdiv( pow( 2.0, 1015.0 ), pow( 2.0, -989.0 ),
		pow( 2.0, 1023.0 ), pow( 2.0, 1023.0 ) );

	bits = numberBitsCorrect( q[0], 0.001953125 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], -0.001953125 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	// Test case #10
	q = cdiv( pow( 2.0, -622.0 ), pow( 2.0, -1071.0 ),
		pow( 2.0, -343.0 ), pow( 2.0, -798.0 ) );

	bits = numberBitsCorrect( q[0], 1.02951151789360578e-84 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );
	bits = numberBitsCorrect( q[1], 6.97145987515076231e-220 );
	t.deepEqual( bits, [1, 11, 52], 'Sign, exponent, and mantissa bits are correct' );

	t.end();
});

tape( 'the function computes a quotient', function test( t ) {
	var delta;
	var tol;
	var re1;
	var im1;
	var re2;
	var im2;
	var i;
	var q;

	re1 = quotients.re1;
	im1 = quotients.im1;
	re2 = quotients.re2;
	im2 = quotients.im2;

	for ( i = 0; i < re1.length; i++ ) {
		q = cdiv( re1[i], im1[i], re2[i], im2[i] );

		if ( quotients.qreNaN[i] ) {
			t.ok( isnan( q[0] ), 'real part is NaN' );
		} else if ( quotients.qreFinite[i] ) {
			delta = abs( q[0] - quotients.qre[i] );
			tol = EPS * abs( quotients.qre[i] );
			t.ok( delta <= tol, 're( ( '+re1[i]+' + '+im1[i]+' i ) / ( '+re2[i]+' + '+im2[i]+' i ) ): expected '+q[0]+' to equal '+quotients.qre[i] );
		} else {
			t.ok( isinfinite( q[0] ), 'real part is infinite' );
		}

		if ( quotients.qimNaN[i] ) {
			t.ok( isnan(q[1]), 'imaginary part is NaN' );
		} else if ( quotients.qimFinite[i]) {
			delta = abs( q[1] - quotients.qim[i] );
			tol = EPS * abs( quotients.qim[i] );
			t.ok( delta <= tol, 'im( ( '+re1[i]+' + '+im1[i]+' i ) / ( '+re2[i]+' + '+im2[i]+' i ) ): expected '+q[1]+' to equal '+quotients.qim[i] );
		} else {
			t.ok( isinfinite(q[1]), 'imaginary part is infinite' );
		}

		if ( isnan( q[1] ) ) {
			t.ok( isnan( q[0] ), 'if the imaginary part of the result is NaN, then so is the real part' );
		}

		if ( isnan( q[0] ) ) {
			t.ok( isnan( q[1] ), 'if the real part of the result is NaN, then so is the imaginary part' );
		}
	}

	t.end();
});

tape('the function handles large and small numbers', function test( t ) {
	var expected;
	var v;

	v = cdiv( 1.0e308, 5.0e307, 1.0, 0.5 );
	expected = [ 1.0e308, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0, 0.5, 1.0e308, 5.0e307 );
	expected = [ 1.0e-308, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0e-304, 2.0e-304, 1.0, 2.0 );
	expected = [ 1.0e-304, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0, 2.0, 1.0e-304, 2.0e-304 );
	expected = [ 1.0e+304, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 2.0, 4.0, 0.0, 2.0 );
	expected = [ 2.0, -1.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0e-180, 1.0e-180, 1.0, 1.0e-180 );
	expected = [ 1.0e-180, 1.0e-180 ];

	t.end();
});

tape( 'if a real or imaginary component is `NaN`, all components are `NaN`', function test( t ) {
	var v;

	v = cdiv( NaN, 3.0, -2.0, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, NaN, -2.0, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, 3.0, NaN, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, 3.0, -2.0, NaN );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, 3.0, NaN, NaN );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( NaN, NaN, -2.0, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( NaN, NaN, NaN, NaN );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	t.end();
});
