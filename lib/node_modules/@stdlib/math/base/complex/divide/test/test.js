'use strict';

// MODULES //

var tape = require( 'tape' );
var isnan = require( '@stdlib/math/base/assert/is-nan' );
var abs = require( '@stdlib/math/base/special/abs' );
var EPS = require( '@stdlib/math/constants/float64-eps' );
var cdiv = require( './../lib' );


// FIXTURES //

var quotients = require( './fixtures/julia/quotients.json' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof cdiv, 'function', 'main export is a function' );
	t.end();
});

tape( 'accepts an optional output array', function test( t ) {
	var output = [];
	var result = cdiv( output, 2.0, 4.0, 1.0, 2.0 );
	t.deepEqual( output, [ 2.0, 0.0 ], 'values are correct' );
	t.equal( output, result, 'array reference is identical' );
	t.end();
});

tape( 'throws an error if optional output array is not valid', function test( t ) {
	t.throws( function evaluateWithExtraArgs() {
		cdiv( 2.0, 2.0, 4.0, 1.0, 2.0 );
	}, TypeError, 'throws an error');
	t.end();
});

tape( 'works without output array specified', function test( t ) {
	var result = cdiv( 2.0, 4.0, 1.0, 2.0 );
	t.deepEqual( result, [ 2.0, 0.0 ], 'values are correct' );
	t.end();
});

tape( 'the function computes a quotient', function test( t ) {
	var delta;
	var tol;
	var re1;
	var im1;
	var re2;
	var im2;
	var i;
	var q;

	re1 = quotients.re1;
	im1 = quotients.im1;
	re2 = quotients.re2;
	im2 = quotients.im2;

	for ( i = 0; i < re1.length; i++ ) {
		q = cdiv( re1[i], im1[i], re2[i], im2[i] );

		if ( quotients.qreNaN[i] ) {
			t.ok( isNaN( q[0] ), 'real part is NaN' );
		} else if ( quotients.qreFinite[i] ) {
			delta = abs( q[0] - quotients.qre[i] );
			tol = EPS * abs( quotients.qre[i] );
			t.ok( delta <= tol, 're( ( '+re1[i]+' + '+im1[i]+' i ) / ( '+re2[i]+' + '+im2[i]+' i ) ): expected '+q[0]+' to equal '+quotients.qre[i] );
		} else {
			t.ok( !isFinite( q[0] ), 'real part is infinite' );
		}

		if ( quotients.qimNaN[i] ) {
			t.ok(isNaN(q[1]), 'imaginary part is NaN' );
		} else if ( quotients.qimFinite[i]) {
			delta = abs( q[1] - quotients.qim[i] );
			tol = EPS * abs( quotients.qim[i] );
			t.ok( delta <= tol, 'im( ( '+re1[i]+' + '+im1[i]+' i ) / ( '+re2[i]+' + '+im2[i]+' i ) ): expected '+q[1]+' to equal '+quotients.qim[i] );
		} else {
			t.ok(!isFinite(q[1]), 'imaginary part is infinite' );
		}

		if ( isnan( q[1] ) ) {
			t.ok( isnan( q[0] ), 'if the imaginary part of the result is NaN, then so is the real part' );
		}

		if ( isnan( q[0] ) ) {
			t.ok( isnan( q[1] ), 'if the real part of the result is NaN, then so is the imaginary part' );
		}
	}

	t.end();
});

tape('the function performs performs well in corner cases', function test( t ) {
	var expected;
	var v;

	v = cdiv( 1.0e308, 5.0e307, 1.0, 0.5 );
	expected = [ 1.0e308, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0, 0.5, 1.0e308, 5.0e307 );
	expected = [ 1.0e-308, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0e-304, 2.0e-304, 1.0, 2.0 );
	expected = [ 1.0e-304, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0, 2.0, 1.0e-304, 2.0e-304 );
	expected = [ 1.0e+304, 0.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 2.0, 4.0, 0.0, 2.0 );
	expected = [ 2.0, -1.0 ];

	t.deepEqual( v, expected, 'returns expected values' );

	v = cdiv( 1.0e-180, 1.0e-180, 1.0, 1.0e-180 );
	expected = [ 1.0e-180, 1.0e-180 ];

	t.end();
});


tape( 'if a real or imaginary component is `NaN`, all components are `NaN`', function test( t ) {
	var v;

	v = cdiv( NaN, 3.0, -2.0, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, NaN, -2.0, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, 3.0, NaN, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, 3.0, -2.0, NaN );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( 5.0, 3.0, NaN, NaN );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( NaN, NaN, -2.0, 1.0 );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	v = cdiv( NaN, NaN, NaN, NaN );
	t.strictEqual( isnan( v[ 0 ] ), true, 'returns NaN' );
	t.strictEqual( isnan( v[ 1 ] ), true, 'returns NaN' );

	t.end();
});
