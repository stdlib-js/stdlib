'use strict';

// MODULES //

var isNonNegativeInteger = require( '@stdlib/math/base/utils/is-nonnegative-integer' );
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var trunc = require( '@stdlib/math/base/special/truncate' );
var pmf = require( '@stdlib/math/base/dist/hypergeometric/pmf' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var sum = require( './sum.js' );


// FUNCTIONS //

var max = Math.max;
var min = Math.min;


// CDF //

/**
* Evaluates the cumulative distribution function (CDF) for a hypergeometric distribution with number of white balls in urn `m` and number of black balls in urn `n` and number of draws `k` at a value `x`.
*
* @param {number} x - input value
* @param {NonNegativeInteger} m - number of white balls in urn
* @param {NonNegativeInteger} n - number of black balls in urn
* @param {NonNegativeInteger} k - number of draws
* @returns {Probability} evaluated CDF
*
* @example
* var y = cdf( 1.0, 4, 4, 2 );
* // returns ~0.786
* @example
* var y = cdf( 1.5, 4, 4, 2 );
* // returns ~0.786
* @example
* var y = cdf( 2.0, 4, 4, 2 );
* // returns 1.0
* @example
* var y = cdf( 0, 4, 4, 2)
* // returns ~0.214
* @example
* var y = cdf( NaN, 5, 5, 2 );
* // returns NaN
* @example
* var y = cdf( 0.0, NaN, 5, 2 );
* // returns NaN
* @example
* var y = cdf( 0.0, 5, NaN, 2 );
* // returns NaN
* @example
* var y = cdf( 0.0, 5, 5, NaN );
* // returns NaN
* @example
* var y = cdf( 2.0, 1.5, 5, 2 );
* // returns NaN
* @example
* var y = cdf( 2.0, 5, 1.5, 2 );
* // returns NaN
* @example
* var y = cdf( 2.0, 5, 5, -2.0 );
* // returns NaN
* @example
* var y = cdf( 2.0, 5, 5, 12 );
* // returns NaN
* @example
* var y = cdf( 2.0, 5, 3, 9 );
* // returns NaN
*/
function cdf( x, m, n, k ) {
	var denom;
	var probs;
	var num;
	var ret;
	var i;

	if (
		isnan( x ) ||
		isnan( m ) ||
		isnan( n ) ||
		isnan( k )
	) {
		return NaN;
	}
	if (
		!isNonNegativeInteger( m ) ||
		!isNonNegativeInteger( n ) ||
		!isNonNegativeInteger( k ) ||
		m === PINF ||
		n === PINF ||
		k > m + n
	) {
		return NaN;
	}
	x = trunc( x );
	if ( x < max( 0, k - n ) ) {
		return 0.0;
	}
	if ( x >= min( k, m ) ) {
		return 1.0;
	}

	probs = new Array( x + 1 );
	probs[ x ] = pmf( x, m, n, k );
	// Use recurrence relation:
	// (x+1)( n -(k-x-1))P(X=x+1)=(m-x)(k-x)P(X=x)
	for ( i = x - 1; i >= 0; i-- ) {
		num = ( i + 1 ) * ( n - (k-i-1) );
		denom = ( m - i ) * ( k - i );
		probs[ i ] =  ( num / denom ) * probs[ i + 1 ];
	}
	ret = sum( probs );
	return ret;
} // end FUNCTION cdf()


// EXPORTS //

module.exports = cdf;
