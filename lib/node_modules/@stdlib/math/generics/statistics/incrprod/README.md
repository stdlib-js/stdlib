# incrprod

> Compute a product incrementally.


<section class="usage">

## Usage

``` javascript
var incrprod = require( '@stdlib/math/generics/statistics/incrprod' );
```

#### incrprod()

Returns an accumulator `function` which incrementally computes a product.

``` javascript
var accumulator = incrprod();
```

#### accumulator( \[x\] )

If provided an input value `x`, the accumulator function returns an updated product. If not provided an input value `x`, the accumulator function returns the current product.

``` javascript
var product = accumulator( 2.0 );
// returns 2.0

product = accumulator( 1.0 );
// returns 2.0

product = accumulator( 3.0 );
// returns 6.0

product = accumulator();
// returns 6.0
```

</section>

<!-- /.usage -->


<section class="notes">

## Notes

* Input values are __not__ type checked. If provided `NaN` or a value which, when used in computations, results in `NaN`, the accumulated value is `NaN` for __all__ future invocations. If non-numeric inputs are possible, you are advised to type check and handle accordingly __before__ passing the value to the accumulator function.
* For long running accumulations or accumulations of large numbers, care should be taken to prevent overflow. Overflow need not be forever since internally the accumulator stores the product as a __mantissa__ and __exponent__.


</section>

<!-- /.notes -->


<section class="examples">

## Examples


``` javascript
var randu = require( '@stdlib/math/base/random/randu' );
var incrprod = require( '@stdlib/math/generics/statistics/incrprod' );

var accumulator;
var v;
var i;

// Initialize an accumulator:
accumulator = incrprod();

// For each simulated value, update the product...
for ( i = 0; i < 100; i++ ) {
    v = randu() * 100.0;
    accumulator( v );
}
console.log( accumulator() );
```

Under certain conditions, overflow may be "corrected". For example,

``` javascript
var ldexp = require('@stdlib/math/base/special/ldexp');
var incrprod = require('@stdlib/math/generics/statistics/incrprod');

// Write huge numbers x and y as a double starting from a normalized mantissa and big exponent

var x = ldexp( 0.5, 1000 );
// returns 5.357543035931337e+300

var y = ldexp( 0.1, 1000 );
// returns 1.0715086071862674e+300

// The number z on the other hand is practically zero
var z = ldexp( 0.2 , -1000 );
// returns 1.8665272370064379e-302

var accumulator = incrprod();

accumulator( x );
// returns 5.357543035931337e+300

accumulator( y );
// returns Infinity

accumulator( z );
// returns 1.0715086071862675e+299
```

The output of the accumulator can underflow but this is recoverable. This becomes clear when considering that the actual multiplication uses the (normalized) mantissa and exponent. The following example shows how this works

```javascript
var ldexp = require('@stdlib/math/base/special/ldexp');
var incrprod = require('@stdlib/math/generics/statistics/incrprod');

// Write numbers x and y, of tiny magnitude, as a double starting from a normalized mantissa and very negative exponent
var x = ldexp( 0.5, -1000 );
// returns 4.6663180925160944e-302

var y = ldexp( 0.1, -1000 );
// returns 9.332636185032189e-303

// The number z on the other hand is very large
var z = ldexp( 0.2 , 1000 );
// returns 2.1430172143725348e+300

var accumulator = incrprod();

console.log( accumulator( x ) );
// returns 4.6663180925160944e-302

console.log( accumulator( y ) );
// returns 0

console.log( accumulator( z ) );
// returns 9.33263618503219e-304
```

</section>

<!-- /.examples -->

<section class="links">

</section>

<!-- /.links -->
