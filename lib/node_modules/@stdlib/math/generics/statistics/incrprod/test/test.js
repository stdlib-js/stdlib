'use strict';

// MODULES //

var tape = require( 'tape' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var EPSILON = require( '@stdlib/math/constants/float64-eps' );
var normal = require( '@stdlib/math/base/random/normal' );
var ldexp = require( '@stdlib/math/base/special/ldexp' );
var isnan = require( '@stdlib/utils/is-nan' );
var abs = require( '@stdlib/math/base/special/abs' );
var incrprod = require( './../lib' );

// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof incrprod, 'function', 'main export is a function' );
	t.end();
} );

tape( 'the function returns an accumulator function', function test( t ) {
	t.equal( typeof incrprod(), 'function', 'returns a function' );
	t.end();
} );

tape( 'the accumulator function incrementally computes a product', function test( t ) {
	var expected;
	var actual;
	var data;
	var prod;
	var acc;
	var N;
	var d;
	var i;

	data = [ 2.0, 3.0, 2.0, 4.0, 3.0, 4.0 ];
	N = data.length;

	expected = new Array( N );
	actual = new Array( N );

	acc = incrprod();

	prod = 1.0;
	for ( i = 0; i < N; i++ ) {
		d = data[ i ];
		prod *= d;
		expected[ i ] = prod;
		actual[ i ] = acc( d );
	}

	t.deepEqual( actual, expected, 'returns expected incremental results' );
	t.end();
} );

tape( 'if not provided an input value, the accumulator function returns the current product', function test( t ) {
	var data;
	var acc;
	var i;

	data = [ 2.0, 3.0, 1.0 ];
	acc = incrprod();
	for ( i = 0; i < data.length; i++ ) {
		acc( data[ i ] );
	}
	t.equal( acc(), 6.0, 'returns the current accumulated product' );
	t.end();
} );

tape( 'calculate the product of a long series defined as a(s) = x if s is even and a(s) = 1/x if s is odd', function test( t ) {
	var length = 150;
	var x = 2;
	var acc;
	var i;

	acc = incrprod();
	for ( i = 0; i < length; i++ ) {
		if ( i%2 === 0 ) {
			acc( x );
		} else {
			acc( 1/x );
		}
	}

	t.equal( acc(), 1.0, 'returns the current accumulated product' );
	t.end();
} );

tape( 'check overflow that the result can overflow', function test( t ) {
	var acc = incrprod();
	var x = ldexp( 0.5, 1000 );
	var y = ldexp( 0.1, 1000 );

	acc( x );
	acc( y );

	t.equal( acc(), PINF, 'return accumulated product 0.6*10^2000' );
	t.end();
} );

tape( 'check overflow can vanish', function test( t ) {
	var expected = ldexp( 0.01, 1000 );
	var acc = incrprod();
	var x = ldexp( 0.5, 1000 );
	var y = ldexp( 0.1, 1000 );
	var z = ldexp( 0.2, -1000 );

	var deviation;
	var tolerance;

	acc( x );
	acc( y );
	acc( z );

	deviation = abs( expected - acc() );
	tolerance = EPSILON * abs( expected );
	t.equal( deviation <= tolerance, true, 'overflow is not persistent, final result within tolerance' );
	t.end();
} );

tape( 'check non-overflowing product against a naive implementation using random doubles', function test( t ) {
	var spread = 10.0;
	var mean = 50.0;
	var prod = 1.0;
	var acc = incrprod();
	var n = 500000;
	var rand;
	var rng;
	var i;


	rng = normal.factory( mean, spread, {
		'seed': Math.floor( Date.now() / 1000 )
	} );

	for ( i = 0; i < n; i++ ) {
		rand = rng();
		acc( rand );
		prod *= rand;
	}

	t.equal( acc(), prod, 'the incremental product is correct' );
	t.end();
} );

tape( 'check underflow can happen', function test( t ) {
	var acc = incrprod();
	var x = ldexp( 0.5, -1000 );
	var y = ldexp( 0.1, -1000 );

	acc( x );
	acc( y );

	t.equal( acc(), 0.0, 'underflow allowed' );
	t.end();
} );

tape( 'check underflow can vanish', function test( t ) {
	var acc = incrprod();
	var x = ldexp( 0.5, -1000 );
	var y = ldexp( 0.1, -1000 );
	var z = ldexp( 0.2, 1000 );

	acc( x );
	acc( y );

	t.equal( acc(), 0.0, 'underflow happens' );

	acc( z );

	t.equal( acc() !== 0.0, true, 'underflow resolved' );

	t.end();
} );

tape( 'NaN is not recoverable', function test( t ) {
	var acc = incrprod();
	var x = 5.0;
	var y = NaN;
	var z = 5.0;

	acc( x );

	t.equal( typeof acc() === 'number', true, 'accumulator works correctly' );

	acc( y );

	t.equal( isnan( acc() ), true, 'accumulator returns something different from a number' );

	acc( z );

	t.equal( isnan( acc() ), true, 'NaN values are not recoverable' );
	t.end();
} );
