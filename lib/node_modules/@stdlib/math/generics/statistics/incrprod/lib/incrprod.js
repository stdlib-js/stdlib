'use strict';

var frexp = require( '@stdlib/math/base/special/frexp' );
var ldexp = require( '@stdlib/math/base/special/ldexp' );

/**
* Returns an accumulator function which incrementally computes a product.
*
* @returns {Function} accumulator function
*
* @example
* var accumulator = incrprod();
*/
function incrprod() {
	var product = 1.0;
	var productFactorized = frexp( product );

	return accumulator;

	/**
	* If provided a value, the accumulator function returns an updated product. If not provided a value, the accumulator function returns the current product.
	*
	* @param {number} [x] - new value
	* @returns {number} product
	*
	* @example
	* var product = accumulator();
	* // returns 1.0
	*
	* product = accumulator( 2.0 );
	* // returns 2.0
	*
	* product = accumulator( -5.0 );
	* // returns -10.0
	*
	* product = accumulator();
	* // returns -10.0
	*/
	function accumulator( x ) {
		var newFactorized = frexp( x );

		if ( arguments.length === 0 ) {
			return product;
		}

		// Multiply mantissa
		productFactorized[ 0 ] *= newFactorized[ 0 ];

		// Add exponents
		productFactorized[ 1 ] += newFactorized[ 1 ];

		// Keep mantissa normalised to avoid underflow
		if ( productFactorized[ 0 ] < 0.5 && productFactorized[ 0 ] > -0.5) {
			newFactorized = frexp( productFactorized[ 0 ] );

			// The mantissa isn't obtained by multiplication!
			productFactorized[ 0 ] = newFactorized[ 0 ];

			// Add exponents
			productFactorized[ 1 ] += newFactorized[ 1 ];
		}

		// Convert to double precision float
		product = ldexp( productFactorized[ 0 ], productFactorized[ 1 ] );

		return product;
	}
} // End FUNCTION incrprod()

// EXPORTS //

module.exports = incrprod;
