'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isArrayLike = require( '@stdlib/utils/is-array-like' );
var isString = require( '@stdlib/utils/is-string' ).isPrimitive;
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var copy = require( '@stdlib/utils/copy' );
var discreteUniform = require( './discrete_uniform.js' );
var renormalizing = require( './renormalizing.js' );
var fisherYates = require( './fisher_yates.js' );
var vose = require( './vose.js' );
var defaults = require( './defaults.json' );
var validate = require( './validate.js' );


// FUNCTIONS //

var slice = Array.prototype.slice;


// FACTORY //

/**
* Returns a function to sample elements from an array-like object.
*
* @param {ArrayLike} [pool] - array-like object to sample from
* @param {Options} [options] - function options
* @param {PositiveInteger} [options.seed] - integer-valued seed
* @param {NonNegativeInteger} [options.size] - sample size
* @param {ProbabilityArray} [options.probs] - element probabilities
* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
* @returns {Function} function to sample elements from an array-like object
*
* @example
* var sample = factory({
*     'seed': 232
* });
* var out = sample( 'abcdefg' );
* // [ 'g', 'd', 'g', 'f', 'c', 'e', 'f' ]
*
* @example
* var sample = factory( [1,2,3,4,5,6], {
*     'seed': 232
*     'size': 2
* });
* var out = sample();
* // returns [ 6, 4 ]
*
* out = sample()
* // returns [ 6, 5 ]
*
* @example
* var sample = factory( [1,2,3,4,5,6], {
*     'seed': 474
*     'size': 3
*     'replace': false
* });
* var out = sample();
* // returns [ 4, 3, 6 ]
*
* out = sample()
* // returns [ 1, 5, 2 ]
*
* out = sample()
* // throws <Error>
*
* @example
* var sample = factory( [0,1], {
*     'size': 2
* });
*
* var out = sample();
* // e.g., returns [ 1, 1 ]
*
* out = sample({
*     size: 10
* });
* // e.g, returns [ 0, 1, 1, 1, 0, 1, 0, 0, 1, 1 ]
*
* @example
* var sample = factory( [0,1], {
*     'size': 2
* });
*
* var out = sample();
* // e.g., returns [ 1, 1 ]
*
* out = sample({
*     'replace': false
*     'size': 1
* });
* // returns [ 0 ] or [ 1 ]
*
* out = sample();
* // throws <RangeError>
*/
function factory() {
	var config;
	var pool;
	var conf;
	var rand;
	var err;
	var fun;

	conf = copy( defaults );
	if ( arguments.length === 1 ) {
		if ( isArrayLike( arguments[ 0 ] ) ) {
			pool = arguments[ 0 ];
			pool = isString( pool ) ? pool.split( '' ) : copy( pool );
		} else {
			config = arguments[ 0 ];
			err = validate( conf, config );
		}
	} else if ( arguments.length > 1 ) {
		if ( isArrayLike( arguments[ 0 ] ) ) {
			pool = arguments[ 0 ];
			config = arguments[ 1 ];
		} else {
			pool = arguments[ 1 ];
			config = arguments[ 0 ];
		}
		pool = isString( pool ) ? pool.split( '' ) : copy( pool );
		err = validate( conf, config );
	}

	if ( err ) {
		throw err;
	}
	rand = ( config && config.seed ) ?
		randu({ 'seed': config.seed }) :
		randu();

	if ( !pool ) {
		fun = sample1;
	} else {
		fun = sample2;
	}

	/**
	* Samples elements from an array-like object.
	*
	* @param {ArrayLike} x - array-like object from which to sample elements
	* @param {Options} [options] - function options
	* @param {NonNegativeInteger} [options.size] - sample size
	* @param {ProbabilityArray} [options.probs] - element probabilities
	* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
	* @throws {TypeError} first argument must be array-like
	* @throws {TypeError} options argument must be an object
	* @throws {TypeError} must provide valid options
	* @throws {TypeError} `size` option must be smaller or equal to the length of `x` when `replace` option is set to `false`
	* @returns {Array} sample
	*/
	function sample1( x, options ) {
		var replace;
		var xcopy;
		var opts;
		var probs;
		var size;
		var err;

		if ( !isArrayLike( x ) ) {
			throw new TypeError( 'invalid input argument. First argument must be array-like. Value: `' + x + '`.' );
		}
		if ( isString( x ) ) {
			x = x.split( '' );
		}
		opts = {};
		if ( arguments.length > 1 ) {
			err = validate( opts, options );
			if ( err ) {
				throw err;
			}
		}
		replace = opts.replace !== void 0 ? opts.replace : conf.replace;
		probs = opts.probs !== void 0 ? opts.probs : conf.probs;
		if ( opts.size ) {
			size = opts.size;
		} else if ( conf.size ) {
			size = conf.size;
		} else {
			size = x.length;
		}

		if (
			replace === false &&
			size > x.length
		) {
			throw new RangeError( 'invalid input option. `size` option must be less than or equal to the length of `x` when `replace` is `false`. Option: `' + size + '`.' );
		}
		// CASE 1: Custom probabilities supplied...
		if ( probs ) {
			if ( replace !== false ) {
				return vose( x, size, rand, probs );
			}
			return renormalizing( x, size, rand, probs );
		}
		// CASE 2: No probabilities supplied, all elements equally likely...
		if ( replace !== false ) {
			return discreteUniform( x, size, rand );
		}
		xcopy = slice.call( x );
		return fisherYates( xcopy, size, rand );
	} // end FUNCTION sample1()

	/**
	* Samples elements from the specified population.
	*
	* @param {Options} [options] - function options
	* @param {NonNegativeInteger} [options.size] - sample size
	* @param {boolean} [options.replace=true] - boolean indicating whether to sample with replacement
	* @throws {TypeError} options argument must be an object
	* @throws {TypeError} must provide valid options
	* @throws {TypeError} `size` option must be smaller or equal to the population when `replace` option is set to `false`
	* @returns {Array} sample
	*/
	function sample2( options ) {
		var replace;
		var opts;
		var size;
		var err;
		var ret;

		if ( pool.length === 0 ) {
			throw new Error( 'the population is empty.' );
		}
		opts = {};
		if ( arguments.length ) {
			err = validate( opts, options );
			if ( err ) {
				throw err;
			}
		}
		replace = opts.replace !== void 0 ? opts.replace : conf.replace;
		if ( opts.size ) {
			size = opts.size;
		} else if ( conf.size ) {
			size = conf.size;
		} else {
			size = pool.length;
		}

		if (
			replace === false &&
			size > pool.length
		) {
			throw new RangeError( 'invalid input option. `size` option must be less than or equal to the population size when `replace` is `false`. Option: `' + size + '`.' );
		}

		if ( replace !== false ) {
			return discreteUniform( pool, size, rand );
		}
		ret = fisherYates( pool, size, rand );
		// Slice off observations included in `ret`...
		pool = pool.slice( size, pool.length );
		return ret;
	} // end FUNCTION sample2()

	setReadOnly( fun, 'SEED', rand.SEED );
	setReadOnly( fun, 'PRNG', rand );
	return fun;
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
