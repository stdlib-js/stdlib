'use strict';

/*
* The weight vector implementation was inspired by the [sofia-ml]{@link https://code.google.com/archive/p/sofia-ml/} library.
*/

// MODULES //

var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' );
var isBoolean = require( '@stdlib/assert/is-boolean' );
var pow = require( '@stdlib/math/base/special/pow' );
var dot = require( './dot.js' );


// VARIABLES //

var MIN_SCALE = 1e-11;


// MAIN //

/**
* Creates a WeightVector.
*
* @constructor
* @param {PositiveInteger} dim - number of feature weights (excluding bias/intercept term)
* @param {boolean} intercept - boolean indicating whether a bias/intercept weight should be implicitly assumed
*/
function WeightVector( dim, intercept ) {
	var i;
	if ( !(this instanceof WeightVector) ) {
		return new WeightVector( dim, intercept );
	}
	if ( !isPositiveInteger( dim ) ) {
		throw new TypeError( 'invalid input argument. First argument `dim` must be a positive integer. Value: `' + dim + '`.' );
	}
	if ( !isBoolean( intercept ) ) {
		throw new TypeError( 'invalid input argument. Second argument `intercept` must be a boolean primitive. Value: `' + intercept + '`.' );
	}

	this.scale = 1.0;
	this.norm = 0.0;
	this.intercept = intercept;
	this.nWeights = dim + ( this.intercept ? 1 : 0 );

	this._data = new Array( this.nWeights );

	// Initialize weights to zero:
	for ( i = 0; i < this.nWeights; i++ ) {
		this._data[ i ] = 0.0;
	}
} // end FUNCTION WeightVector()

/**
* Scale elements of the weight vector by the supplied factor.
*
* @memberof WeightVector.prototype
* @function scaleTo
* @param {number} factor - scaling factor
* @throws {RangeError} `lambda` times `eta` must be large enough for the scaling weight to be nonnegative
*/
WeightVector.prototype.scaleTo = function scaleTo( factor ) {
	var i;
	if ( this.scale < MIN_SCALE ) {
		// Scale vector to one:
		for ( i = 0; i < this.nWeights; i++ ) {
			this._data[ i ] *= this.scale;
		}
		this.scale = 1.0;
	}

	this.norm *= pow( factor, 2 );

	if ( factor > 0.0 ) {
		this.scale *= factor;
	} else {
		throw new RangeError( 'Scaling weight vector by nonpositive value, likely due to too large value of eta * lambda. Value: `' + factor + '`' );
	}
}; // end METHOD scaleTo()


/**
* Adds vector `x` to the weight vector after scaling its elements.
*
* @memberof WeightVector.prototype
* @function add
* @param {NumericArray} x - vector to add
* @param {number} [xScale=1.0] - number to scale the elements of x with
*/
WeightVector.prototype.add = function add( x, xScale ) {
	var xscaled;
	var inner;
	var i;

	inner = 0;
	if ( xScale === void 0 ) {
		xScale = 1.0;
	}
	for ( i = 0; i < x.length; i++ ) {
		xscaled = x[ i ] * xScale;
		inner += this._data[i] * xscaled;
		this._data[ i ] = this._data[ i ] + ( xscaled / this.scale );
	}
	// If an intercept is assumed, treat `x` as containing one additional element equal to one...
	if ( this.intercept ) {
		xscaled = 1.0 * xScale;
		inner += this._data[ i ] * xscaled;
		this._data[ i ] = this._data[ i ] + xscaled / this.scale;
	}
	this.norm += ( dot( x, x ) + ( this.intercept ? 1.0 : 0.0  ) ) *
		pow( xScale, 2 ) +
		( 2.0 * this.scale * inner );
}; // end METHOD add()


/**
* Calculates the inner product of the weights and supplied vector `x`.
*
* @memberof WeightVector.prototype
* @function innerProduct
* @param {NumericArray} x - input vector
* @returns {number} inner product
*/
WeightVector.prototype.innerProduct = function innerProduct( x ) {
	var ret = 0;
	var i;
	for ( i = 0; i < x.length; i++ ) {
		ret += this._data[ i ] * x[ i ];
	}
	ret += this.intercept ? this._data[ i ] : 0.0;
	ret *= this.scale;
	return ret;
}; // end METHOD innerProduct()


// EXPORTS //

module.exports = WeightVector;
