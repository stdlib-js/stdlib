/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this, no-underscore-dangle, max-lines-per-function */

'use strict';

// MODULES //

var format = require( '@stdlib/string/format' );
var repeat = require( '@stdlib/string/repeat' );
var splitGraphemeClusters = require( '@stdlib/string/split-grapheme-clusters' );
var isString = require( '@stdlib/assert/is-string' );
var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' );
var filled = require( '@stdlib/array/base/filled' );
var floor = require( '@stdlib/math/base/special/floor' );
var ceil = require( '@stdlib/math/base/special/ceil' );
var min = require( '@stdlib/math/base/special/min' );
var slice = require( '@stdlib/array/slice' );
var truncate = require( '@stdlib/string/truncate' );


// MAIN //

/**
* Renders a table.
*
* @private
* @throws {Error} output must be able to accommodate every column individually
* @returns {string} rendered table
*/
function render() {
	var verticalLineIdx;
	var columnSeparator;
	var headerSeparator;
	var maxCellWidths;
	var paddingsRight;
	var rowSeparator;
	var paddingsLeft;
	var wrapIndices;
	var alignments;
	var borders;
	var widths;
	var start;
	var table;
	var wraps;
	var self;
	var row;
	var end;
	var out;
	var i;
	var j;

	self = this;
	out = '';

	// Resolve table properties:
	resolveProps();

	// Resolve indices to wrap the table at:
	wrapIndices = resolveWrapping();

	// Render top margin:
	out += repeat( '\n', this._marginY );

	// Render table:
	wraps = [];
	for ( j = 0; j < wrapIndices.length - 1; j++ ) {
		table = '';
		verticalLineIdx = 0;
		start = wrapIndices[ j ];
		end = wrapIndices[ j + 1 ];

		// Render top border:
		if ( borders[ 0 ].length !== 0 ) {
			widths = slice( this._columnWidths, start, end );
			table += renderLine( borders[ 0 ], widths, this._corners[ 0 ], this._joints[ 1 ], this._corners[ 1 ] ); // eslint-disable-line max-len
			table += '\n';
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				verticalLineIdx += 1;
			}
		}

		// Render headers:
		if ( this._headers ) {
			row = slice( this._headers, start, end );
			widths = slice( this._columnWidths, start, end );
			table += renderRow( row, widths );
			table += '\n';
			verticalLineIdx += 1;
		}

		// Render header separator:
		if ( this._headers && headerSeparator.length !== 0 ) {
			widths = slice( this._columnWidths, start, end );
			table += renderLine( headerSeparator, widths, this._joints[ 4 ], this._joints[ 0 ], this._joints[ 2 ] ); // eslint-disable-line max-len
			table += '\n';
			if ( this._verticalSeparatorMode === 'interpolate' ) {
				verticalLineIdx += 1;
			} else if ( this._verticalSeparatorMode === 'repeat' ) {
				verticalLineIdx = 0;
			}
		}

		// Render data:
		if ( this._data ) {
			for ( i = 0; i < this._data.length; i++ ) {
				// Render row:
				row = slice( this._data[ i ], start, end );
				widths = slice( this._columnWidths, start, end );
				table += renderRow( row, widths );
				if ( i !== this._data.length - 1 ) {
					table += '\n';
				}
				verticalLineIdx += 1;

				// Render row separator:
				if ( rowSeparator.length !== 0 && i !== this._data.length - 1 ) { // eslint-disable-line max-len
					widths = slice( this._columnWidths, start, end );
					table += renderLine( rowSeparator, widths, this._joints[ 4 ], this._joints[ 0 ], this._joints[ 2 ] ); // eslint-disable-line max-len
					table += '\n';
					if ( this._verticalSeparatorMode === 'interpolate' ) {
						verticalLineIdx += 1;
					} else if ( this._verticalSeparatorMode === 'repeat' ) {
						verticalLineIdx = 0;
					}
				}
			}
		}

		// Render bottom border:
		if ( borders[ 2 ].length !== 0 ) {
			table += '\n';
			widths = slice( this._columnWidths, start, end );
			table += renderLine( borders[ 2 ], widths, this._corners[ 3 ], this._joints[ 3 ], this._corners[ 2 ] ); // eslint-disable-line max-len
		}
		wraps.push( table );
	}
	out += wraps.join( '\n' );

	// Render bottom margin:
	out += repeat( '\n', this._marginY );

	this.emit( 'render', out );
	return out;

	/**
	* Resolves table properties for rendering.
	*
	* @private
	*/
	function resolveProps() {
		var i;
		if ( isString( self._alignment ) ) {
			alignments = filled( self._alignment, self._numColumns );
		} else {
			alignments = self._alignment;
		}
		if ( isNonNegativeInteger( self._cellPaddingLeft ) ) {
			paddingsLeft = filled( self._cellPaddingLeft, self._numColumns );
		} else {
			paddingsLeft = self._cellPaddingLeft;
		}
		if ( isNonNegativeInteger( self._cellPaddingRight ) ) {
			paddingsRight = filled( self._cellPaddingRight, self._numColumns );
		} else {
			paddingsRight = self._cellPaddingRight;
		}
		if ( isNonNegativeInteger( self._maxCellWidth ) ) {
			maxCellWidths = filled( self._maxCellWidth, self._numColumns );
		} else {
			maxCellWidths = self._maxCellWidth;
		}
		borders = [];
		for ( i = 0; i < self._borders.length; i++ ) {
			borders.push( splitGraphemeClusters( self._borders[ i ] ) );
		}
		columnSeparator = splitGraphemeClusters( self._columnSeparator );
		headerSeparator = splitGraphemeClusters( self._headerSeparator );
		rowSeparator = splitGraphemeClusters( self._rowSeparator );
	}

	/**
	* Resolves columns to wrap the table at (includes bounding indices).
	*
	* @private
	* @throws {Error} output must be able to accommodate every column individually
	* @returns {Array<number>} list of column indices
	*/
	function resolveWrapping() {
		var outputWidth;
		var fixedLength;
		var indices;

		// Initialize with zeroth index:
		indices = [ 0 ];

		// Calculate fixed horizontal length:
		fixedLength = 2 * self._marginX;
		if ( borders[ 1 ] !== 0 ) {
			fixedLength += 1;
		}
		if ( borders[ 3 ] !== 0 ) {
			fixedLength += 1;
		}
		if ( !self._columnWidths ) {
			return indices;
		}
		outputWidth = 0;
		for ( i = 0; i < self._columnWidths.length; i++ ) {
			outputWidth += min( self._columnWidths[ i ] + ( paddingsLeft[ i ] + paddingsRight[ i ] ), maxCellWidths[ i ] ); // eslint-disable-line max-len

			// If output crosses the maximum, time to wrap:
			if ( outputWidth + fixedLength > self._maxOutputWidth ) {
				if ( i === indices[ indices.length - 1 ] ) {
					// The output width cannot accommodate current column:
					throw new Error( format( 'invalid operation. `maxOutputWidth` must be able to accommodate every column individually. Value: `%s`', self._maxOutputWidth ) );
				}
				indices.push( i );
				outputWidth = 0;
				continue;
			}
			// Include column separator. Exclude for last column as we included them as borders:
			if ( i !== self._columnWidths.length - 1 && columnSeparator.length !== 0 ) { // eslint-disable-line max-len
				outputWidth += 1;
			}
		}
		// Include last bounding index:
		indices.push( self._columnWidths.length );
		return indices;
	}

	/**
	* Renders a line.
	*
	* @private
	* @param {string} lineChars - line character
	* @param {Array<number>} columnWidths - column widths
	* @param {string} jointL - left joint
	* @param {string} jointM - middle joint
	* @param {jointR} jointR - right joint
	* @returns {string} rendered line
	*/
	function renderLine( lineChars, columnWidths, jointL, jointM, jointR ) {
		var horizontalLineIdx;
		var colWidth;
		var out;
		var i;
		var j;

		out = '';
		horizontalLineIdx = 0;

		// Render left margin:
		out += repeat( ' ', self._marginX );

		// Render left joint:
		if ( borders[ 3 ].length !== 0 ) {
			out += jointL;
			if ( self._horizontalSeparatorMode === 'interpolate' ) {
				horizontalLineIdx += 1;
			}
		}
		// Render line:
		for ( i = 0; i < columnWidths.length; i++ ) {
			// If columns are separated, render the middle joint...
			if ( columnSeparator.length !== 0 && i !== 0 ) {
				out += jointM;
				if ( self._horizontalSeparatorMode === 'interpolate' ) {
					horizontalLineIdx += 1;
				} else if ( self._horizontalSeparatorMode === 'repeat' ) {
					horizontalLineIdx = 0;
				}
			}
			colWidth = min( columnWidths[ i ] + ( paddingsLeft[ i ] + paddingsRight[ i ] ), maxCellWidths[ i ] ); // eslint-disable-line max-len
			for ( j = 0; j < colWidth; j++ ) {
				out += lineChars[ horizontalLineIdx % lineChars.length ];
				horizontalLineIdx += 1;
			}
		}
		// Render right joint:
		if ( borders[ 1 ].length !== 0 ) {
			out += jointR;
		}
		// Render right margin:
		out += repeat( ' ', self._marginX );
		return out;
	}

	/**
	* Renders a data row.
	*
	* @private
	* @param {Array} data - row data
	* @param {Array<number>} columnWidths - column widths
	* @returns {string} rendered line
	*/
	function renderRow( data, columnWidths ) {
		var maxDatumWidth;
		var width;
		var datum;
		var out;
		var i;

		out = '';

		// Render left margin:
		out += repeat( ' ', self._marginX );

		// Render left border:
		if ( borders[ 3 ].length !== 0 ) {
			out += borders[ 3 ][ verticalLineIdx % borders[ 3 ].length ];
		}
		for ( i = 0; i < columnWidths.length; i++ ) {
			// Render column separator...
			if ( columnSeparator.length !== 0 && i !== 0 ) {
				out += columnSeparator[ verticalLineIdx % columnSeparator.length ]; // eslint-disable-line max-len
			}
			// Render left cell padding:
			out += repeat( ' ', paddingsLeft[ i ] );

			// If datum is longer than what is allowed by `maxCellWidth`, truncate it...
			datum = String( data[ i ] );
			maxDatumWidth = maxCellWidths[ i ] - ( paddingsLeft[ i ] + paddingsRight[ i ] ); // eslint-disable-line max-len
			width = columnWidths[ i ];
			if ( width > maxDatumWidth ) {
				datum = truncate( datum, maxDatumWidth );
				width = maxDatumWidth;
			}
			// Render datum:
			switch ( alignments[ i ] ) {
			case 'left':
				out += datum;
				out += repeat( ' ', width - datum.length );
				break;
			case 'center':
				out += repeat( ' ', ceil( ( width - datum.length ) / 2 ) );
				out += datum;
				out += repeat( ' ', floor( ( width - datum.length ) / 2 ) );
				break;
			case 'right':
				out += repeat( ' ', width - datum.length );
				out += datum;
				break;
			default:
				break;
			}
			// Render right cell padding:
			out += repeat( ' ', paddingsRight[ i ] );
		}
		// Render right border:
		if ( borders[ 1 ].length !== 0 ) {
			out += borders[ 1 ][ verticalLineIdx % borders[ 1 ].length ];
		}
		// Render right margin:
		out += repeat( ' ', self._marginX );
		return out;
	}
}


// EXPORTS //

module.exports = render;
