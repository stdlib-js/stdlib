/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isCollection = require( '@stdlib/assert/is-collection' );
var isInteger = require( '@stdlib/assert/is-integer' );
var max = require( '@stdlib/math/base/special/max' );
var min = require( '@stdlib/math/base/special/min' );


// MAIN //

/**
* Copies a part of a collection to another location in the same collection.
*
* @param {Collection} collection - input collection
* @param {integer} target - target index
* @param {integer} [start=0] - source start index
* @param {integer} [end=collection.length] - source end index
* @throws {TypeError} first argument must be a collection
* @throws {TypeError} second argument must be an integer
* @throws {TypeError} third argument must be an integer
* @throws {TypeError} fourth argument must be an integer
* @returns {Collection} modified input collection
*
* @example
* var arr = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];
*
* arr = copyWithin( arr, 0, 2, 4 );
* // returns [ 3.0, 4.0, 3.0, 4.0, 5.0 ]
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var arr = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]
*
* arr = copyWithin( arr, 0, 3, 4 );
* // returns <Float64Array>[ 4.0, 2.0, 3.0, 4.0, 5.0 ]
*/
function copyWithin( collection, target, start, end ) {
	var direction;
	var count;
	var final;
	var from;
	var len;
	var to;
	if ( !isCollection( collection ) ) {
		throw new TypeError( 'invalid argument. First argument must be a collection. Value: `'+collection+'`.' );
	}
	if ( !isInteger( target ) ) {
		throw new TypeError( 'invalid argument. Second argument must be an integer. Value: `'+target+'`.' );
	}

	len = collection.length;
	from = 0;
	final = len;
	if ( arguments.length > 2 ) {
		if ( !isInteger( start ) ) {
			throw new TypeError( 'invalid argument. Third argument must be an integer. Value: `'+start+'`.' );
		}
		from = start;

		if ( arguments.length === 4 ) {
			if ( !isInteger( end ) ) {
				throw new TypeError( 'invalid argument. Fourth argument must be an integer. Value: `'+end+'`.' );
			}
			final = end;
		}
	}

	to = target;
	if ( to < 0 ) {
		to = max( 0, to + len );
	} else {
		to = min( to, len );
	}
	if ( from < 0 ) {
		from = max( 0, from + len );
	} else {
		from = min( from, len );
	}
	if ( final < 0 ) {
		final = max( 0, final + len );
	} else {
		final = min( final, len );
	}

	count = min( final-from, len-to );
	direction = 1;
	if ( from < to && to < ( from+count ) ) {
		direction = -1;
		from += count - 1;
		to += count - 1;
	}

	while ( count > 0 ) {
		if ( from in collection ) {
			collection[ to ] = collection[ from ];
		} else {
			delete collection[ to ];
		}
		from += direction;
		to += direction;
		count -= 1;
	}

	return collection;
}


// EXPORTS //

module.exports = copyWithin;
