/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var setReadOnly = require('@stdlib/utils/define-read-only-property');
var isPositiveInteger = require('@stdlib/assert/is-positive-integer').isPrimitive;
var INT32_MAX = require('@stdlib/constants/math/int32-max');
var UINT32_MAX = require('@stdlib/constants/math/uint32-max');
var randint32 = require('./rand_int32.js');


// VARIABLES //

var NORMALIZATION_CONSTANT = (UINT32_MAX) | 0; // asm type annotation
var MAX_SEED = (INT32_MAX - 1) | 0; // asm type annotation
var N = 624;
var M = 397;
var UPPER_MASK = 0x80000000; /* Most significant w-r bits */
var LOWER_MASK = 0x7fffffff; /* Least significant r bits */
var MATRIX_A = 0x9908b0df;


// MAIN //

/**
* Returns a 32-bit Mersenne Twister pseudorandom number generator.
*
* @param {PositiveInteger} [seed] - pseudorandom number generator seed
* @throws {TypeError} must provide a positive integer
* @throws {RangeError} must provide a positive integer less than the maximum signed 32-bit integer
* @returns {Function} Mersenne Twister PRNG
*
* @example
* var mt19937 = factory();
*
* var v = mt19937();
* // returns <number>
*
* @example
* // Return a seeded Mersenne Twister PRNG:
* var mt19937 = factory( 1234 );
*
* var v = mt19937();
* // returns 822569775
*/
function factory( seed ) {
	var seedIsArray = false;
	var state;
	var mag01 = [ 0x0, MATRIX_A ];
	var mti;
	var mt = new Array( N );
	var s;
	var i;
	var j;
	var k;

	if ( arguments.length ) {
		if ( Array.isArray( seed ) ) {
			seedIsArray = true;
			i = 1;
			j = 0;
			k = ( N > seed.length ) ? N : seed.length;
			state = 19650218 | 0; // asm type annotation
		} else {
			if ( !isPositiveInteger( seed ) ) {
				throw new TypeError( 'invalid argument. Must provide a positive integer. Value: `' + seed + '`.' );
			}
			if ( seed > MAX_SEED ) {
				throw new RangeError( 'invalid argument. Must provide a positive integer less than the maximum signed 32-bit integer. Value: `' + seed + '`.' );
			}
			state = seed | 0; // asm type annotation
		}
	} else {
		state = randint32() | 0; // asm type annotation
	}

	mt[ 0 ] = state >>> 0;
	for ( mti = 1; mti < N; mti++ ) {
		s = mt[ mti - 1 ] ^ ( mt[ mti - 1 ] >>> 30 );
		mt[ mti ] =
			( ( ( ( (s & 0xffff0000) >>> 16 ) * 1812433253 ) << 16 ) +
			( (s & 0x0000ffff) * 1812433253) ) + mti;
		mt[ mti ] >>>= 0;
	}

	if ( seedIsArray ) {
		for (; k > 0; k--) {
			s = mt[ i - 1 ] ^ ( mt[ i - 1 ] >>> 30 );

			mt[i] = (mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) +
				( (s & 0x0000ffff) * 1664525 ) ) ) + seed[ j ] + j;
			mt[i] >>>= 0;
			i += 1;
			j += 1;
			if (i >= N) {
				mt[0] = mt[N - 1];
				i = 1;
			}
			if (j >= seed.length) {
				j = 0;
			}
		}

		for (k = N - 1; k; k--) {
			s = mt[i - 1] ^ (mt[i - 1] >>> 30);
			mt[i] = (mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) +
				( (s & 0x0000ffff ) * 1566083941 ) ) ) - i;
			mt[i] >>>= 0;
			i += 1;
			if (i >= N) {
				mt[0] = mt[N - 1];
				i = 1;
			}
		}
		mt[0] = 0x80000000;
	}

	setReadOnly( mt19937, 'NAME', 'mt19937' );
	setReadOnly( mt19937, 'SEED', state );
	setReadOnly( mt19937, 'MIN', 1 );
	setReadOnly( mt19937, 'MAX', UINT32_MAX );
	setReadOnly( mt19937, 'normalized', normalized );

	setReadOnly( normalized, 'NAME', mt19937.NAME );
	setReadOnly( normalized, 'SEED', mt19937.SEED );
	setReadOnly( normalized, 'MIN', ((( mt19937.MIN - 1.0 )) >>> 0) / ( NORMALIZATION_CONSTANT >>> 0 ) );
	setReadOnly( normalized, 'MAX', ((( mt19937.MAX - 1.0 )) >>> 0) / ( NORMALIZATION_CONSTANT >>> 0 ) );

	return mt19937;

	/**
	* Generates a pseudorandom integer on the interval \\( [1,2^{32}-1) \\).
	*
	* @private
	* @returns {PositiveInteger} pseudorandom integer
	*
	* @example
	* var v = mt19937();
	* // returns <number>
	*/
	function mt19937() {
		var kk;
		var y;

		if (mti >= N) {
			for ( kk = 0; kk < N - M; kk++ ) {
				y = ( mt[kk] & UPPER_MASK ) | ( mt[kk + 1] & LOWER_MASK );
				mt[kk] = mt[kk + M] ^ ( y >>> 1 ) ^ mag01[y & 0x1];
			}
			for ( ; kk < N - 1; kk++ ) {
				y = ( mt[kk] & UPPER_MASK ) | ( mt[kk + 1] & LOWER_MASK );
				mt[kk] = mt[kk + (M - N)] ^ (y >>> 1) ^ mag01[y & 0x1];
			}
			y = ( mt[N - 1] & UPPER_MASK ) | ( mt[0] & LOWER_MASK );
			mt[N - 1] = mt[M - 1] ^ ( y >>> 1 ) ^ mag01[y & 0x1];
			mti = 0;
		}

		y = mt[ mti ];
		mti += 1;

		/* Tempering */
		y ^= y >>> 11;
		y ^= ( y << 7 ) & 0x9d2c5680;
		y ^= ( y << 15 ) & 0xefc60000;
		y ^= y >>> 18;

		return y >>> 0;
	}

	/**
	* Generates a pseudorandom number on the interval \\( [0,1) \\).
	*
	* @private
	* @returns {number} pseudorandom number
	*
	* @example
	* var v = normalized();
	* // returns <number>
	*/
	function normalized() {
		return ((( mt19937() - 1.0 )) >>> 0) / (NORMALIZATION_CONSTANT >>> 0);
	}
}


// EXPORTS //

module.exports = factory;
