/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var toAccessorArray = require( '@stdlib/array/base/to-accessor-array' );
var iterCartesianProduct = require( './../lib' );


// TESTS //

tape('main export is a function', function test(t) {
	t.ok(true, __filename);
	t.strictEqual(typeof iterCartesianProduct, 'function', 'main export is a function');
	t.end();
});

tape('the function throws an error if provided a first argument which is not a collection', function test(t) {
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		true,
		false,
		null,
		void 0,
		{},
		function noop() {}
	];
	for (i = 0; i < values.length; i++) {
		t.throws(badValue(values[i]), TypeError, 'throws an error when provided ' + values[i]);
	}
	t.end();

	function badValue(value) {
		return function badValue() {
			iterCartesianProduct(value, [1, 2]);
		};
	}
});

tape('the function throws an error if provided a second argument which is not a collection', function test(t) {
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		true,
		false,
		null,
		void 0,
		{},
		function noop() {}
	];
	for (i = 0; i < values.length; i++) {
		t.throws(badValue(values[i]), TypeError, 'throws an error when provided ' + values[i]);
	}
	t.end();

	function badValue(value) {
		return function badValue() {
			iterCartesianProduct([1, 2], value);
		};
	}
});

tape('the function returns the Cartesian product iterator (indexed)', function test(t) {
	var iterator;
	var expected;
	var actual;
	var i;

	iterator = iterCartesianProduct([1, 2], [3, 4]);

	expected = [
		{
			'value': [1, 3],
			'done': false
		},
		{
			'value': [1, 4],
			'done': false
		},
		{
			'value': [2, 3],
			'done': false
		},
		{
			'value': [2, 4],
			'done': false
		},
		{
			'done': true
		}
	];

	actual = [];

	for (i = 0; i < expected.length; i++) {
		actual.push(iterator.next());
	}

	t.deepEqual(actual, expected, 'returns expected value');
	t.end();
});

tape('the function returns a empty iterator if either of the input iterators are empty (indexed)', function test(t) {
	var iterator;
	var expected;
	var actual;
	var i;

	iterator = iterCartesianProduct([], [3, 4]);
	expected = [{
		'done': true
	}];
	actual = [];
	for (i = 0; i < expected.length; i++) {
		actual.push(iterator.next());
	}
	t.deepEqual(actual, expected, 'returns expected value');

	iterator = iterCartesianProduct([1, 2], []);
	expected = [{
		'done': true
	}];
	actual = [];
	for (i = 0; i < expected.length; i++) {
		actual.push(iterator.next());
	}
	t.deepEqual(actual, expected, 'returns expected value');

	iterator = iterCartesianProduct([], []);
	expected = [{
		'done': true
	}];
	actual = [];
	for (i = 0; i < expected.length; i++) {
		actual.push(iterator.next());
	}
	t.deepEqual(actual, expected, 'returns expected value');
	t.end();
});

tape('the function returns the Cartesian product iterator (accessors)', function test(t) {
	var expected;
	var actual;
	var it;
	var i;

	it = iterCartesianProduct(toAccessorArray([1, 2]), toAccessorArray([3, 4]));

	expected = [
		{
			'value': [1, 3],
			'done': false
		},
		{
			'value': [1, 4],
			'done': false
		},
		{
			'value': [2, 3],
			'done': false
		},
		{
			'value': [2, 4],
			'done': false
		},
		{
			'done': true
		}
	];

	actual = [];

	for (i = 0; i < expected.length; i++) {
		actual.push(it.next());
	}

	t.deepEqual(actual, expected, 'returns expected value');
	t.end();
});

tape('the function returns a empty iterator if either of the input iterators are empty (accessors)', function test(t) {
	var expected;
	var actual;
	var it;
	var i;

	it = iterCartesianProduct(toAccessorArray([]), toAccessorArray([3, 4]));
	expected = [{
		'done': true
	}];
	actual = [];

	for (i = 0; i < expected.length; i++) {
		actual.push(it.next());
	}
	t.deepEqual(actual, expected, 'returns expected value');

	it = iterCartesianProduct(toAccessorArray([1, 2]), toAccessorArray([]));
	expected = [{
		'done': true
	}];
	actual = [];
	for (i = 0; i < expected.length; i++) {
		actual.push(it.next());
	}
	t.deepEqual(actual, expected, 'returns expected value');

	it = iterCartesianProduct(toAccessorArray([]), toAccessorArray([]));
	expected = [{
		'done': true
	}];
	actual = [];
	for (i = 0; i < expected.length; i++) {
		actual.push(it.next());
	}
	t.deepEqual(actual, expected, 'returns expected value');
	t.end();
});
