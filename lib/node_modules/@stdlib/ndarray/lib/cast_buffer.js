'use strict';

// MODULES //

var bufferCtors = require( '@stdlib/ndarray/base/buffer-ctors' );
var allocUnsafe = require( '@stdlib/buffer/alloc-unsafe' );


// MAIN //

/**
* Casts buffer elements by copying those elements to a buffer of another data type.
*
* @private
* @param {(Array|TypedArray|Buffer)} buffer - input buffer
* @param {NonNegativeInteger} len - number of elements to cast
* @param {string} dtype - data type
* @returns {(Array|TypedArray|Buffer)} output buffer
*
* @example
* var b = castBuffer( [ 1.0, 2.0, 3.0 ], 2, 'float64' );
* // returns <Float64Array>[ 1.0, 2.0 ]
*/
function castBuffer( buffer, len, dtype ) {
	/* eslint-disable no-new-cap */
	var ctor;
	var out;
	var i;

	// TODO: move to separate pkg? Yes, because this is not trivial. For performance, need to ensure element access minimizes cache misses. Although, in fairness, we don't need to iterate according to the view. We need to iterate from the perspective of the underlying buffer. Meaning, in this case, we don't need to consider strides. Note, however, if we copy based on the view, then the strides may no longer correspond to the copied buffer (e.g., the original strides indicated to skip elements; in other words, a non-single-segment buffer). The larger question is whether we should copy the view or the entire buffer?

	ctor = bufferCtors( dtype );
	if ( dtype === 'generic') {
		out = [];
		for ( i = 0; i < len; i++ ) {
			out.push( 0 ); // TODO: index into buffer
		}
	} else if ( dtype === 'binary' ) {
		out = allocUnsafe( len );
		for ( i = 0; i < len; i++ ) {
			out[ i ] = 0; // TODO: index into buffer
		}
	} else {
		out = new ctor( len );
		for ( i = 0; i < len; i++ ) {
			out[ i ] = 0; // TODO: index into buffer
		}
	}
	return out;
}


// EXPORTS //

module.exports = castBuffer;
