
/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var trim = require( '@stdlib/string/trim' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var format = require( '@stdlib/string/format' );
var replace = require( '@stdlib/string/replace' );
var startsWith = require( '@stdlib/string/starts-with' );
var endsWith = require( '@stdlib/string/ends-with' );
var removeFirst = require( '@stdlib/string/remove-first' );
var removeLast = require( '@stdlib/string/remove-last' );
var indexOf = require( '@stdlib/utils/index-of' );
var generateCodeArray = require( './generate_code_array.js' );
var extractSignature = require( './extract_signature.js' );
var extractTags = require( './extract_tags.js' );


// VARIABLES //

var RE_INTERFACE = /\r?\n(?=\S+)/;
var RE_NEWLINE = /\r?\n/g;


// FUNCTIONS //

/**
* Counts the number of lines in the given string.
*
* @private
* @param {string} str - input string
* @returns {number} number of lines
*/
function countLines( str ) {
	return ( str.match( RE_NEWLINE ) || '' ).length;
}

/**
* Extracts the short and extended description and returns description object.
*
* @private
* @param {string} descr - raw description
* @returns {Object} description object
*/
function extractDescription( descr ) {
	var extended;
	var short;
	var out;
	var tmp;
	var str;
	var i;

	out = {
		'raw': descr
	};
	tmp = descr.split( /\.\r?\n\r?\n/ );
	extended = '';
	if ( tmp.length === 1 ) {
		// Description does not include an extended description:
		short = tmp[ 0 ];
	} else if ( tmp.length > 1 ) {
		// Description includes an extended description:
		short = tmp[ 0 ] + '.';
		for ( i = 1; i < tmp.length; i++ ) {
			if ( i > 1 ) {
				extended += '.\n\n';
			}
			str = tmp[ i ];
			str = replace( str, '\n    ', ' ' );
			str = trim( str );
			extended += str;
		}
	}
	short = replace( short, '\n    ', ' ' );
	short = trim( short );
	extended = trim( extended );

	out.short = short;
	out.extended = extended;
	return out;
}


// MAIN //

/**
* Parses the contents of a `repl.txt` file and returns an abstract syntax tree (AST) representation.
*
* @param {string} repl - `repl.txt` contents
* @throws {TypeError} must provide a string primitive
* @returns {Object} parsed AST of the `repl.txt` contents
*/
function parse( repl ) {
	var RE_SECTION;
	var interfaces;
	var rawDescr;
	var section;
	var sigIdx;
	var descr;
	var title;
	var match;
	var start;
	var line;
	var ast;
	var sig;
	var str;
	var out;
	var i;

	if ( !isString( repl ) ) {
		throw new TypeError( format( 'invalid argument. First argument must be a string. Value: `%s`.', repl ) );
	}
	line = 1;
	if ( startsWith( repl, '\n' ) ) {
		repl = removeFirst( repl );
		line += 1;
	}
	interfaces = repl.split( RE_INTERFACE );
	out = new Array( interfaces.length );
	for ( i = 0; i < interfaces.length; i++ ) {
		str = interfaces[ i ];
		ast = {
			'raw': str,
			'idx': i,
			'last': i === interfaces.length - 1,
			'start': line
		};
		sigIdx = indexOf( str, '\n' );
		sig = extractSignature( str.substring( 0, sigIdx ) );
		sig.start = line;
		sig.end = line;
		ast.signature = sig;

		RE_SECTION = /(\n([A-Za-z ]+)\n {4}-+)([\s\S]*?)((?=\n {4}[A-Za-z ]+ *\n {4}-+)|\n$)/g;
		match = RE_SECTION.exec( str );
		if ( match ) {
			rawDescr = str.substring( sigIdx+1, match.index );
			descr = extractDescription( rawDescr );
			descr.start = line + 1;
			line += countLines( descr.raw );
			descr.end = line;
			ast.description = descr;
			ast.sections = [];
			while ( match !== null ) {
				title = trim( match[ 2 ] );
				start = line + 1;
				section = {
					'title': title,
					'rawTitle': match[ 1 ],
					'content': trim( match[ 3 ] ),
					'start': start
				};
				if ( title === 'Examples' ) {
					section.examples = generateCodeArray( match[ 3 ] );
				} else {
					section.tags = extractTags( match[ 3 ] );
				}
				line += countLines( match[ 3 ] ) + 2;
				section.end = line;
				ast.sections.push( section );
				match = RE_SECTION.exec( str );
			}
		} else {
			ast.sections = [];
		}
		ast.end = line;
		line += 1;
		while ( endsWith( ast.raw, '\n' ) ) {
			line += 1;
			ast.raw = removeLast( ast.raw );
		}
		out[ i ] = ast;
	}
	return out;
}


// EXPORTS //

module.exports = parse;
