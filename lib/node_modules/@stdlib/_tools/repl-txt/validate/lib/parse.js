
/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var trim = require( '@stdlib/string/trim' );
var startsWith = require( '@stdlib/string/starts-with' );
var removeFirst = require( '@stdlib/string/remove-first' );
var indexOf = require( '@stdlib/utils/index-of' );
var generateCodeArray = require( './generate_code_array.js' );
var extractSignature = require( './extract_signature.js' );
var extractTags = require( './extract_tags.js' );


// VARIABLES //

var RE_FUNCTION = /\n(?={{alias}}|[A-Za-z]+\.?[^(]*\([^)]*\)\n)/;
var RE_SECTION = /(\n([A-Za-z ]+)\n {4}-+)([\s\S]*?)((?=\n {4}[A-Za-z ]+ *\n {4}-+)|\n$)/g;
var RE_NEWLINE = /\r?\n/g;


// FUNCTIONS //

/**
* Counts the number of lines in the given string.
*
* @private
* @param {string} str - input string
* @returns {number} number of lines
*/
function countLines( str ) {
	return ( str.match( RE_NEWLINE ) || '' ).length;
}


// MAIN //

/**
* Parses the contents of a `repl.txt` file and returns a abstract syntax tree (AST) representation.
*
* @private
* @param {string} repl - `repl.txt` contents
* @returns {Object} parsed AST of the `repl.txt` contents
*/
function parse( repl ) {
	var section;
	var sigIdx;
	var descr;
	var title;
	var match;
	var start;
	var fcns;
	var line;
	var ast;
	var sig;
	var str;
	var out;
	var i;

	line = 1;
	if ( startsWith( repl, '\n' ) ) {
		repl = removeFirst( repl );
		line += 1;
	}
	fcns = repl.split( RE_FUNCTION );
	out = new Array( fcns.length );
	for ( i = 0; i < fcns.length; i++ ) {
		str = fcns[ i ];
		ast = {
			'raw': str,
			'idx': i,
			'last': i === fcns.length - 1,
			'start': line
		};
		sigIdx = indexOf( str, '\n' );
		sig = extractSignature( str.substring( 0, sigIdx ) );
		sig.start = line;
		sig.end = line;
		ast.signature = sig;

		match = RE_SECTION.exec( str );
		if ( match ) {
			descr = {
				'raw': str.substring( sigIdx+1, match.index ),
				'start': line+1
			};
			line += countLines( descr.raw );
			descr.end = line;
			ast.description = descr;
			ast.sections = [];
			while ( match !== null ) {
				title = trim( match[ 2 ] );
				start = line + 1;
				section = {
					'title': title,
					'rawTitle': match[ 1 ],
					'content': trim( match[ 3 ] ),
					'start': start
				};
				if ( title === 'Examples' ) {
					section.examples = generateCodeArray( match[ 3 ] );
				} else {
					section.tags = extractTags( match[ 3 ] );
				}
				line += countLines( match[ 3 ] ) + 2;
				section.end = line;
				ast.sections.push( section );
				match = RE_SECTION.exec( str );
			}
		} else {
			ast.sections = [];
		}
		ast.end = line;
		line += 3;
		out[ i ] = ast;
	}
	return out;
}


// EXPORTS //

module.exports = parse;
