/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var dirname = require( 'path' ).dirname;
var join = require( 'path' ).join;
var semver = require( 'semver' );
var recommendVersionBump = require( '@stdlib/_tools/changelog/recommend-version-bump' );
var name2standalone = require( '@stdlib/_tools/pkgs/name2standalone' );
var substringAfter = require( '@stdlib/string/substring-after' );
var objectEntries = require( '@stdlib/utils/entries' );
var parseCommits = require( '@stdlib/_tools/changelog/parse-commits' );
var objectKeys = require( '@stdlib/utils/keys' );
var namespaces = require( '@stdlib/_tools/pkgs/namespaces' ).sync;
var contains = require( '@stdlib/assert/contains' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var rootDir = require( '@stdlib/_tools/utils/root-dir' );
var replace = require( '@stdlib/string/replace' );
var groupBy = require( '@stdlib/utils/group-by' );
var filter = require( '@stdlib/array/base/filter' );
var format = require( '@stdlib/string/format' );
var repeat = require( '@stdlib/string/repeat' );
var isNull = require( '@stdlib/assert/is-null' );
var formatContributors = require( './format_contributors.js' );
var breakingChanges = require( './breaking_changes.js' );
var closedIssues = require( './closed_issues.js' );
var releaseSummary = require( './release_summary.js' );
var formatCommits = require( './format_commits.js' );
var npmReleases = require( './npm_releases.js' );
var sectionStart = require( './section_start.js' );
var sectionEnd = require( './section_end.js' );
var heading = require( './heading.js' );


// VARIABLES //

var STDLIB_LIB_DIR = join( rootDir(), 'lib', 'node_modules', '@stdlib' );
var STDLIB_NAMESPACE_PKGS = namespaces();
var STDLIB_REPO_NODE_PATH = 'https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules';
var RE_PACKAGE_SUBDIRS = /\/?(benchmark|bin|data|docs|etc|examples|include|lib|scripts|src|test)\/?[\s\S]*$/;
var RE_MARKDOWN_HEADER = /(^#+)/gm;
var RE_EXTRANEOUS_NEWLINES = /\n{3,}/g;


// FUNCTIONS //

/**
* Decrements all Markdown headers by a specified number of levels.
*
* @private
* @param {string} str - string to modify
* @param {number} n - number of levels to decrement
* @returns {string} modified string
*
* @example
* var str = '## Foo\n\n### Bar\n';
* var out = decrementHeaders( str, 1 );
* // returns '### Foo\n\n#### Bar\n'
*
* @example
* var str = '# Beep Boop\n\n## Baz Bar';
* var out = decrementHeaders( str, 2 );
* // returns '### Beep Boop\n\n#### Baz Bar'
*/
function decrementHeaders( str, n ) {
	return replace( str, RE_MARKDOWN_HEADER, '$1' + repeat( '#', n ) );
}

/**
* Formats a given date as a string in the format YYYY-MM-DD.
*
* @private
* @param {(string|integer)} [date] - date to format (default: current date)
* @returns {string} formatted date string in YYYY-MM-DD format
*/
function formatDate( date ) {
	return new Date( date || Date.now() ).toISOString().slice( 0, 10 );
}

/**
* Generates an opening release section tag.
*
* @private
* @param {string} [version] - release version
* @returns {string} release section tag
*/
function releaseSectionStart( version ) {
	if ( version ) {
		return '<section class="release" id="v' + version + '">\n\n';
	}
	return '<section class="release" id="unreleased">\n\n';
}

/**
* Groups commits by subpackages.
*
* @private
* @param {ObjectArray} commits - commits
* @param {string} pkg - package name
* @returns {Object} grouped commits
*/
function groupBySubPackage( commits, pkg ) {
	var commit;
	var group;
	var out;
	var i;
	var j;

	out = {};
	for ( i = 0; i < commits.length; i++ ) {
		commit = commits[ i ];
		for ( j = 0; j < commit.files.length; j++ ) {
			if ( commit.files[ j ].indexOf( 'lib/node_modules/@stdlib/' ) !== -1 ) {
				group = dirname( commit.files[ j ] );
				group = substringAfter( group, ( pkg ) ? pkg + '/' : '@stdlib/' );
				group = replace( group, RE_PACKAGE_SUBDIRS, '' );
				if ( contains( group, '/_tools/' ) ) {
					continue;
				}
				if ( !out[ group ] ) {
					out[ group ] = [];
				}
				if ( !contains( out[ group ], commit ) ) {
					out[ group ].push( commit );
				}
			}
		}
	}
	return out;
}

/**
* Tests whether a commit only affects internal tooling, i.e., files located in the `lib/node_modules/@stdlib/_tools/` directory.
*
* @private
* @param {Object} commit - commit object
* @returns {boolean} boolean indicating whether a commit is not only touching internal tooling
*/
function isNotInternalTooling( commit ) {
	var files;
	var i;

	files = commit.files;
	for ( i = 0; i < files.length; i++ ) {
		if ( files[ i ].indexOf( 'lib/node_modules/@stdlib/_tools/' ) === -1 ) {
			return true;
		}
	}
	return false;
}

/**
* Wraps a package summary for inclusion in a namespace changelog.
*
* @private
* @param {string} pkg - namespace package
* @param {string} version - namespace version
* @param {string} name - subpackage name
* @param {string} summary - package summary
* @returns {string} wrapped package summary
*/
function packageSummaryWrapper( pkg, version, name, summary ) {
	var href;
	var out;
	var id;

	name = pkg + ( ( name ) ? '/' + name : '' );
	href = STDLIB_REPO_NODE_PATH + '/%40stdlib/' + name;
	id = replace( name, '/', '-' );
	if ( version ) {
		id += '-v' + version;
	} else {
		id += '-unreleased';
	}
	out = '<section class="package" id="' + id + '">\n\n';
	out += heading( '[@stdlib/' + name + '](' + href + ')', 4 );
	out += '<details>\n\n';
	out += decrementHeaders( summary, 2 );
	out += '</details>';
	out += sectionEnd( 'package' );
	return out;
}


// MAIN //

/**
* Generates a Markdown formatted changelog for a specified stdlib package.
*
* @param {string} pkg - package name
* @param {string} [releaseType] - release type (`patch`, `minor`, `major`, `prerelease`, `prepatch`, `preminor`, `premajor`, or `auto`)
* @throws {TypeError} must provide a string
* @throws {Error} must provide a valid package name
* @throws {TypeError} must provide a recognized release type
* @returns {Object} changelog `content` and `releaseType` (`null` if no release)
*
* @example
* var changelog = generate( '@stdlib/utils/curry' );
* // returns {...}
*
* @example
* var changelog = generate( '@stdlib/stats/base/dists' );
* // returns {...}
*
* @example
* var changelog = generate( '@stdlib/proxy' );
* // returns {...}
*
* @example
* var changelog = generate( '@stdlib/utils/curry', 'patch' );
* // returns {...}
*
* @example
* var changelog = generate( '@stdlib/utils/curry', 'major' );
* // returns {...}
*/
function generate( pkg, releaseType ) {
	var isNamespacePkg;
	var releaseCommits;
	var newestRelease;
	var bySubpackage;
	var nextVersion;
	var standalone;
	var unreleased;
	var releases;
	var pkgNames;
	var commits;
	var version;
	var summary;
	var name;
	var str;
	var i;
	var j;

	if ( !isString( pkg ) ) {
		throw new TypeError( format( 'invalid argument. Must provide a string. Value: `%s`.', pkg ) );
	}
	if ( pkg === '@stdlib' || pkg === '@stdlib/stdlib' ) {
		// Case: root package
		isNamespacePkg = true;
		standalone = '@stdlib/stdlib';
		pkg = '';
		releases = objectEntries( npmReleases( standalone ) );
	} else {
		// Case: all other packages
		isNamespacePkg = contains( STDLIB_NAMESPACE_PKGS, pkg );
		standalone = name2standalone( pkg );
		pkg = replace( pkg, '@stdlib/', '' );
		releases = objectEntries( npmReleases( standalone ) );
	}

	str = '# CHANGELOG\n\n';
	str += '> Package changelog.\n\n';

	commits = parseCommits({
		'dir': join( STDLIB_LIB_DIR, pkg )
	});
	if ( commits.length === 0 ) {
		throw new Error( format( 'invalid argument. Unable to parse commits for package: `%s`.', pkg ) );
	}

	// Filter out all commits which only affect internal tooling:
	commits = filter( commits, isNotInternalTooling );

	// Group commits by release:
	commits = groupBy( commits, indicator );
	if ( !commits.unreleased ) {
		commits.unreleased = [];
	}

	if ( releaseType === 'auto' ) {
		releaseType = recommendVersionBump( commits.unreleased );
	}
	if ( releaseType && releaseType !== 'none' ) {
		if ( releases.length > 0 ) {
			newestRelease = releases[ releases.length-1 ][ 0 ];
			nextVersion = semver.inc( newestRelease, releaseType );
		} else {
			nextVersion = semver.inc( '0.0.0', releaseType );
		}
		if ( isNull( nextVersion ) ) {
			throw new TypeError( format( 'invalid argument. Unrecognized release type: `%s`.', releaseType ) );
		}
	}

	if ( isNamespacePkg ) {
		str += releaseSectionStart( nextVersion );
		str += '## ' + ( nextVersion || 'Unreleased' ) + ' (' + formatDate() + ')\n\n';
		bySubpackage = groupBySubPackage( commits.unreleased, pkg );
		pkgNames = objectKeys( bySubpackage ).sort();
		str += sectionStart( 'packages' );
		str += heading( 'Packages', 3 );
		for ( i = 0; i < pkgNames.length; i++ ) {
			name = pkgNames[ i ];
			unreleased = releaseSummary( bySubpackage[ name ], true, true );
			if ( unreleased ) {
				str += packageSummaryWrapper( pkg, '', name, unreleased );
			}
		}
		str += sectionEnd( 'packages' );
		str += breakingChanges( commits.unreleased );
		str += closedIssues( commits.unreleased );
		str += formatContributors( commits.unreleased );
		str += formatCommits( commits.unreleased );
		str += sectionEnd( 'release' );
	} else {
		unreleased = releaseSummary( commits.unreleased );
		if ( unreleased ) {
			str += releaseSectionStart( nextVersion );
			str += '## ' + ( nextVersion || 'Unreleased' ) + ' (' + formatDate() + ')\n\n';
			str += unreleased;
			str += sectionEnd( 'release' );
		}
	}
	if ( isNamespacePkg ) {
		for ( i = releases.length-1; i >= 0; i-- ) {
			version = releases[ i ][ 0 ];
			releaseCommits = commits[ version ];
			if ( !releaseCommits ) {
				continue;
			}
			str += '## ' + version + ' (' + formatDate( releases[ i ][ 1 ] ) + ')\n\n';
			bySubpackage = groupBySubPackage( releaseCommits, pkg );
			pkgNames = objectKeys( bySubpackage ).sort();
			str += sectionStart( 'packages' );
			str += heading( 'Packages', 3 );
			for ( j = 0; j < pkgNames.length; j++ ) {
				name = pkgNames[ j ];
				summary = releaseSummary( bySubpackage[ name ], true, true );
				if ( !summary ) {
					continue;
				}
				str += packageSummaryWrapper( pkg, version, name, summary );
			}
			str += sectionEnd( 'packages' );
			str += breakingChanges( releaseCommits );
			str += closedIssues( releaseCommits );
			str += formatContributors( releaseCommits );
			str += formatCommits( releaseCommits );
		}
	} else {
		for ( i = releases.length-1; i >= 0; i-- ) {
			version = releases[ i ][ 0 ];
			summary = releaseSummary( commits[ version ] );
			if ( !summary ) {
				continue;
			}
			str += releaseSectionStart( version );
			str += '## ' + version + ' (' + formatDate( releases[ i ][ 1 ] ) + ')\n\n';
			str += summary;
			str += sectionEnd( 'release' );
		}
	}
	return {
		'content': replace( str, RE_EXTRANEOUS_NEWLINES, '\n\n' ),
		'releaseType': releaseType || null
	};

	/**
	* Returns an indicator for a commit based on its release status.
	*
	* @private
	* @param {Object} commit - commit object
	* @returns {string} release indicator
	*/
	function indicator( commit ) {
		var date;
		var i;
		date = new Date( commit.date );

		// Walk the releases in reverse chronological order:
		for ( i = releases.length-1; i >= 0; i-- ) {
			if ( date <= new Date( releases[ i ][ 1 ] ) ) {
				return releases[ i ][ 0 ]; // version
			}
		}
		return 'unreleased';
	}
}


// EXPORTS //

module.exports = generate;
