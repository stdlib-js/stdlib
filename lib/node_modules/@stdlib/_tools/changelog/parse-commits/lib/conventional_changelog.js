/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var visitWithAncestors = require( 'unist-util-visit-parents' );
var visit = require( 'unist-util-visit' );
var contains = require( '@stdlib/assert/contains' );
var replace = require( '@stdlib/string/base/replace' );


// VARIABLES //

var RE_DIGITS = /^[0-9]+$/;
var RE_CLOSES = /(?:closes|fixes|resolves)/i;
var RE_CO_AUTHORED_BY = /co-authored-by/i;
var RE_LEADING_HASH = /^\s*#/;


// MAIN //

/**
* Converts a commit message AST to the conventional changelog format.
*
* @private
* @param {Object} ast - unist commit message AST
* @param {Options} options - function options
* @param {string} options.issueURL - issue URL
* @param {string} options.prURL - PR URL
* @returns {Object} conventional changelog format
*/
function toConventionalChangelog( ast, options ) {
	var breakingChanges = [];
	var out = {
		'type': '',
		'scope': null,
		'header': '',
		'subject': '',
		'body': '',
		'notes': [],
		'references': [],
		'mentions': [],
		'footer': null
	};

	visit( ast, 'body', onBody );
	visit( ast, 'summary', onSummary );
	visitWithAncestors( ast, [ 'breaking-change' ], processBreakingChanges );
	visit( ast, 'footer', processFooter );

	// Only keep the last breaking change note:
	if ( breakingChanges.length > 0 ) {
		out.notes.push( breakingChanges[ breakingChanges.length-1 ] );
	}
	return out;

	/**
	* Callback invoked upon visiting a breaking change node.
	*
	* @private
	* @param {Object} _ - AST node
	* @param {ObjectArray} ancestors - node ancestors
	*/
	function processBreakingChanges( _, ancestors ) {
		var startCollecting = false;
		var breaking = {
			'title': 'BREAKING CHANGE',
			'text': ''
		};
		var parent = ancestors.pop();
		switch ( parent.type ) {
		case 'summary':
			breaking.text = out.subject;
			break;
		case 'body':
			breaking.text = '';
			visit( parent, [ 'text', 'breaking-change' ], visitBodyNode );
			break;
		case 'token':
			parent = ancestors.pop();
			visit( parent, 'text', visitTextNode );
			break;
		default:
			break;
		}
		if ( breaking.text !== '' ) {
			breakingChanges.push( breaking );
		}

		/**
		* Callback invoked upon visiting a body node.
		*
		* @private
		* @param {Object} node - AST node
		*/
		function visitBodyNode( node ) {
			if ( startCollecting && node.type === 'text' ) {
				if ( breaking.text !== '' ) {
					breaking.text += '\n';
				}
				breaking.text += node.value;
			} else if ( node.type === 'breaking-change' ) {
				startCollecting = true;
			}
		}

		/**
		* Callback invoked upon visiting a text node.
		*
		* @private
		* @param {Object} node - AST node
		*/
		function visitTextNode( node ) {
			breaking.text = node.value;
		}
	}

	/**
	* Callback invoked upon visiting the body node.
	*
	* @private
	* @param {Object} body - AST node
	*/
	function onBody( body ) {
		if ( body ) {
			visit( body, 'text', extractBody );
		}
	}

	/**
	* Callback invoked upon visiting a text node.
	*
	* @private
	* @param {Object} node - AST node
	*/
	function extractBody( node ) {
		if ( out.body !== '' ) {
			out.body += '\n';
		}
		out.body += node.value;
	}

	/**
	* Callback invoked upon visiting the summary node.
	*
	* @private
	* @param {Object} summary - AST node
	*/
	function onSummary( summary ) {
		visit( summary, visitSummary );
	}

	/**
	* Processes a summary node and extracts relevant information.
	*
	* @private
	* @param {Object} node - AST node
	*/
	function visitSummary( node ) {
		switch ( node.type ) {
		case 'type':
			out.type = node.value;
			out.header += node.value;
			break;
		case 'scope':
			out.scope = node.value;
			out.header += '(' + node.value + ')';
			break;
		case 'breaking-change':
			out.header += '!';
			break;
		case 'text':
			out.subject = node.value;
			out.header += ': ' + node.value;
			break;
		default:
			break;
		}
	}

	/**
	* Processes a footer node and extracts relevant information.
	*
	* @private
	* @param {Object} node - AST node
	*/
	function processFooter( node ) {
		var hasRefSeparator = false;
		var coAuthoredBy = false;
		var closesIssue = false;
		var reference = {};
		var hasPRURL = false;

		visit( node, [ 'type', 'separator', 'text' ], processFooterNode );
		if ( hasRefSeparator && RE_DIGITS.test( reference.ref ) ) {
			reference.prefix = '#';
			out.references.push( reference );
		}
		if ( hasPRURL || closesIssue || coAuthoredBy ) {
			out.mentions.push( reference );
		}

		/**
		* Processes a footer node and extracts relevant information.
		*
		* @private
		* @param {Object} node - AST node
		*/
		function processFooterNode( node ) {
			switch ( node.type ) {
			case 'type':
				if ( node.value === 'PR-URL' ) {
					hasPRURL = true;
				} else if ( RE_CLOSES.test( node.value ) ) {
					closesIssue = true;
				} else if ( RE_CO_AUTHORED_BY.test( node.value ) ) {
					coAuthoredBy = true;
				}
				reference.action = node.value;
				break;
			case 'separator':
				if ( node.value.indexOf( '#' ) !== -1 ) {
					hasRefSeparator = true;
				}
				break;
			case 'text':
				if ( contains( node.value, options.issueURL ) ) {
					reference.url = node.value;
					reference.ref = node.value.split( '/' ).pop();
				}
				else if ( contains( node.value, options.prURL ) ) {
					hasPRURL = true;
					reference.url = node.value;
					reference.ref = node.value.split('/').pop();
				}
				if ( !reference.url ) {
					// Case: reference is not an issue or PR URL
					if ( RE_LEADING_HASH.test( node.value ) ) {
						hasRefSeparator = true;
						reference.ref = replace( node.value, RE_LEADING_HASH, '' );
					} else {
						reference.ref = node.value;
					}
					if ( closesIssue ) {
						reference.url = options.issueURL + reference.ref;
					} else if ( hasPRURL ) {
						reference.url = options.prURL + reference.ref;
					}
				}
				break;
			default:
				break;
			}
		}
	}
}


// EXPORTS //

module.exports = toConventionalChangelog;
