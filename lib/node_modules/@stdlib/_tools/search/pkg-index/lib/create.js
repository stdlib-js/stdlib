/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var join = require( 'path' ).join;
var logger = require( 'debug' );
var lunr = require( 'lunr' );
var lowercase = require( '@stdlib/string/lowercase' );
var replace = require( '@stdlib/string/replace' );
var dirname = require( '@stdlib/utils/dirname' );
var readJSON = require( '@stdlib/fs/read-json' ).sync;
var sectionText = require( './section_text.js' );


// VARIABLES //

var debug = logger( 'seach:pkg-index:create' );
var RE_TITLE = /#[ ]*([^\n]+)\r?\n/;
var RE_DESC = />[ ]*([^\n]+)\r?\n/;
var RE_LINKS = /\[([^\]]+)\]\[[^\]]+\]/g;
var RE_TRAILING_PERIOD = /\.$/;
var RE_BACKTICK = /`/;


// FUNCTIONS //

/**
* Returns the last index of a specified string.
*
* ## Notes
*
* -   The function assumes that `searchValue.length < str.length`.
*
* @private
* @param {string} str - string to search
* @param {string} searchValue - string to match
* @returns {integer} index
*/
function lastIndexOf( str, searchValue ) {
	var len;
	var N;
	var i;

	len = str.length;
	N = searchValue.length;
	for ( i = len-N; i >= 0; i-- ) {
		if ( str.substring( i, i+N ) === searchValue ) {
			return i;
		}
	}
	return -1;
}


// MAIN //

/**
* Returns a serialized lunr.js search index.
*
* @private
* @param {(EmptyArray|ObjectArray)} files - list of files and their associated contents
* @returns {Object} serialized search index
*/
function createIndex( files ) {
	var idx = lunr( initialize );
	return idx.toJSON();

	/**
	* Initializes a search index.
	*
	* @private
	*/
	function initialize() {
		/* eslint-disable no-invalid-this */
		var keywords;
		var title;
		var file;
		var blob;
		var desc;
		var dir;
		var pkg;
		var id;
		var i;
		var j;

		// If a document title matches the search query, decent probability that the document is relevant...
		this.field( 'title', {
			'boost': 10
		});

		// If a document description matches the search query, we are a little less confident that the document is relevant, as the description could mislead based on its content, but reasonable probability that the document is relevant regardless...
		this.field( 'desc', {
			'boost': 5
		});

		// Keywords are a means for package authors to provide hints as to package relevance, but these can be a bit noisy and imperfect...
		this.field( 'keywords', {
			'boost': 3
		});

		// A document's introduction could mention something relevant to the search query, but only in passing. Accordingly, the introduction is a signal, but not as important as the title and description...
		this.field( 'intro', {
			'boost': 1
		});

		this.ref( 'id' );

		// Add documents to search index:
		for ( i = 0; i < files.length; i++ ) {
			debug( 'Indexing file: %s', files[ i ].file );
			file = files[ i ].data;

			// Note: we assume that a README only has one H1 heading representing the title and the title always has the form: "Foo Bar" or "fooBar"
			title = lowercase( file.match( RE_TITLE )[ 1 ] );
			debug( 'Title: %s', title );

			// Note: we assume that a description always has the form: "Compute the [absolute value][absolute-value] of a mathematical `function` beep boop foo bar."
			desc = file.match( RE_DESC )[ 1 ];
			desc = replace( desc, RE_LINKS, '$1' );
			desc = lowercase( desc );
			desc = replace( desc, RE_BACKTICK, '' );
			desc = replace( desc, RE_TRAILING_PERIOD, '' );
			debug( 'Description: %s', desc );

			// Note: we assume that any resolved README file has an associated `package.json`. If not, probably not a package README...
			dir = dirname( files[ i ].file );
			pkg = readJSON( join( dir, 'package.json' ) );
			if ( pkg instanceof Error ) {
				debug( 'Encountered an error when attempting to read a `package.json` file in directory: %s. Skipping...', dir );
				continue;
			}
			keywords = JSON.stringify( pkg.keywords.join( ' ' ) );
			debug( 'Keywords: %s', keywords );

			// Note: we assume we can deduce a package name from the resolved file path: "/foo/bar/@stdlib/beep/boop" => "@stdlib/beep/boop"
			j = lastIndexOf( dir, '@' );
			id = dir.substring( j );
			debug( 'id: %s', id );

			blob = {
				'title': title,
				'desc': desc,
				'intro': sectionText( file, 'intro' ),
				'keywords': keywords,
				'id': id
			};
			debug( 'File data: %s', JSON.stringify( blob ) );
			this.add( blob );
		}
	}
}


// EXPORTS //

module.exports = createIndex;
