/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var basename = require( 'path' ).basename;
var dirname = require( 'path' ).dirname;
var join = require( 'path' ).join;
var relative = require( 'path' ).relative;
var statSync = require( 'fs' ).statSync; // eslint-disable-line node/no-sync
var endsWith = require( '@stdlib/string/ends-with' );
var replace = require( '@stdlib/string/replace' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var trim = require( '@stdlib/string/trim' );
var camelcase = require( '@stdlib/string/base/camelcase' );
var readDir = require( '@stdlib/fs/read-dir' ).sync;
var contains = require( '@stdlib/assert/contains' );
var rootDir = require( '@stdlib/_tools/utils/root-dir' );


// VARIABLES //

var rule;
var ORDER_COMMENT = 'When adding modules to the namespace, ensure that they are added in alphabetical order according to module name.';
var RE_CUSTOM_EXCLUDES = /The following modules are intentionally not exported: ?([^\n]+)\n/;
var RE_NS_VAR = /@namespace ([a-zA-Z0-9_]+)/;
var LIB_DIR = join( rootDir(), 'lib', 'node_modules' );
var EXCLUDE_LIST = [
	'node_modules',
	'benchmark',
	'data',
	'docs',
	'etc',
	'examples',
	'lib',
	'include',
	'scripts',
	'src',
	'test'
];
var OPTS_COMPARE = {
	'numeric': true
};


// FUNCTIONS //

/**
* Checks whether a directory content is a directory.
*
* @private
* @param {string} content - directory content path
* @returns {boolean} boolean indicating whether the directory content is a directory
*/
function isDirectory( content ) {
	var stat = statSync( content );
	return stat.isDirectory();
}

/**
* Rule for validating that a namespace `index.js` exports all packages in the respective namespace directory.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var requires;
	var packages;
	var filename;
	var excludes;
	var source;
	var match;
	var arr;
	var dir;
	var i;

	source = context.getSourceCode();
	if ( !contains( source.text, ORDER_COMMENT ) ) {
		return {};
	}
	match = RE_CUSTOM_EXCLUDES.exec( source.text );
	if ( match ) {
		excludes = EXCLUDE_LIST.slice();
		arr = match[ 1 ].split( ',' );
		for ( i = 0; i < arr.length; i++ ) {
			excludes.push( trim( arr[ i ] ) );
		}
	} else {
		excludes = EXCLUDE_LIST;
	}
	filename = context.getFilename();
	if ( !filename || !endsWith( filename, 'index.js' ) ) {
		return {};
	}
	dir = join( dirname( filename ), '..' );
	packages = packageDirectories( readDir( dir ) );
	requires = [];

	/**
	* Checks for existence of require paths in the current program and registers them.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var requirePath;
		var pkg;
		if ( node.callee.name === 'require' ) {
			requirePath = node.arguments[ 0 ].value;
			if ( isString( requirePath ) ) {
				pkg = basename( requirePath );
				if ( !contains( requires, pkg ) ) {
					requires.push( pkg );
				}
			}
		}
	}

	/**
	* Callback invoked upon program exit.
	*
	* @private
	* @param {Object} node - AST node
	*/
	function finish( node ) {
		var errs;
		var i;

		errs = [];
		for ( i = 0; i < packages.length; i++ ) {
			if ( !contains( requires, packages[ i ] ) ) {
				errs.push( packages[ i ] );
			}
		}
		if ( errs.length ) {
			report( errs, node );
		}
		requires.length = 0; // reset the require cache
	}

	/**
	* Reports a rule violation.
	*
	* @private
	* @param {string} pkg - package missing from the namespace `index.js`
	* @param {Object} node - AST node
	*/
	function reportPkg( pkg, node ) {
		var msg = '`' + pkg + '` should be exported from namespace `index.js`';
		context.report({
			'node': node,
			'message': msg,
			'suggest': [
				{
					'desc': 'Add `' + pkg + '` to the namespace `index.js`',
					'fix': fix
				}
			],
			'fix': fix
		});

		/**
		* Fixes the error message.
		*
		* @private
		* @param {Function} fixer - ESLint fixer
		* @returns {Object} fix
		*/
		function fix( fixer ) {
			var nsPath;
			var entry;
			var match;
			var pos;
			var ns;
			var re;
			var i;

			nsPath = replace( relative( LIB_DIR, dir ), '\\', '/' );
			match = RE_NS_VAR.exec( source.text );
			if ( !match ) {
				return null;
			}
			ns = match[ 1 ];
			entry = [
				'/**',
				'* @name <<alias>>',
				'* @memberof <<ns>>',
				'* @readonly',
				'* @type {Function}',
				'* @see {@link module:<<pkg>>}',
				'*/',
				'setReadOnly( <<ns>>, \'<<alias>>\', require( \'<<pkg>>\' ) );'
			].join( '\n' );
			entry = entry.replace( /<<pkg>>/g, nsPath + '/' + pkg );
			entry = entry.replace( /<<alias>>/g, camelcase( pkg ) );
			entry = entry.replace( /<<ns>>/g, ns );

			// Find position where to insert the entry (packages are listed in alphabetical order according to module name):
			pos = source.text.indexOf( 'var '+ns+' = {};' );
			for ( i = 0; i < packages.length; i++ ) {
				if ( pkg.localeCompare( packages[ i ], 'en', OPTS_COMPARE ) < 0 ) {
					break;
				}
				re = new RegExp( 'require\\( \'' + nsPath + '\\/' + packages[ i ] + '\' \\) \\);' );
				if ( re.test( source.text ) ) {
					pos = source.text.search( re );
				}
			}
			pos = source.text.indexOf( '\n', pos );
			return fixer.insertTextAfterRange( [ pos, pos ], '\n\n'+entry );
		}
	}

	/**
	* Reports error messages.
	*
	* @private
	* @param {StringArray} errs - array of packages not exported from `index.js`
	* @param {ASTNode} node - AST node
	*/
	function report( errs, node ) {
		var pkg;
		var i;
		for ( i = 0; i < errs.length; i++ ) {
			pkg = errs[ i ];
			reportPkg( pkg, node );
		}
	}

	/**
	* Filters out any non-package directories from a list of directory contents.
	*
	* @private
	* @param {Array} contents - directory contents
	* @returns {Array} namespace package directories
	*/
	function packageDirectories( contents ) {
		var content;
		var out;
		var i;

		out = [];
		for ( i = 0; i < contents.length; i++ ) {
			content = contents[ i ];
			if (
				isDirectory( join( dir, content ) ) &&
				!contains( excludes, content )
			) {
				out.push( content );
			}
		}
		return out;
	}

	return {
		'CallExpression': validate,
		'Program:exit': finish
	};
}


// MAIN //

rule = {
	'meta': {
		'type': 'suggestion',
		'docs': {
			'description': 'enforce that a namespace `index.js` exports all packages in the respective namespace directory'
		},
		'schema': [],
		'fixable': 'code',
		'hasSuggestions': true
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
