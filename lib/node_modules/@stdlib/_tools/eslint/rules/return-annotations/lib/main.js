/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var walk = require( 'acorn/dist/walk' );


// VARIABLES //

var RE_ANNOTATION = /^\s*(?:\* ){0,1}(?:\/\/|\/\*)* *(?:e\.g\.,){0,1} (returns|=>|throws)/;
var rule;


// FUNCTIONS //

/**
* Rule for validating that return annotations adhere to the project conventions.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var source = context.getSourceCode();

	/**
	* Reports the error message.
	*
	* @private
	* @param {Object} loc - error location info
	* @param {string} msg - error message
	*/
	function report( loc, msg ) {
		context.report({
			'node': null,
			'message': msg,
			'loc': loc
		});
	}

	/**
	* Checks whether return annotations in the current program follow the project conventions.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var comments;
		var current;
		var msg;
		var i;

		comments = source.getAllComments( node );
		for ( i = 0; i < comments.length; i++ ) {
			current = comments[ i ];
			msg = checkComment( current, node );
			if ( msg ) {
				report( current.loc, msg );
			}
		}
	}

	/**
	* Checks whether a comment is a return annotation and if so, whether it adheres to the project conventions.
	*
	* @private
	* @param {string} comment - comment to examine
	* @param {ASTNode} ast - node to examine
	* @returns {(string|null)} error message or null
	*/
	function checkComment( comment, ast ) {
		var matches;
		var node;
		var prev;
		var type;

		matches = comment.value.match( RE_ANNOTATION );
		if ( matches ) {
			prev = walk.findNodeAt( ast, null, comment.start-1 );
			type = matches[ 1 ];
			if ( !prev ) {
				return 'Encountered an orphaned return annotation without a preceding node';
			}
			node = prev.node;
			switch ( type ) {
			case 'returns':
				if (
					node.type !== 'VariableDeclaration' &&
					( node.type !== 'ExpressionStatement' || node.expression.type !== 'AssignmentExpression' )
				) {
					return 'Only include `// returns` after variable declarations or assignment expressions (use `=>` after `console.log`)';
				}
				break;
			case '=>':
				if (
					node.type === 'VariableDeclaration' ||
					( node.type === 'ExpressionStatement' && node.expression === 'AssignmentExpression' )
				) {
					return 'Use `// returns` after variable declarations or assignment expressions instead of `=>`';
				}
				break;
			default:
				break;
			}
		}
		return null;
	}

	return {
		'Program': validate
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce conventions for return annotations'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
