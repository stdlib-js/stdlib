/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var parseJS = require( 'acorn' ).parse;
var parseJSDoc = require( 'doctrine' ).parse;
var contains = require( '@stdlib/assert/contains' );
var isEmptyArray = require( '@stdlib/assert/is-empty-array' );
var isObject = require( '@stdlib/assert/is-object' );
var isNull = require( '@stdlib/assert/is-null' );
var replace = require( '@stdlib/string/replace' );
var findJSDoc = require( '@stdlib/_tools/eslint/utils/find-jsdoc' );
var INTEGER_TYPES = require( './integer_types.json' );
var FLOAT_TYPES = require( './float_types.json' );


// VARIABLES //

var RE_TRAILING_COMMENT = /; (\/\/|=>)[^\n]*\n/g;
var RE_ANNOTATION = /(?:returns|=>|throws) {0,1}([\s\S]*?)(?:\n\n|$)/;
var RE_NUMBER = /^[0-9e+-.]+$/;
var RE_DECIMAL = /([~+-]*[0-9]+)(?:.0)?(e[+-]?[0-9]+)?/;
var DOPTS = {
	'sloppy': true,
	'unwrap': true,
	'tags': [ 'example', 'returns' ]
};
var rule;


// FUNCTIONS //

/**
* Creates a replacement string for the given return annotation.
*
* @private
* @param {string} comment - return annotation
* @param {boolean} flg - boolean indicating whether annotation must include decimal point
* @returns {string} fixed return annotation
*/
function createReplacement( comment, flg ) {
	if ( flg ) {
		return replace( comment, RE_DECIMAL, '$1.0$2' );
	}
	return replace( comment, RE_DECIMAL, '$1$2' );
}

/**
* Checks the return value type for whether return annotations should include a decimal point.
*
* @private
* @param {string} type - type name
* @returns {(boolean|null)} for numbers, a boolean indicating whether return annotation value should include a decimal point, `null` otherwise
*/
function checkType( type ) {
	if ( contains( FLOAT_TYPES, type ) ) {
		return true;
	}
	if ( contains( INTEGER_TYPES, type ) ) {
		return false;
	}
	return null;
}

/**
* Checks whether a comment is a return annotation and, if so, whether it only includes decimal points for real-valued return values.
*
* @private
* @param {string} comment - comment to examine
* @param {string} rType - JSDoc return type
* @param {boolean} flg - boolean indicating whether annotation must include decimal point
* @returns {(string|null)} error message or null
*/
function checkComment( comment, rType, flg ) {
	var matches;
	var str;
	var val;

	str = comment.value;
	matches = str.match( RE_ANNOTATION );
	if ( matches ) {
		val = matches[ 1 ];
		if ( flg ) {
			if ( RE_NUMBER.test( val ) && !contains( val, '.' ) ) {
				return '`//'+str+'` should be `//'+createReplacement( str, flg )+'` (return annotations for values of type `'+rType+'` must always include a decimal point)';
			}
		}
		else if ( contains( val, '.0' ) ) {
			return '`//'+str+'` should be `//'+createReplacement( str, flg )+'` (return annotations for values of type `'+rType+'` must NOT include a decimal point)';
		}
	}
	return null;
}

/**
* Rule for validating that only return annotations for real-valued return values always contain decimal points.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var source = context.getSourceCode();
	var flg = false;

	/**
	* Reports the error message.
	*
	* @private
	* @param {ASTNode} node - node to examine
	* @param {string} msg - error message
	*/
	function report( node, msg ) {
		context.report({
			'node': node,
			'message': msg
		});
	}

	/**
	* Checks whether only return annotations for real-valued return values always contain decimal points.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var comments;
		var current;
		var jsdoc;
		var descr;
		var rType;
		var tags;
		var ast;
		var msg;
		var tag;
		var i;
		var j;

		jsdoc = findJSDoc( source, node );
		if ( isObject( jsdoc ) ) {
			ast = parseJSDoc( jsdoc.value, DOPTS );
			tags = ast.tags;
			if ( isEmptyArray( tags ) ) {
				return;
			}
			if ( tags[ 0 ].title === 'returns' && tags[ 0 ].type ) {
				rType = tags[ 0 ].type.name;
				flg = checkType( rType );
				if ( isNull( flg ) ) {
					return;
				}
			} else {
				// Return early for functions that do not have a return value...
				return;
			}
			for ( i = 1; i < tags.length; i++ ) {
				tag = tags[ i ];
				comments = [];
				descr = tag.description;

				// Handle special case where example code contains JSDoc comments with escaped ending:
				descr = replace( descr, '\\/', '/' );

				// Replace trailing comments to ensure that they are not mistakenly regarded as return annotations:
				descr = replace( descr, RE_TRAILING_COMMENT, ';\n' );
				try {
					parseJS( descr, {
						'onComment': comments,
						'locations': true,
						'ecmaVersion': 'latest'
					});
					if ( comments.length === 0 ) {
						// Move to next example as no comments are present:
						continue;
					}
					for ( j = 0; j < comments.length; j++ ) {
						current = comments[ j ];
						msg = checkComment( current, rType, flg );
						if ( msg ) {
							report( node, msg );
						}
					}
				} catch ( err ) {
					report( node, 'Error while parsing code: '+err.message );
				}
			}
		}
	}

	return {
		'FunctionExpression:exit': validate,
		'FunctionDeclaration:exit': validate,
		'VariableDeclaration:exit': validate,
		'ExpressionStatement:exit': validate
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce that (only) return annotations for floating-point typed values always contain decimal points'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
