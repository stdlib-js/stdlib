/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var startsWith = require( '@stdlib/string/starts-with' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isNodeBuiltin = require( '@stdlib/assert/is-node-builtin' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var indexOf = require( '@stdlib/utils/index-of' );
var isRegExpString = require( '@stdlib/assert/is-regexp-string' );
var reFromString = require( '@stdlib/utils/regexp-from-string' );
var DEFAULTS = require( './defaults.json' );


// VARIABLES //

var rule;


// FUNCTIONS //

/**
* Analyzes an array of require statement objects for "out-of-order" statements.
*
* @private
* @param {ObjectArray} requires - array of objects representing require statements
* @returns {(EmptyArray|ObjectArray)} array holding statements which violate a specified order
*/
function analyze( requires ) {
	var max;
	var out;
	var len;
	var i;

	len = requires.length;
	out = [];
	if ( len === 0 ) {
		return out;
	}
	max = requires[ 0 ];
	for ( i = 0; i < len; i++ ) {
		if ( requires[ i ].rank < max.rank ) {
			requires[ i ].compared = max;
			out.push( requires[ i ] );
		} else if ( requires[ i ].rank > max.rank ) {
			max = requires[ i ];
		}
	}
	return out;
}

/**
* Calculates the "rank" of a `require` path.
*
* @private
* @param {StringArray} order - require statement order
* @param {Array<RegExp>} regexps - regular expression array for detecting custom require statement types
* @param {string} name - require path
* @returns {integer} path rank
*/
function rank( order, regexps, name ) {
	var type;
	var i;

	type = 'external';
	if ( isNodeBuiltin( name ) ) {
		type = 'builtin';
	} else if (
		startsWith( name, './' ) ||
		startsWith( name, '/' ) ||
		startsWith( name, '../' )
	) {
		type = 'path';
	}
	for ( i = 0; i < regexps.length; i++ ) {
		if ( regexps[ i ].test( name ) ) {
			type = '/'+regexps[ i ].source+'/';
			break;
		}
	}
	return indexOf( order, type );
}

/**
* Rule for validating `require()` calls follow a specified order.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var requires;
	var options;
	var regexps;
	var order;
	var i;

	requires = [];
	regexps = [];
	options = context.options[ 0 ];
	order = DEFAULTS.order;
	if ( hasOwnProp( options, 'order' ) ) {
		order = options.order.slice();
	}
	for ( i = 0; i < order.length; i++ ) {
		if ( isRegExpString( order[ i ] ) ) {
			regexps.push( reFromString( order[ i ] ) );
		}
	}

	/**
	* Reports the error message.
	*
	* @private
	* @param {ObjectArray} errs - array of require statements that are not in order
	*/
	function report( errs ) {
		var curr;
		var msg;
		var i;
		for ( i = 0; i < errs.length; i++ ) {
			curr = errs[ i ];
			msg = '`require( \''+curr.name+'\' )` should come before `require( \''+curr.compared.name+'\' )`';
			context.report({
				'node': null,
				'message': msg,
				'loc': curr.node.loc
			});
		}
	}

	/**
	* Checks for existence of require paths in the current program and registers them.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var requirePath;
		var r;
		if ( node.callee.name === 'require' ) {
			requirePath = node.arguments[ 0 ].value;
			if ( isString( requirePath ) ) {
				r = rank( order, regexps, requirePath );
				if ( r !== -1 ) {
					// Register a require statement "node":
					requires.push({
						'name': requirePath,
						'node': node,
						'rank': r,
						'compared': null
					});
				}
			}
		}
	}

	/**
	* Callback invoked upon program exit.
	*
	* @private
	*/
	function finish() {
		var errs = analyze( requires );
		if ( errs.length ) {
			report( errs );
			requires.length = 0; // reset the require cache
		}
	}

	return {
		'CallExpression': validate,
		'Program:exit': finish
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce that `require()` calls follow a specified order'
		},
		'schema': [
			{
				'type': 'object',
				'properties': {
					'order': {
						'type': 'array'
					}
				},
				'additionalProperties': false
			}
		]
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
