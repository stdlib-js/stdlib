/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var endsWith = require( '@stdlib/string/ends-with' );
var trim = require( '@stdlib/string/trim' );


// VARIABLES //

var REGEXP_HEADER = /^( )*[A-Z][A-Z0-9 ]+( )*(\/\/)?$/;
var rule;


// FUNCTIONS //

/**
* Checks whether a line is a section header comment.
*
* @private
* @param {string} line - line of code
* @returns {boolean} boolean indicating if a line is a section header
*/
function isSectionHeader( line ) {
	return REGEXP_HEADER.test( line ) || endsWith( line, '//' );
}

/**
* Rule for validating that code does not contain multiple blank lines.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var source = context.getSourceCode();
	var lines = source.lines;

	/**
	* Reports the error message.
	*
	* @private
	* @param {string} msg - message to report
	* @param {Object} loc - lines of code (object with `start` and `end` properties)
	* @param {Object} opts - options
	* @param {boolean} opts.beforeHeader - boolean indicating whether the error is before a section header
	* @param {boolean} opts.lastLine - boolean indicating whether the error is on the last line
	*/
	function report( msg, loc, opts ) {
		context.report({
			'node': null,
			'message': msg,
			'loc': loc,
			'fix': fix
		});

		/**
		* Fixes the lint error.
		*
		* @private
		* @param {Object} fixer - ESLint fixer
		* @returns {Object} fix
		*/
		function fix( fixer ) {
			var nSpaces;
			var range;
			var start;
			var end;
			var i;

			start = 0;
			end = 0;
			for ( i = 0; i < lines.length; i++ ) {
				if ( i < loc.start.line ) {
					start += lines[ i ].length + 1;
				}
				else if ( i < loc.end.line ) {
					end += lines[ i ].length + 1;
				}
			}
			range = [ start, start + end ];
			if ( opts.beforeHeader ) {
				nSpaces = 2;
			} else if ( opts.lastLine ) {
				nSpaces = 0;
			} else {
				nSpaces = 1;
			}
			return fixer.replaceTextRange( range, '\n'.repeat( nSpaces ) );
		}
	}

	/**
	* Checks whether code contains multiple blank lines.
	*
	* @private
	*/
	function validate() {
		var nonEmpty;
		var current;
		var diff;
		var line;
		var prev;
		var loc;
		var msg;
		var i;

		nonEmpty = [];
		for ( i = 0; i < lines.length; i++ ) {
			if ( trim( lines[ i ] ) !== '' ) {
				nonEmpty.push( i );
			}
		}
		nonEmpty.unshift( -1 ); // allows empty lines at beginning to be checked
		nonEmpty.push( lines.length ); // allows trailing empty lines to be checked
		for ( i = 1; i < nonEmpty.length; i++ ) {
			diff = 2;
			msg = 'Only one blank line is allowed';
			current = nonEmpty[ i ];
			prev = nonEmpty[ i-1 ];
			line = lines[ current ];
			if ( line && isSectionHeader( line ) ) {
				diff += 1;
				msg = 'Not more than two blank lines are allowed before a section header';
			}
			if ( current - prev > diff ) {
				loc = {
					'start': {
						'line': prev + 1,
						'column': 0
					},
					'end': {
						'line': current,
						'column': 0
					}
				};
				report( msg, loc, {
					'beforeHeader': diff === 3,
					'lastLine': i === nonEmpty.length-1
				});
			}
		}
	}

	return {
		'Program:exit': validate
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce that code does not contain multiple blank lines'
		},
		'fixable': 'whitespace',
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
