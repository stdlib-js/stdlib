/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var parseJSDoc = require( 'doctrine' ).parse;
var contains = require( '@stdlib/assert/contains' );
var endsWith = require( '@stdlib/string/ends-with' );
var startsWith = require( '@stdlib/string/starts-with' );
var removeLast = require( '@stdlib/string/remove-last' );
var replace = require( '@stdlib/string/replace' );


// VARIABLES //

// TODO: Figure out a better way than relying on a curated list of non-verbs
var NON_VERBS = [
	'Bias',
	'BLAS',
	'Alias',
	'Canvas',
	'Datasets',
	'Windows'
];
var DOPTS = {
	'sloppy': true,
	'unwrap': true,
	'tags': [ 'module', 'example' ]
};
var rule;


// FUNCTIONS //

/**
* Rule for validating that the JSDoc comment documenting a package's main export adheres to stdlib conventions and contains the correct package path.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var RE_REQUIRE;
	var modulePath;
	var activate;
	var comments;
	var ending;
	var source;

	source = context.getSourceCode();
	modulePath = context.getFilename();

	// Get the part starting with `@stdlib`, shift by one to avoid leading `@`:
	modulePath = modulePath.substr( modulePath.indexOf( '@stdlib' )+1 );

	// Replace Windows path separators with POSIX path separators (if present):
	modulePath = replace( modulePath, '\\', '/' );

	activate = false;
	ending = '/lib/index.js';
	if ( endsWith( modulePath, ending ) && !contains( source.text, '@namespace' ) ) {
		activate = true;
		modulePath = modulePath.substr( 0, modulePath.length - ending.length );
		RE_REQUIRE = new RegExp( 'require\\( \'@'+modulePath+'\' \\)' );
	}

	/**
	* Reports the error message.
	*
	* @private
	* @param {string} msg - error message
	* @param {Object} loc - lines of code (object with `start` and `end` properties)
	*/
	function report( msg, loc ) {
		context.report({
			'node': null,
			'message': msg,
			'loc': loc
		});
	}

	/**
	* Checks whether the first require statement in example code for the main export of a package requires the module itself.
	*
	* @private
	* @param {Object} tag - example tag
	* @param {Object} loc - lines of code (object with `start` and `end` properties)
	*/
	function checkExample( tag, loc ) {
		var match;

		match = RE_REQUIRE.exec( tag.description );
		if ( match ) {
			// The main export should be required last, so no `require` calls should follow:
			if ( match.index !== tag.description.lastIndexOf( 'require(' ) ) {
				report( 'Example code of main export should require itself last, i.e. contain `require( \'@'+modulePath+'\' )` as the last `require` call', loc );
			}
		} else {
			report( 'Example code of main export should require itself, i.e. contain `require( \'@'+modulePath+'\' )`', loc );
		}
	}

	/**
	* Checks whether JSDoc comments documenting a package's main export adhere to stdlib conventions and contain correct module paths.
	*
	* @private
	* @param {Object} node - program AST node
	* @returns {void}
	*/
	function validate( node ) {
		var hasModuleTag;
		var firstWord;
		var comment;
		var descr;
		var ast;
		var str;
		var tag;
		var i;
		var j;

		hasModuleTag = false;
		comments = source.getAllComments();
		if ( comments.length === 0 ) {
			return report( 'Missing JSDoc comment for `index.js` file, see https://bit.ly/stdlib-pkg-index for example snippet', node.loc );
		}
		for ( i = 0; i < comments.length; i++ ) {
			comment = comments[ i ];

			// Check whether comment is JSDoc:
			if ( startsWith( comment.value, '*\n*' ) ) {
				str = comment.value;

				// Replace `@module @stdlib/...` by `@module stdlib/...` to address failure/limitation in JSDoc parsing:
				str = replace( str, '@module @', '@module ' );
				ast = parseJSDoc( str, DOPTS );

				descr = ast.description;
				if ( descr ) {
					firstWord = descr.substr( 0, descr.indexOf( ' ' ) );
					if (
						endsWith( firstWord, 's' ) &&
						!contains( NON_VERBS, firstWord ) &&
						!endsWith( firstWord, '\'s' )
					) {
						report( 'Begin description with `'+removeLast( firstWord )+'` instead of `'+firstWord+'`', comment.loc );
					}
				}
				for ( j = 0; j < ast.tags.length; j++ ) {
					tag = ast.tags[ j ];
					if ( tag.title === 'module' ) {
						hasModuleTag = true;
						if ( tag.name !== modulePath ) {
							report( 'Expected `@'+modulePath+'` for `@module` tag, but encountered `@'+tag.name+'`', comment.loc );
						}
					}
					else if ( tag.title === 'example' ) {
						checkExample( tag, comment.loc );
					}
				}
			}
		}
		if ( !hasModuleTag ) {
			report( 'JSDoc comment for main export is missing `@module @'+modulePath+'` tag', comment.loc );
		}
	}

	if ( activate ) {
		return {
			'Program:exit': validate
		};
	}
	return {};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce that the JSDoc comment documenting a package\'s main export adheres to stdlib conventions and contains the correct package path'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
