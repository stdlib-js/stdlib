/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var vm = require( 'vm' );
var proc = require( 'process' );
var join = require( 'path' ).join;
var format = require( 'util' ).format;
var dirname = require( 'path' ).dirname;
var logger = require( 'debug' );
var parseJSDoc = require( 'doctrine' ).parse;
var Buffer = require( '@stdlib/buffer/ctor' );
var isNull = require( '@stdlib/assert/is-null' );
var isNumber = require( '@stdlib/assert/is-number' );
var isObject = require( '@stdlib/assert/is-object' );
var contains = require( '@stdlib/assert/contains' );
var findJSDoc = require( '@stdlib/_tools/eslint/utils/find-jsdoc' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var startsWith = require( '@stdlib/string/starts-with' );
var replace = require( '@stdlib/string/replace' );
var objectKeys = require( '@stdlib/utils/keys' );
var compareValues = require( '@stdlib/_tools/doctest/compare-values' );
var createAnnotationValue = require( '@stdlib/_tools/doctest/create-annotation-value' );
var SCOPE_DEFAULTS = require( './scope_defaults.json' );
var windowShim = require( './window.js' );


// VARIABLES //

var debug = logger( 'jsdoc-doctest' );
var RE_ANNOTATION = /(?:\n|^)(?:var|let|const)? ?([a-zA-Z0-9._]+) ?=?[^;]*;\n\/\/ ?(returns|([A-Za-z][A-Za-z_0-9]*)? ?=>|throws) {0,1}([\s\S]*?)(\n|$)/g;
var RE_CONSOLE = /console\.(?:dir|error|log)/;
var NODE_SHEBANG = /#!\/usr\/bin\/env node/;
var DOPTS = {
	'sloppy': true,
	'unwrap': true,
	'tags': [ 'example' ]
};
var rule;


// FUNCTIONS //

/**
* Shim for `console.log` function that returns the logged data instead of printing it to `stdout`.
*
* @private
* @param {*} data - data to be logged
* @param {...*} args - substitution values
* @returns {*} return value
*/
function log( data ) {
	if ( isString( data ) ) {
		return format.apply( null, arguments );
	}
	return data;
}

/**
* Adds asterisks to the beginning of each line of a string.
*
* @private
* @param {string} str - input string
* @returns {string} string padded with asterisks at the beginning of each line
*/
function addAsterisks( str ) {
	str = '* '+str;
	str = replace( str, /\n(?!$)/g, '\n* ' );
	str = replace( str, /\s*\n/g, '\n' );
	return str;
}

/**
* Searches for variable in scope matching the expected value.
*
* @private
* @param {Object} scope - VM scope
* @param {any} expected - expected value to search for
* @returns {string} variable name or `?` if no match found
*/
function findName( scope, expected ) {
	var keys = objectKeys( scope );
	var key;
	var i;
	for ( i = 0; i < keys.length; i++ ) {
		key = keys[ i ];
		if (
			!contains( SCOPE_DEFAULTS, key ) &&
			!compareValues( scope[ key ], expected )
		) {
			return key;
		}
	}
	return '?';
}


// MAIN //

/**
* Rule for validating that return annotations in example code match the actual output.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var filename;
	var source;
	var scope;
	var opts;
	var dir;

	source = context.getSourceCode();
	if ( NODE_SHEBANG.test( source.text ) ) {
		// Do not lint executable Node.js script files:
		return {};
	}
	filename = context.getFilename();
	dir = dirname( filename );
	opts = {
		'includeDecimal': false
	};
	/**
	* Requires modules after converting relative to absolute paths.
	*
	* @private
	* @param {string} path - module path
	* @returns {*} required module
	*/
	function customRequire( path ) {
		if ( startsWith( path, './' ) ) {
			return require( join( dir, path ) ); // eslint-disable-line stdlib/no-dynamic-require
		}
		return require( path ); // eslint-disable-line stdlib/no-dynamic-require
	}
	scope = {
		'require': customRequire,
		'exports': exports,
		'module': module,
		'process': proc,
		'setTimeout': setTimeout,
		'clearTimeout': clearTimeout,
		'setInterval': setInterval,
		'clearInterval': clearInterval,
		'window': windowShim,
		'Buffer': Buffer,
		'__dirname': dir,
		'__filename': filename,
		'console': {
			'dir': log,
			'error': log,
			'log': log,
			'warn': log
		}
	};

	vm.createContext( scope );
	try {
		vm.runInContext( source.text, scope );
	} catch ( err ) {
		debug( 'Encountered an error: '+err.message );
	}

	/**
	* Reports the error message.
	*
	* @private
	* @param {Object} jsdoc - JSDoc comment object
	* @param {string} msg - error message
	* @param {string} replacement - fixed return annotation
	*/
	function report( jsdoc, msg, replacement ) {
		context.report({
			'node': null,
			'loc': jsdoc.loc,
			'message': msg,
			'fix': fix
		});

		/**
		* Applies a fix to the offending code.
		*
		* @private
		* @param {Object} fixer - object to apply a fix
		* @returns {Object} fixing object
		*/
		function fix( fixer ) {
			return fixer.replaceTextRange( jsdoc.range, replacement );
		}
	}

	/**
	* Checks whether return annotations in example code match the actual output.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var jsdoc;
		var ast;

		if ( node.parent.type !== 'Program' ) {
			// Only validate nodes at the module scope...
			return;
		}
		jsdoc = findJSDoc( source, node );
		if ( isObject( jsdoc ) ) {
			ast = parseJSDoc( jsdoc.value, DOPTS );
			processTags( jsdoc, ast.tags );
		}
	}

	/**
	* Processes the extracted example tags.
	*
	* @private
	* @param {Object} jsdoc - JSDoc comment object
	* @param {Array} tags - array of tags
	*/
	function processTags( jsdoc, tags ) {
		var expected;
		var actual;
		var descr;
		var found;
		var code;
		var last;
		var type;
		var arr;
		var str;
		var tag;
		var msg;
		var out;
		var i;

		try {
			for ( i = 0; i < tags.length; i++ ) {
				tag = tags[ i ];
				last = 0;

				// Run entire code in case it relies on hoisting of function declarations:
				try {
					vm.runInContext( tag.description, scope );
				} catch ( err ) {
					debug( 'Encountered an error: '+err.message );
				}
				arr = RE_ANNOTATION.exec( tag.description );
				while ( !isNull( arr ) ) {
					// Run intermediary code:
					code = tag.description.substring( last, arr.index );
					last = arr.index + arr[ 0 ].length;
					if ( code ) {
						vm.runInContext( code, scope );
					}
					found = arr[ 2 ]+' '+arr[ 4 ];

					// Run code preceding return annotation:
					try {
						out = vm.runInContext( arr[ 0 ], scope );
						if ( RE_CONSOLE.test( arr[ 1 ] ) ) {
							actual = out;
						} else {
							actual = scope[ arr[ 1 ] ];
						}
						if ( arr[ 3 ] ) {
							actual = vm.runInContext( arr[ 3 ], scope );
						}
						expected = arr[ 4 ];
						msg = compareValues( actual, expected );
						if ( msg ) {
							opts.includeDecimal = isNumber( actual ) && contains( expected, '.' );
							str = createAnnotationValue( actual, opts );
							str = replace( arr[ 0 ], found, arr[ 2 ]+' '+str );
							str = replace( tag.description, arr[ 0 ], str );
							str = addAsterisks( str );
							descr = addAsterisks( tag.description );
							str = replace( jsdoc.value, descr, str );
							str = '/*'+str+'*/';
							report( jsdoc, msg, str );
						}
					} catch ( err ) {
						type = '<'+err.name+'>';

						if ( arr[ 2 ] !== 'throws' ) {
							/* eslint-disable max-depth */
							if ( arr[ 3 ] ) {
								msg = 'Encountered an error: `'+err.message+'`.';
							} else {
								msg = 'Encountered an error while running code: `'+err.message+'`.';
								msg += 'Did you mean to include a `// throws '+type+'` annotation instead of `// '+found+'`?';
							}
							/* eslint-enable max-depth */
						} else if (arr[ 4 ] !== type ) {
							msg = 'Code should have a `// throws '+type+'` annotation, but received: `// '+found+'`';
						}
						if ( msg ) {
							str = ( arr[ 3 ] ) ? findName( scope, arr[ 4 ] ) + ' => ' + arr[ 4 ] : 'throws '+type;
							str = replace( tag.description, found, str );
							str = replace( jsdoc.value, tag.description, str );
							str = '/*'+str+'*/';
							report( jsdoc, msg, str );
						}
					}
					arr = RE_ANNOTATION.exec( tag.description );
				}
			}
		} catch ( err ) {
			report( jsdoc, 'Encountered an error while running code: '+err.message );
		} finally {
			RE_ANNOTATION.lastIndex = 0;
		}
	}

	return {
		'FunctionExpression:exit': validate,
		'FunctionDeclaration:exit': validate,
		'VariableDeclaration:exit': validate,
		'ExpressionStatement:exit': validate
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'validate that return annotations in example code match the actual output'
		},
		'fixable': 'code',
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
