/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

var invalid = [];
var test;

test = {
	'code': [
		'/**',
		'* Returns an iterator for generating pseudorandom numbers drawn from a Bernoulli distribution.',
		'*',
		'* @param {Probability} p - success probability',
		'* @param {Options} [options] - function options',
		'* @param {*} [options.seed] - pseudorandom number generator seed',
		'* @param {NonNegativeInteger} [options.iter] - number of iterations',
		'* @returns {Iterator} iterator',
		'*',
		'* @example',
		'* var iter = iterator( 0.3 );',
		'*',
		'* var r = iter.next().value;',
		'* // returns <number>',
		'*',
		'* r = iter.next().value;',
		'* // returns <number>',
		'*',
		'* r = iter.next().value;',
		'* // returns <number>',
		'*',
		'* // ...',
		'*/',
		'function iterator( p, options ) {',
		'  var niter;',
		'  var iter;',
		'  var rand;',
		'  var FLG;',
		'  var i;',
		'  if ( !isProbability( p ) ) {',
		'    throw new TypeError( \'invalid argument. First argument must be a probability. Value: `\'+p+\'`.\' );',
		'  }',
		'  niter = MAX_VALUE;',
		'  if ( arguments.length > 1 ) {',
		'    if ( !isObject( options ) ) {',
		'      throw new TypeError( \'invalid argument. Options argument must be an object. Value: `\'+options+\'`.\' );',
		'    }',
		'    if ( hasOwnProp( options, \'iter\' ) ) {',
		'      niter = options.iter;',
		'      if ( !isNonNegativeInteger( niter ) ) {',
		'        throw new TypeError( \'invalid option. `iter` option must be a nonnegative integer. Option: `\'+niter+\'`.\' );',
		'      }',
		'    }',
		'    rand = rbern( p, options );',
		'  } else {',
		'    rand = rbern( p );',
		'  }',
		'  i = 0;',
		'',
		'  // Create an iterator protocol-compliant object:',
		'  iter = {};',
		'  setReadOnly( iter, \'next\', next );',
		'  setReadOnly( iter, \'return\', end );',
		'  setReadOnly( iter, \'seed\', rand.seed );',
		'',
		'  // If an environment supports `Symbol.iterator`, make the iterator iterable:',
		'  if ( iteratorSymbol ) {',
		'  setReadOnly( iter, iteratorSymbol, factory );',
		'  }',
		'  return iter;',
		'',
		'  /**',
		'  * Returns an iterator protocol-compliant object containing the next iterated value.',
		'  *',
		'  * @private',
		'  * @returns {Object} iterator protocol-compliant object',
		'  */',
		'  function next() {',
		'    i += 1;',
		'    if ( FLG || i > niter ) {',
		'      return {',
		'        \'done\': true',
		'      };',
		'    }',
		'    return {',
		'      \'value\': rand(),',
		'      \'done\': false',
		'    };',
		'  }',
		'',
		'  /**',
		'  * Finishes an iterator.',
		'  *',
		'  * @private',
		'  * @param {*} [value] - value to return',
		'  * @returns {Object} iterator protocol-compliant object',
		'  */',
		'  function end( value ) {',
		'    FLG = true;',
		'    if ( arguments.length ) {',
		'      return {',
		'        \'value\': value,',
		'        \'done\': true',
		'      };',
		'    }',
		'    return {',
		'      \'done\': true',
		'    };',
		'  }',
		'',
		'  /**',
		'  * Returns a new iterator.',
		'  *',
		'  * @private',
		'  * @returns {Iterator} iterator',
		'  */',
		'  function factory() {',
		'    iterator( p, {',
		'      \'seed\': iter.seed,',
		'      \'iter\': niter',
		'    });',
		'  }',
		'}'
	].join( '\n' ),
	'errors': [
		{
			'message': '`iterator` is missing `@throws {TypeError}` annotation(s)',
			'type': null
		}
	]
};
invalid.push( test );

test = {
	'code': [
		' /**',
		' * Copies or deep clones a value to an arbitrary depth.',
		' *',
		' * @param {*} value - value to copy',
		' * @param {NonNegativeInteger} [level=+infinity] - copy depth',
		' * @returns {*} value copy',
		' */',
		' function copy( value, level ) {',
		'   var out;',
		'   if ( arguments.length > 1 ) {',
		'     if ( !isNonNegativeInteger( level ) ) {',
		'       throw new TypeError( \'invalid argument. `level` must be a nonnegative integer. Value: `\' + level + \'`.\' );',
		'     }',
		'     if ( level === 0 ) {',
		'       return value;',
		'     }',
		'   } else {',
		'     level = PINF;',
		'   }',
		'   out = ( isArray( value ) ) ? new Array( value.length ) : {};',
		'   return deepCopy( value, out, [value], [out], level );',
		' }'
	].join( '\n' ),
	'errors': [
		{
			'message': '`copy` is missing `@throws {TypeError}` annotation(s)',
			'type': null
		}
	]
};
invalid.push( test );

test = {
	'code': [
		'/**',
		'* Generates a linearly spaced numeric array using an increment of one.',
		'*',
		'* @param {number} x1 - first array value',
		'* @param {number} x2 - array element bound',
		'* @throws {TypeError} first argument must be numeric',
		'* @throws {TypeError} second argument must be numeric',
		'* @returns {Array} linearly spaced numeric array',
		'*/',
		'function incrspace( x1, x2 ) {',
		'  var arr;',
		'  var len;',
		'  var inc;',
		'  var i;',
		'  if ( !isNumber( x1 ) || isnan( x1 ) ) {',
		'    throw new TypeError( \'invalid argument. Start must be numeric. Value: `\' + x1 + \'`.\' );',
		'  }',
		'  if ( !isNumber( x2 ) || isnan( x2 ) ) {',
		'    throw new TypeError( \'invalid argument. Stop must be numeric. Value: `\' + x2 + \'`.\' );',
		'  }',
		'  inc = 1;',
		'  len = ceil( ( x2-x1 ) / inc );',
		'  if ( len > MAX_LENGTH ) {',
		'    throw new RangeError( \'invalid arguments. Generated array exceeds maximum array length.\' );',
		'  }',
		'  if ( len <= 1 ) {',
		'    return [ x1 ];',
		'  }',
		'  arr = [];',
		'  arr.push( x1 );',
		'  for ( i = 1; i < len; i++ ) {',
		'    arr.push( x1 + (inc*i) );',
		'  }',
		'  return arr;',
		'}'
	].join( '\n' ),
	'errors': [
		{
			'message': '`incrspace` is missing `@throws {RangeError}` annotation(s)',
			'type': null
		}
	]
};
invalid.push( test );

test = {
	'code': [
		'/**',
		'* Beep boop.',
		'*',
		'* @name bar',
		'* @memberof Foo.prototype',
		'* @type {Function}',
		'*/',
		'Object.defineProperty( Foo.prototype, \'bar\', {',
		'  \'configurable\': false,',
		'  \'enumerable\': false,',
		'  \'writable\': false,',
		'  \'value\': function bar() {',
		'    throw new Error( \'beep\' );',
		'  }',
		'});'
	].join( '\n' ),
	'errors': [
		{
			'message': '`bar` is missing `@throws {Error}` annotation(s)',
			'type': null
		}
	]
};
invalid.push( test );

test = {
	'code': [
		'/**',
		'* Beep boop.',
		'*',
		'* @name bar',
		'* @memberof Foo.prototype',
		'* @type {Function}',
		'*/',
		'defineProperty( Foo.prototype, \'bar\', {',
		'  \'configurable\': false,',
		'  \'enumerable\': false,',
		'  \'writable\': false,',
		'  \'value\': function bar() {',
		'    throw new Error( \'beep\' );',
		'  }',
		'});'
	].join( '\n' ),
	'errors': [
		{
			'message': '`bar` is missing `@throws {Error}` annotation(s)',
			'type': null
		}
	]
};
invalid.push( test );


// EXPORTS //

module.exports = invalid;
