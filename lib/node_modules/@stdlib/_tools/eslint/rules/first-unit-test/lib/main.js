/**
* @license Apache-2.0
*
* Copyright (c) 2023 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var startsWith = require( '@stdlib/string/starts-with' );
var endsWith = require('@stdlib/string/ends-with');
var contains = require( '@stdlib/assert/contains' );


// VARIABLES //

var rule;


// FUNCTIONS //

/**
* Rule for ensuring that test files start with a test of a specific structure and name.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	/**
	* Reports the error message.
	*
	* @private
	* @param {ASTNode} node - node to report
	* @param {string} message - error message
	*/
	function report( node, message ) {
		context.report({
			'node': node,
			'message': message
		});
	}

	/**
	* Checks the structure and name of the first test.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var hasMainExportTest;
		var tOkExists;
		var filename;
		var forCLI;
		var first;
		var body;
		var elem;
		var expr;
		var fix;
		var msg;
		var i;
		var j;

		hasMainExportTest = false;
		tOkExists = false;
		filename = context.getFilename();
		if ( contains( filename, 'test.' ) && !contains( filename, 'fixtures' ) ) {
			if ( endsWith( filename, 'cli.js' ) ) {
				forCLI = true;
			}
			for ( i = 0; i < node.body.length; i++ ) {
				elem = node.body[ i ];
				if (
					elem.type === 'ExpressionStatement' &&
					elem.expression &&
					elem.expression.type === 'CallExpression' &&
					elem.expression.callee.name === 'tape'
				) {
					if (
						startsWith( elem.expression.arguments[ 0 ].value, 'main export is' ) ||
						( forCLI && startsWith( elem.expression.arguments[ 0 ].value, 'command-line interface' ) )
					) {
						hasMainExportTest = true;
						expr = elem.expression.arguments[ elem.expression.arguments.length-1 ]; // eslint-disable-line max-len
						body = expr.body;
						if ( !body.body || body.body.length === 0 ) {
							break;
						}
						j = 0;

						// Skip over all variable declarations...
						while ( body.body[ j ].type === 'VariableDeclaration' ) {
							j += 1;
						}
						first = body.body[ j ];
						if (
							first.type === 'ExpressionStatement' &&
							first.expression &&
							first.expression.type === 'CallExpression' &&
							first.expression.callee.object &&
							first.expression.callee.object.name === 't' &&
							first.expression.callee.property &&
							first.expression.callee.property.name === 'ok' &&
							first.expression.arguments.length === 2 &&
							first.expression.arguments[0].value === true &&
							first.expression.arguments[1].name === '__filename'
						) {
							tOkExists = true;
						}
					}
					break;
				}
			}

			if ( hasMainExportTest ) {
				if ( !tOkExists ) {
					fix = ( first ) ? insertFilenamePrintout : void 0;
					context.report({
						'node': node,
						'message': 'The first test in a test file should start with a call to `t.ok( true, __filename );`',
						'fix': fix
					});
				}
			}
			else {
				msg = ( forCLI ) ?
					'Each CLI test file should start with a test of the form `tape( \'command-line interface\', function test( t ) { ... } );`' :
					'Each test file should start with a test for the main export, e.g., tape( \'main export is a function\', function test( t ) { ... } );';
				report( node, msg );
			}
		}

		/**
		* Inserts a filename printout.
		*
		* @private
		* @param {Object} fixer - ESLint fixer
		* @returns {Object} fixer
		*/
		function insertFilenamePrintout( fixer ) {
			return fixer.insertTextBefore( first.expression, 't.ok( true, __filename );\n\t' );
		}
	}

	return {
		'Program': validate
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'ensure that each test file starts with the expected test.'
		},
		'schema': [],
		'fixable': 'code'
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
