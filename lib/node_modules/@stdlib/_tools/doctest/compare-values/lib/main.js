/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var roundn = require( '@stdlib/math/base/special/roundn' );
var epsdiff = require( '@stdlib/math/base/utils/float64-epsilon-difference' );
var indexOf = require( '@stdlib/utils/index-of' );
var typeOf = require( '@stdlib/utils/type-of' );
var deepEqual = require( '@stdlib/assert/deep-equal' );
var isNull = require( '@stdlib/assert/is-null' );
var isArray = require( '@stdlib/assert/is-array' );
var isNumber = require( '@stdlib/assert/is-number' );
var isObject = require( '@stdlib/assert/is-object' );
var isSymbol = require( '@stdlib/assert/is-symbol' );
var isUndefined = require( '@stdlib/assert/is-undefined' );
var isObjectArray = require( '@stdlib/assert/is-object-array' );
var isBoolean = require( '@stdlib/assert/is-boolean' );
var isString = require( '@stdlib/assert/is-string' );
var isRegExp = require( '@stdlib/assert/is-regexp' );
var isEmptyString = require( '@stdlib/assert/is-empty-string' );
var isComplex64 = require( '@stdlib/assert/is-complex64' );
var isComplex128 = require( '@stdlib/assert/is-complex128' );
var isComplex64Array = require( '@stdlib/assert/is-complex64array' );
var isComplex128Array = require( '@stdlib/assert/is-complex128array' );
var isBoxedPrimitive = require( '@stdlib/assert/is-boxed-primitive' );
var isPrimitive = require( '@stdlib/assert/is-primitive' );
var isObjectLike = require( '@stdlib/assert/is-object-like' );
var isFunction = require( '@stdlib/assert/is-function' );
var isTypedArray = require( '@stdlib/assert/is-typed-array' );
var isError = require( '@stdlib/assert/is-error' );
var isTypeError = require( '@stdlib/assert/is-type-error' );
var isSyntaxError = require( '@stdlib/assert/is-syntax-error' );
var isReferenceError = require( '@stdlib/assert/is-reference-error' );
var isURIError = require( '@stdlib/assert/is-uri-error' );
var isEvalError = require( '@stdlib/assert/is-eval-error' );
var isRangeError = require( '@stdlib/assert/is-range-error' );
var startsWith = require( '@stdlib/string/starts-with' );
var contains = require( '@stdlib/assert/contains' );
var endsWith = require( '@stdlib/string/ends-with' );
var removeFirst = require( '@stdlib/string/remove-first' );
var removeLast = require( '@stdlib/string/remove-last' );
var replace = require( '@stdlib/string/replace' );
var trim = require( '@stdlib/string/trim' );
var PINF = require( '@stdlib/constants/float64/pinf' );
var NINF = require( '@stdlib/constants/float64/ninf' );
var createAnnotationValue = require( '@stdlib/_tools/doctest/create-annotation-value' );
var parse = require( './parse.js' );


// VARIABLES //

var RE_INSTANCE_ANNOTATION = /<([^>]+)>(\[?[^\]]*\]?)/;
var RE_ARRAY = /(\[[\s\S]+\])/;
var RE_UNESCAPED_QUOTE = /[^\\]'/;
var BOXED_TYPE_ANNOTATIONS = [
	'<Boolean>',
	'<Number>',
	'<String>',
	'<Symbol>'
];
var PRIMITIVE_TYPE_ANNOTATIONS = [
	'<boolean>',
	'<number>',
	'<string>',
	'<symbol>'
];
var OPTS = {
	'numel': 1e308
};


// FUNCTIONS //

/**
* Checks whether a primitive value matches a return annotation.
*
* @private
* @param {(string|boolean|number|null|undefined)} actual - primitive value
* @param {string} expected - return value annotation
* @returns {boolean} boolean indicating whether value matches return annotation
*/
function checkPrimitive( actual, expected ) {
	var dgts;
	var type;
	var a;
	var b;

	type = typeOf( actual );
	if ( type === 'number' ) {
		if ( expected === 'Infinity' || expected === '+Infinity' ) {
			return actual === PINF;
		}
		if ( expected === '-Infinity' ) {
			return actual === NINF;
		}
		if ( expected === 'NaN' ) {
			return isNaN( actual );
		}
		if ( startsWith( expected, '~' ) ) {
			if ( contains( expected, 'e' ) ) {
				dgts = indexOf( expected, 'e' ) - indexOf( expected, '.' );
				a = actual.toPrecision( dgts );
				b = removeFirst( expected );
			} else {
				dgts = expected.length - indexOf( expected, '.' ) - 1;
				a = roundn( actual, -dgts );
				b = roundn( parseFloat( removeFirst( expected ) ), -dgts );
			}
		} else {
			a = actual;
			b = parseFloat( expected );
		}
		return epsdiff( a, b ) < 10.0;
	}
	if ( expected === 'null' ) {
		return isNull( actual );
	}
	if ( expected === 'undefined' ) {
		return isUndefined( actual );
	}
	if ( type === 'boolean' ) {
		actual = String( actual );
		return expected === actual;
	}
	if ( type === 'string' ) {
		// Harmonize escapes between annotations and actual values:
		expected = replace( expected, '\\\'', '\'' );
		actual = replace( actual, '\n', '\\n' );
		expected = replace( expected, '\n', '\\n' );
		actual = replace( actual, '\t', '\\t' );
		return expected === actual || expected === '...';
	}
}

/**
* Checks whether type annotation matches the actual return value.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {boolean} boolean indicating whether type annotation matches the actual output
*/
function checkForPlaceholders( actual, expected ) {
	switch ( expected ) {
	case '<boolean>':
	case '<Boolean>':
		return isBoolean( actual );
	case '<string>':
	case '<String>':
		return isString( actual );
	case '<number>':
	case '<Number>':
		return isNumber( actual );
	case '<symbol>':
	case '<Symbol>':
		return isSymbol( actual );
	case '<ObjectArray>':
		return isObjectArray( actual );
	case '<Node>':
	case '<Object>':
		return isObject( actual );
	case '<Array>':
		return isArray( actual );
	case '<Complex64>':
		return isComplex64( actual );
	case '<Complex128>':
		return isComplex128( actual );
	case '<Complex64Array>':
		return isComplex64Array( actual );
	case '<Complex128Array>':
		return isComplex128Array( actual );
	case '<Error>':
		return isError( actual );
	case '<TypeError>':
		return isTypeError( actual );
	case '<SyntaxError>':
		return isSyntaxError( actual );
	case '<ReferenceError>':
		return isReferenceError( actual );
	case '<URIError>':
		return isURIError( actual );
	case '<EvalError>':
		return isEvalError( actual );
	case '<RangeError>':
		return isRangeError( actual );
	default:
		// Uknown type, let it slide...
		return true;
	}
}

/**
* For a typed array, if the return annotation asserts deep instance equality, check whether it corresponds to the actual value; otherwise, check whether the return annotation signals the correct type.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {(string|null)} error message in case the annotation and value do not match, `null` otherwise
*/
function checkTypedArrays( actual, expected ) {
	var entries;
	var match;
	var type;
	var i;

	match = RE_INSTANCE_ANNOTATION.exec( expected );
	if ( match ) {
		type = match[ 1 ];
		entries = match[ 2 ];
		if ( actual.constructor.name !== type ) {
			return 'Expected instance type <'+actual.constructor.name+'>, but observed <'+type+'>';
		}
		if ( entries ) {
			entries = parse( entries );
			for ( i = 0; i < entries.length; i++ ) {
				if ( !checkPrimitive( actual[ i ], String( entries[ i ] ) ) ) {
					return 'Expected array entries ['+entries+'], but observed ['+actual+']';
				}
			}
		}
		return null;
	}
	return 'Typed arrays should be documented using instance annotation';
}

/**
* Checks whether the elements of an array match the return annotation.
*
* @private
* @param {Array} actual - input array
* @param {string} expected - return value annotation
* @returns {boolean} boolean indicating whether values of array match return annotation
*/
function checkArray( actual, expected ) {
	var entries;
	var match;
	var a;
	var b;
	var i;

	if ( actual.length === 0 ) {
		return expected === '[]';
	}
	match = RE_ARRAY.exec( expected );
	if ( match ) {
		entries = parse( match[ 1 ] );
		for ( i = 0; i < entries.length; i++ ) {
			a = actual[ i ];
			b = entries[ i ];
			if ( b === '...' ) {
				break;
			}
			if (
				startsWith( String( b ), '<' ) &&
				endsWith( String( b ), '>' )
			) {
				if ( !checkForPlaceholders( a, String( b ) ) ) {
					return false;
				}
				if (
					(
						contains( BOXED_TYPE_ANNOTATIONS, expected ) &&
						isPrimitive( actual )
					) || (
						contains( PRIMITIVE_TYPE_ANNOTATIONS, expected ) &&
						isBoxedPrimitive( actual )
					)
				) {
					return false;
				}
			}
			else if ( isPrimitive( a ) ) {
				b = String( b );
				if ( !checkPrimitive( a, b ) ) {
					return false;
				}
			}
			else if ( isArray( a ) ) {
				b = createAnnotationValue( b, OPTS );
				if ( !checkArray( a, b ) ) {
					return false;
				}
			}
			else if ( isRegExp( a ) ) {
				if ( a.toString() !== b.toString() ) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}


// MAIN //

/**
* Checks whether a return value is equal to the value of a return annotation.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {(string|null)} error message in case of mismatch, `null` otherwise
*
* @example
* var out = compareValues( [ 1, 2, 3 ], '[ 1, 2, ... ]' );
* // returns null
*/
function compareValues( actual, expected ) {
	var expectedValue;
	var actualString;
	var actualValue;
	var parts;
	var msg1;
	var msg2;
	var a;
	var b;

	if ( contains( expected, '||' ) ) {
		parts = expected.split( '||' );
		a = trim( parts[ 0 ] );
		b = trim( parts[ 1 ] );
		msg1 = compareValues( actual, a );
		msg2 = compareValues( actual, b );
		if ( msg1 && msg2 ) {
			return 'Actual value is `'+actual+'`, but expected `'+a+'` or `'+b+'`';
		}
		return null;
	}
	if ( isEmptyString( expected ) ) {
		return 'Return annotation is empty';
	}
	if ( contains( expected, 'e.g.' ) ) {
		// Early return since we cannot compare actual value to return annotation value:
		return null;
	}

	if ( startsWith( expected, '<' ) && endsWith( expected, '>' ) ) {
		if ( !checkForPlaceholders( actual, expected ) ) {
			return 'Expected a '+expected+', but received: `'+actual+'`';
		}
		if (
			contains( BOXED_TYPE_ANNOTATIONS, expected ) &&
			isPrimitive( actual )
		) {
			return 'Expected a '+expected+', but received an unboxed primitive: `'+actual+'`';
		}
		if (
			contains( PRIMITIVE_TYPE_ANNOTATIONS, expected ) &&
			isBoxedPrimitive( actual )
		) {
			return 'Expected a '+expected+', but received a boxed primitive: `'+actual+'`';
		}
		return null;
	}
	if ( isPrimitive( actual ) ) {
		if ( isString( actual) ) {
			if (
				!RE_UNESCAPED_QUOTE.test( actual ) &&
				( !startsWith( expected, '\'' ) || !endsWith( expected, '\'' ) )
			) {
				return '`'+expected+'` should be wrapped in single quotes';
			}
			expected = removeFirst( removeLast( expected ) );
		}
		if ( !checkPrimitive( actual, expected ) ) {
			return 'Displayed return value is `'+expected+'`, but expected `'+actual+'` instead';
		}
	}
	else if ( isTypedArray( actual ) ) {
		return checkTypedArrays( actual, expected );
	}
	if ( isArray( actual ) ) {
		if ( !checkArray( actual, expected ) ) {
			return 'Displayed return value is `'+expected+'`, but expected `'+createAnnotationValue( actual )+'` instead';
		}
	}
	else if ( isRegExp( actual ) ) {
		actual = actual.toString();
		if ( actual !== expected ) {
			return 'Displayed return value is `'+expected+'`, but expected `'+actual+'` instead';
		}
	}
	else if ( isFunction( actual ) ) {
		actual = actual.toString();
		if ( actual !== expected ) {
			return 'Displayed return value is `'+expected+'`, but expected `'+actual+'` instead';
		}
	}
	else if ( isObjectLike( actual ) ) {
		if ( !contains( expected, '...' ) ) {
			try {
				expectedValue = parse( expected );
			} catch ( err ) {
				return 'Malformed return annotation. Encountered error while parsing: '+err.message;
			}
			actualString = createAnnotationValue( actual, OPTS );
			actualValue = parse( actualString );
			if ( !deepEqual( expectedValue, actualValue ) ) {
				return 'Displayed return value is `'+expected+'`, but expected `'+actualString+'` instead';
			}
		}
	}
	return null;
}


// EXPORTS //

module.exports = compareValues;
