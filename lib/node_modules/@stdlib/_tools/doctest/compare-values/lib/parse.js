/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The code is inspired by the JSON parse function by [Douglas Crockford]{@link https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js}.
*
* The original code was released by its author into the public domain.
*/

'use strict';

// MODULES //

var startsWith = require( '@stdlib/string/starts-with' );
var reFromString = require( '@stdlib/utils/regexp-from-string' );
var isNumberArray = require( '@stdlib/assert/is-number-array' );
var isFinite = require( '@stdlib/assert/is-finite' ); // eslint-disable-line stdlib/no-redeclare
var isString = require( '@stdlib/assert/is-string' );
var NINF = require( '@stdlib/constants/float64/ninf' );
var PINF = require( '@stdlib/constants/float64/pinf' );
var ctors = require( './typed_array_ctors.js' );


// VARIABLES //

var at;     // The index of the current character
var ch;     // The current character
var escapee = {
	'\'': '\'',
	'\\': '\\',
	'/': '/',
	'b': '\b',
	'f': '\f',
	'n': '\n',
	'r': '\r',
	't': '\t'
};
var text;


// FUNCTIONS //

/**
* Parses a value. It could be an object, an array, a string, a number, a regular expression, a placeholder sequence (`...`), a type annotation, or a word.
*
* @private
* @returns {*} parsed vlaue
*/
function value() {
	white();
	switch ( ch ) {
	case '{':
		return object();
	case '[':
		return array();
	case '\'':
	case '"':
		return string();
	case '-':
	case '+':
	case '~':
	case 'I':
		return number();
	case '/':
		return regexp();
	case '.':
		return dots();
	case '<':
		return type();
	default:
		return ( ch >= '0' && ch <= '9' ) ? number() : word();
	}
}

/**
* Throws an error when something went wrong during parsing.
*
* @private
* @param {string} m - error message
* @throws {SyntaxError} must provide valid annotation value
*/
function error( m ) {
	throw new SyntaxError( m );
}

/**
* Parses a regular expression.
*
* @private
* @returns {RegExp} parsed regular expression
*/
function regexp() {
	var re = '/';
	if ( ch === '/' ) {
		goNext( '/' );
		if ( ch === '/' ) {
			goNext( '/' );
			return new RegExp();
		}
		while ( ch ) {
			re += ch;
			if ( ch === '/' ) {
				goNext( '/' );
				while ( ch === 'i' || ch === 'g' || ch === 'm' ) {
					re += ch;
					goNext();
				}
				return reFromString( re );
			}
			goNext();
		}
	}
}

/**
* Parses placeholder dots.
*
* @private
* @returns {(string|undefined)} `...` or undefined
*/
function dots() {
	if ( ch === '.' ) {
		goNext( '.' );
		goNext( '.' );
		goNext( '.' );
		return '...';
	}
}

/**
* Matches `true`, `false`, `null`, `undefined`, and `'NaN'`.
*
* ## Notes
*
* -   The function parses `NaN` as a string in order for deep equality checks in the main function to pass for `NaN`.
*
* @private
* @returns {(boolean|null|string|undefined)} parseed value
*/
function word() {
	switch ( ch ) {
	case 't':
		goNext('t');
		goNext('r');
		goNext('u');
		goNext('e');
		return true;
	case 'f':
		goNext('f');
		goNext('a');
		goNext('l');
		goNext('s');
		goNext('e');
		return false;
	case 'n':
		goNext('n');
		goNext('u');
		goNext('l');
		goNext('l');
		return null;
	case 'N':
		goNext('N');
		goNext('a');
		goNext('N');
		return 'NaN';
	case 'u':
		goNext('u');
		goNext('n');
		goNext('d');
		goNext('e');
		goNext('f');
		goNext('i');
		goNext('n');
		goNext('e');
		goNext('d');
		return void 0;
	default:
		error( 'Unexpected `' + ch + '`' );
	}
}

/**
* Parses a type annotation.
*
* @private
* @returns {string} type identifier wrapped in quotes
*/
function type() {
	var str = '';
	var arr;

	if ( ch === '<' ) {
		goNext( '<' );
		if ( ch === '>' ) {
			goNext( '>' );
			return '<>'; // empty type annotation
		}
		while ( ch !== '>' ) {
			str += ch;
			goNext();
		}
		goNext( '>' );
		if ( ch === '[' ) {
			// Encountered a deep instance equality type annotation:
			arr = array();
			if ( isNumberArray( arr ) ) {
				return new ctors[ str ]( arr );
			}
			return arr;
		}
		return '<'+str+'>';
	}
}

/**
* Skips whitespace.
*
* @private
*/
function white() {
	while ( ch && ch <= ' ' ) {
		goNext();
	}
}

/**
* Parses an array value.
*
* @private
* @returns {Array} parsed array
*/
function array() {
	var arr = [];
	if ( ch === '[' ) {
		goNext( '[' );
		white();
		if ( ch === ']' ) {
			goNext( ']' );
			return arr; // empty array
		}
		while ( ch ) {
			if ( text.charAt( at-1 ) === ',' ) {
				arr.push( void 0 );
				white();
				goNext( ',' );
				white();
			} else {
				arr.push( value() );
				white();
				if ( ch === ']' ) {
					goNext( ']' );
					return arr;
				}
				goNext( ',' );
				white();
			}
		}
	}
	error( 'Bad array' );
}

/**
* Parses an object value.
*
* @private
* @returns {Object} parsed object
*/
function object() {
	var obj = {};
	var key;

	if ( ch === '{' ) {
		goNext( '{' );
		white();
		if ( ch === '.' ) {
			// Encountered object placeholder `{...}`:
			goNext( '.' );
			goNext( '.' );
			goNext( '.' );
			goNext( '}' );
			return '<Object>';
		}
		if ( ch === '}' ) {
			goNext( '}' );
			return obj;   // empty object
		}
		while ( ch ) {
			key = objectKey();
			white();
			goNext( ':' );
			if ( Object.hasOwnProperty.call( obj, key ) ) {
				error( 'Duplicate key `' + key + '`' );
			}
			obj[ key ] = value();
			white();
			if ( ch === '}' ) {
				goNext( '}' );
				return obj;
			}
			goNext( ',' );
			white();
		}
	}
	error( 'Bad object' );
}

/**
* Parses a string value.
*
* @private
* @returns {string} parsed string
*/
function string() {
	var value;
	var uffff;
	var hex;
	var i;

	value = '';

	// When parsing for string values, we must look for `'` and `\` characters.
	if ( ch === '\'' || ch === '"' ) {
		while ( goNext() ) {
			if ( ch === '\'' || ch === '"' ) {
				goNext();
				return value;
			}
			if ( ch === '\\' ) {
				goNext();
				if ( ch === 'u' ) {
					uffff = 0;
					for ( i = 0; i < 4; i += 1 ) {
						hex = parseInt( goNext(), 16 );

						// eslint-disable-next-line max-depth
						if ( !isFinite( hex ) ) {
							break;
						}
						uffff = ( uffff * 16 ) + hex;
					}
					value += String.fromCharCode( uffff );
				} else if ( isString( escapee[ch] ) ) {
					value += escapee[ ch ];
				} else {
					break;
				}
			} else {
				value += ch;
			}
		}
	}
	error( 'Bad string' );
}

/**
* Parses an object key.
*
* @private
* @returns {string} parsed key
*/
function objectKey() {
	var value = '';

	if ( ch === '\'' || ch === '"' ) {
		return string();
	}
	value += ch;
	while ( goNext() ) {
		if ( ch === ':' ) {
			return value;
		}
		value += ch;
	}
}

/**
* Returns the next character and assigns it to the `ch` variable. When there are no more characters, the function returns the empty string.
*
* ## Notes
*
* -   If a `c` parameter is provided, the function verifies that it matches the current character.
*
* @private
* @param {string} [c] - character to match
* @returns {string} next character
*/
function goNext( c ) {
	if ( c && c !== ch ) {
		error( 'Expected `' + c + '` instead of `' + ch + '`' );
	}
	ch = text.charAt( at );
	at += 1;
	return ch;
}

/**
* Parses a number value.
*
* @private
* @returns {(number|string)} parsed number or string for rounded values
*/
function number() {
	var string;
	var value;

	string = '';
	if ( ch === '~' ) {
		string += '~';
		goNext( '~' );
	}
	if ( ch === '-' ) {
		string += '-';
		goNext( '-' );
	}
	if ( ch === '+' ) {
		goNext( '+' );
	}
	if ( ch === 'I' ) {
		goNext( 'I' );
		goNext( 'n' );
		goNext( 'f' );
		goNext( 'i' );
		goNext( 'n' );
		goNext( 'i' );
		goNext( 't' );
		goNext( 'y' );
		return ( string === '-' ) ? NINF : PINF;
	}
	while ( ch >= '0' && ch <= '9' ) {
		string += ch;
		goNext();
	}
	if ( ch === '.' ) {
		string += '.';
		while ( goNext() && ch >= '0' && ch <= '9' ) {
			string += ch;
		}
	}
	if ( ch === 'e' || ch === 'E' ) {
		string += ch;
		goNext();
		if ( ch === '-' || ch === '+' ) {
			string += ch;
			goNext();
		}
		while ( ch >= '0' && ch <= '9' ) {
			string += ch;
			goNext();
		}
	}
	if ( startsWith( string, '~' ) ) {
		return string;
	}
	value = +string;
	if ( !isFinite( value ) ) {
		return error( 'Bad number' );
	}
	return value;
}


// MAIN //

/**
* Parses a return annotation value to a JavaScript object.
*
* @param {string} source - return annotation value
* @returns {*} parsed value
*/
function parse( source ) {
	var result;

	text = source;
	at = 0;
	ch = ' ';
	result = value();
	white();
	if ( ch ) {
		error( 'Syntax error' );
	}
	return result;
}


// EXPORTS //

module.exports = parse;
