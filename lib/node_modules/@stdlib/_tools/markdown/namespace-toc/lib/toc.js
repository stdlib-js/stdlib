/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var replace = require( '@stdlib/string/replace' );
var contains = require( '@stdlib/assert/contains' );
var uncapitalizeDescription = require( '@stdlib/_tools/utils/uncapitalize-pkg-description' );


// VARIABLES //

var debug = logger( 'markdown-namespace-toc:toc' );
var RE_FUN_SIG = /#### [^(\n]*([^\n]*?\([^\n]*?\))\n[\s\S]*?\./;
var RE_DESCR = /\n> ([^\n]+).\n/;
var RE_LINKS = /\[([^\]]+)\]\[[^\]]+\]/g;
var RE_FUN = /#### [^(.\n]*?\([^\n]*?\)\n[\s\S]*?\./g;
var RE_PKG = /require\( '([\s\S]*?)' \)/;
var RE_ALIAS = /#### ([^(]*)\(/;


// FUNCTIONS //

/**
* Checks whether a main export has a variadic interface by scanning the `README.md` header sections.
*
* @private
* @param {Array} headers - header array
* @returns {boolean} boolean indicating whether there are multiple function signatures in `headers`
*/
function hasMultipleSignatures( headers ) {
	var name;
	var arr;
	var i;

	arr = RE_ALIAS.exec( headers[ 0 ] );
	name = arr[ 1 ];
	for ( i = 1; i < headers.length; i++ ) {
		arr = RE_ALIAS.exec( headers[ i ] );
		if ( arr[ i ] === name ) {
			return true;
		}
	}
	return false;
}


// MAIN //

/**
* Creates the table of contents and associated link section for insertion into the README.md document.
*
* @private
* @param {Array} contents - array of file contents
* @param {Object} aliases - table mapping package names to aliases
* @param {StringArray} [blacklist] - array of blacklisted packages
* @returns {Object} object with `toc` and `links`
*/
function createTOC( contents, aliases, blacklist ) {
	var multiple;
	var descr;
	var links;
	var used;
	var pkgs;
	var arr;
	var fun;
	var pkg;
	var str;
	var toc;
	var val;
	var i;

	debug( 'Creating ToC...' );
	links = [];
	pkgs = [];
	used = [];
	toc = '<div class="namespace-toc">\n\n';
	for ( i = 0; i < contents.length; i++ ) {
		str = contents[ i ].data.toString();
		descr = RE_DESCR.exec( str )[ 1 ];
		descr = replace( descr, RE_LINKS, '$1' );
		descr = uncapitalizeDescription( descr );
		pkg = str.match( RE_PKG )[ 1 ];
		pkgs.push( pkg );
		debug( 'Processing package %s...', pkg );
		multiple = str.match( RE_FUN );
		if ( multiple && hasMultipleSignatures( multiple ) ) {
			fun = '()';
		} else {
			arr = RE_FUN_SIG.exec( str );
			if ( arr ) {
				fun = arr[ 1 ];
				fun = replace( fun, '\\[', '[' );
			} else {
				fun = '';
			}
		}
		if ( aliases[ pkg ] && isNotBlacklisted( pkg ) ) {
			used.push( pkg );
			toc += '-   <span class="signature">[`'+aliases[ pkg ]+fun+'`]['+pkg+']</span>';
			toc += '<span class="delimiter">: </span>';
			toc += '<span class="description">' + descr + '.</span>';
			toc += '\n';
			val = '['+pkg+']: https://github.com/stdlib-js/stdlib';
			if ( !contains( links, val ) ) {
				links.push( val );
			}
		}
	}
	toc += '\n';
	toc += '</div>';
	return {
		'toc': toc,
		'links': links,
		'packages': used
	};

	/**
	* Checks whether a package appears in the list of blacklisted package names.
	*
	* @private
	* @param {string} pkg - package name
	* @returns {boolean} boolean indicating whether a package is blacklisted
	*/
	function isNotBlacklisted( pkg ) {
		if ( !blacklist ) {
			return true;
		}
		if ( contains( blacklist, pkg ) ) {
			return false;
		}
		return true;
	}
}


// EXPORTS //

module.exports = createTOC;
