/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var join = require( 'path' ).join;
var logger = require( 'debug' );
var visit = require( 'unist-util-visit' );
var rootDir = require( '@stdlib/_tools/utils/root-dir' );
var pkg2related = require( '@stdlib/namespace/pkg2related' );
var uncapitalizeDescription = require( '@stdlib/_tools/utils/uncapitalize-pkg-description' );
var format = require( '@stdlib/string/format' );
var readJSON = require( '@stdlib/fs/read-json' ).sync;
var escapeMarkdown = require( './escape_markdown.js' );


// VARIABLES //

var root = rootDir();
var debug = logger( 'remark-stdlib-related:transformer' );
var RELATED_START = /<section class="related">/;
var RELATED_END = '<!-- /.related -->';
var RELATED_TEMPLATE = [
	'* * *',
	'',
	'## See Also',
	'',
	''
].join( '\n' );


// FUNCTIONS //

/**
* Removes all "See Also" links from the link section by modifying the root node in-place.
*
* @private
* @param {Node} tree - root node of the AST
* @returns {boolean} `true` if the link section included a <related-links> pseudo-section, `false` otherwise
*/
function removeLinks( tree ) {
	var children;
	var child;
	var found;
	var start;
	var end;
	var i;

	children = tree.children;
	for ( i = 0; i < children.length; i++ ) {
		child = children[ i ];
		if ( child.type === 'html' ) {
			if ( child.value === '<!-- <related-links> -->' ) {
				start = i;
				found = true;
			} else if ( child.value === '<!-- </related-links> -->' ) {
				end = i;
				break;
			}
		}
	}
	children.splice( start+1, end-start-1 );
	return found;
}

/**
* Collects existing link definitions into an object.
*
* @private
* @param {Node} node - reference node
* @returns {Object} object mapping link identifiers to `true`
*/
function collectExistingLinks( node ) {
	var existingLinks = {};
	visit( node, 'definition', onDefinition );
	return existingLinks;

	/**
	* Callback invoked upon encountering a link definition.
	*
	* @private
	* @param {Node} definition - reference node
	* @returns {void}
	*/
	function onDefinition( definition ) {
		var identifier = definition.identifier;
		existingLinks[ identifier ] = true;
	}
}


// MAIN //

/**
* Transforms a Markdown abstract syntax tree (AST).
*
* @private
* @param {Node} tree - root node of the AST
* @param {File} file - virtual file
*/
function transformer( tree, file ) {
	var existingLinks;
	var found;
	debug( 'Processing virtual file...' );

	found = removeLinks( tree );
	existingLinks = collectExistingLinks( tree );
	visit( tree, 'html', insertSeeAlso );

	/**
	* Inserts a "See Also" section into a Markdown AST.
	*
	* @private
	* @param {Node} node - reference node
	* @param {number} index - position of `node` in `parent`
	* @param {Node} parent - parent of `node`
	* @throws {Error} "See Also" section must have starting and ending tags
	* @returns {void}
	*/
	function insertSeeAlso( node, index, parent ) {
		var description;
		var newNodes;
		var content;
		var related;
		var newNode;
		var pkgName;
		var links;
		var child;
		var meta;
		var dir;
		var c;
		var i;

		if ( RELATED_START.test( node.value ) === true ) {
			debug( 'Found "See Also" section...' );
			pkgName = file.dirname.substring( file.dirname.lastIndexOf( '@stdlib' ) );
			related = pkg2related( pkgName );
			if ( !related || related.length === 0 ) {
				return;
			}
			links = [];
			content = RELATED_TEMPLATE;
			for ( i = 0; i < related.length; i++ ) {
				dir = join( root, 'lib', 'node_modules', related[ i ] );
				meta = readJSON( join( dir, 'package.json' ) );
				if ( meta instanceof Error ) {
					throw meta;
				}
				description = uncapitalizeDescription( meta.description );
				description = escapeMarkdown( description );
				content += '-   <span class="package-name">[`'+related[ i ]+'`]['+related[ i ]+']</span>';
				content += '<span class="delimiter">: </span>';
				content += '<span class="description">' + description + '</span>';
				content += '\n';
				if ( !existingLinks[ related[ i ] ] ) {
					links.push( '['+related[ i ]+']: https://github.com/stdlib-js/stdlib' );
				}
			}
			content += '\n';
			content += '</section>';
			newNode = {
				'type': 'html',
				'value': content
			};
			for ( i = index; i < parent.children.length; i++ ) {
				if ( parent.children[ i ].value === RELATED_END ) {
					parent.children.splice( index+1, i-index-1, newNode );
					break;
				}
			}
			if ( i === parent.children.length - 1 ) {
				throw new Error( format( 'invalid node. Ensure that the Markdown file includes both a starting `<section class="related">` and closing `</section>\n\n<!-- /.related -->`. Node: `%s`.', node.value ) );
			}
			if ( found ) {
				debug( 'Append links to links section...' );
				newNode = {
					'type': 'html',
					'value': links.join( '\n\n' )
				};
				for ( i = 0; i < parent.children.length; i++ ) {
					child = parent.children[ i ];
					if (
						child.type === 'html' &&
						child.value === '<!-- <related-links> -->'
					) {
						parent.children.splice( i+1, 0, newNode );
						break;
					}
				}
			} else {
				debug( 'Create <related-links> section...' );
				newNodes = [
					{
						'type': 'html',
						'value': '<!-- <related-links> -->'
					},
					{
						'type': 'html',
						'value': links.join( '\n\n' )
					},
					{
						'type': 'html',
						'value': '<!-- </related-links> -->'
					}
				];
				for ( i = 0; i < parent.children.length; i++ ) {
					child = parent.children[ i ];
					if (
						child.type === 'html' &&
						child.value === '<!-- /.links -->'
					) {
						c = parent.children;
						c.splice.apply( c, [ i-1, 0 ].concat( newNodes ) );
						found = true;
						break;
					}
				}
			}
		}
	}
}


// EXPORTS //

module.exports = transformer;
