/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var resolve = require( 'path' ).resolve;
var rule = require( 'unified-lint-rule' );
var visit = require( 'unist-util-visit' );
var awaitSync = require( '@kaciras/deasync' ).awaitSync;
var ESLint = require( 'eslint' ).ESLint;
var cwd = require( '@stdlib/process/cwd' );
var contains = require( '@stdlib/assert/contains' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isObject = require( '@stdlib/assert/is-plain-object' );
var format = require( '@stdlib/string/format' );
var transformHTML = require( './transform_html.js' );


// MAIN //

/**
* Returns a plugin for linting Markdown code blocks using ESLint.
*
* @param {Object} [options] - options
* @param {string} [options.config] - path to an ESLint configuration file
* @throws {TypeError} options argument must be an object
* @returns {Function} plugin
*
* @example
* var remark = require( 'remark' );
*
* var plugin = factory();
* var linter = remark().use( plugin ).processSync;
*
* var vfile = linter( '```javascript\nvar beep = \'boop\';\n```' );
*/
function factory( options ) {
	var eslint;
	var opts;

	opts = {};
	if ( arguments.length ) {
		if ( !isObject( options ) ) {
			throw new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );
		}
		if ( hasOwnProp( options, 'config' ) ) {
			opts.overrideConfigFile = resolve( cwd(), options.config );
		}
		opts.overrideConfig = {};
		if ( hasOwnProp( options, 'rules' ) ) {
			opts.overrideConfig.rules = options.rules;
		}
		if ( hasOwnProp( options, 'ignore' ) ) {
			opts.ignore = options.ignore;
		}
		if ( hasOwnProp( options, 'useEslintrc' ) ) {
			opts.useEslintrc = options.useEslintrc;
		}
		// TODO: add support for other ESLint options
	}
	eslint = new ESLint( opts );
	return rule( 'remark-lint:eslint', lint );

	/**
	* Lints Markdown code blocks using ESLint.
	*
	* @private
	* @param {Node} tree - abstract syntax tree (AST)
	* @param {File} file - file being linted
	* @param {Object} options - options
	* @param {Callback} clbk - callback
	*/
	function lint( tree, file ) {
		var FIRST;
		visit( tree, 'code', onNode );

		/**
		* Callback invoked upon encountering a code block.
		*
		* @private
		* @param {Node} node - AST node
		* @param {number} idx - position of node in parent
		* @param {Node} parent - parent AST node
		* @returns {void}
		*/
		function onNode( node, idx, parent ) {
			var comments;
			var comment;
			var offset;
			var prev;
			var code;

			if ( node.lang === 'javascript' || node.lang === 'js' ) {
				// Check for the first code block in the "Usage" section, as this, by convention, should contain a single `require` statement documenting how to import a package...
				if ( !FIRST ) {
					prev = parent.children[ idx-1 ];
					if (
						prev &&
						prev.type === 'heading' &&
						prev.children &&
						prev.children[ 0 ] &&
						prev.children[ 0 ].value === 'Usage'
					) {
						// Cache the node's value, as this will be prepended to subsequent code blocks and allow evaluation of code blocks for doctesting:
						FIRST = node.value;
					} else {
						// Keep visiting node's until the find the first code block containing the `require` statement:
						return;
					}
				}
				// Look for HTML comments immediately preceding a code block which may contain ESLint configuration...
				idx -= 1;
				prev = parent.children[ idx ];
				comments = [];
				while ( prev && prev.type === 'html' ) {
					comment = transformHTML( prev.value );
					if ( !comment ) {
						break;
					}
					if ( comment === '/* eslint-skip */' ) {
						return;
					}
					comments.unshift( comment );
					idx -= 1;
					prev = parent.children[ idx ];
				}
				offset = comments.length;

				// Prepend main require for subsequent code blocks:
				if ( !contains( node.value, FIRST ) ) {
					comments.push( '/* eslint-disable stdlib/require-order */' );
					comments.push( FIRST+'\n' );
				}
				comments.push( node.value );
				code = comments.join( '\n' );

				// Lint the code block...
				awaitSync( eslint.lintText( code ).then( onLint ) );
			}

			/**
			* Callback invoked upon linting a code block.
			*
			* @private
			* @param {ObjectArray} results - lint results
			*/
			function onLint( results ) {
				var result;
				var msg;
				var str;
				var i;
				var j;
				for ( i = 0; i < results.length; i++ ) {
					result = results[ i ];
					result.filePath = file.path || result.filePath;
					for ( j = 0; j < result.messages.length; j++ ) {
						msg = result.messages[ j ];
						str = '';
						str += (msg.line-offset) + ':' + msg.column;
						str += '   ';
						if ( msg.severity === 2 ) {
							str += 'error';
						} else {
							str += 'warning';
						}
						str += '   ';
						str += msg.message;
						str += '   ';
						str += msg.ruleId;
						file.message( str, node );
					}
				}
			}
		}
	}
}


// EXPORTS //

module.exports = factory;
