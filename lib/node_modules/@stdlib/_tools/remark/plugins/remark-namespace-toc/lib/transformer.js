/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var visit = require( 'unist-util-visit' );
var createTOC = require( '@stdlib/_tools/markdown/namespace-toc' );
var startsWith = require( '@stdlib/string/starts-with' );
var endsWith = require( '@stdlib/string/ends-with' );


// VARIABLES //

var debug = logger( 'remark-namespace-toc:transformer' );
var TOC_START = /<!-- <toc .*> -->/;
var TOC_END = '<!-- </toc> -->';
var KEYWORDS = /keywords="([^"]*)"/;
var PATTERN = /pattern="([^"]*)"/;
var IGNORE = /ignore="([^"]*)"/g;
var usedPackages = [];


// FUNCTIONS //

/**
* Removes all table of contents links from the link section by modifying the root node in-place.
*
* @private
* @param {Node} tree - root node of the AST
* @returns {boolean} `true` if the link section included a <toc-links> pseudo-section, `false` otherwise
*/
function removeLinks( tree ) {
	var children;
	var child;
	var found;
	var start;
	var end;
	var i;

	children = tree.children;
	for ( i = 0; i < children.length; i++ ) {
		child = children[ i ];
		if ( child.type === 'html' ) {
			if ( child.value === '<!-- <toc-links> -->' ) {
				start = i;
				found = true;
			} else if ( child.value === '<!-- </toc-links> -->' ) {
				end = i;
				break;
			}
		}
	}
	children.splice( start+1, end-start-1 );
	return found;
}


// MAIN //

/**
* Transforms a Markdown abstract syntax tree (AST).
*
* @private
* @param {Node} tree - root node of the AST
* @param {File} file - virtual file
*/
function transformer( tree, file ) {
	var found;
	debug( 'Processing virtual file...' );

	found = removeLinks( tree );
	visit( tree, 'html', insertTOC );

	/**
	* Inserts a table of contents list into a Markdown AST.
	*
	* @private
	* @param {Node} node - reference node
	* @param {number} index - position of `node` in `parent`
	* @param {Node} parent - parent of `node`
	* @throws {Error} table of contents comments must have starting and ending comments
	*/
	function insertTOC( node, index, parent ) {
		var keywords;
		var newNodes;
		var newNode;
		var pattern;
		var ignores;
		var ignore;
		var child;
		var match;
		var opts;
		var res;
		var c;
		var i;

		if ( TOC_START.test( node.value ) === true ) {
			debug( 'Found a table of contents...' );

			pattern = PATTERN.exec( node.value );
			if ( pattern ) {
				pattern = pattern[ 1 ];
			} else {
				pattern = '*';
			}
			debug( 'Pattern: %s', pattern );

			ignores = [];
			do {
				match = IGNORE.exec( node.value );
				if ( match ) {
					ignore = match[ 1 ];
					if ( !startsWith( ignore, '**/' ) ) {
						ignore = '**/'+ignore;
					}
					if ( !endsWith( ignore, '/**' ) ) {
						ignore += '/**';
					}
					ignores.push( ignore );
				}
			} while ( match );
			debug( 'Ignored packages: %s', ignores.join( ', ' ) );
			opts = {
				'pattern': pattern,
				'dir': file.dirname
			};
			if ( usedPackages.length > 0 ) {
				opts.blacklist = usedPackages;
			}
			if ( ignores.length > 0 ) {
				opts.ignore = ignores;
			}
			keywords = KEYWORDS.exec( node.value );
			if ( keywords ) {
				keywords = keywords[ 1 ];
				debug( 'Keywords: %s', keywords );
				opts.keywords = keywords;
			}
			res = createTOC.sync( opts );
			if ( res.packages && res.packages.length > 0 ) {
				usedPackages = usedPackages.concat( res.packages );
			}
			if ( res.links.length > 0 ) {
				newNode = {
					'type': 'html',
					'value': res.toc
				};
				debug( 'Index: %d', index );
				for ( i = index; i < parent.children.length; i++ ) {
					if ( parent.children[ i ].value === TOC_END ) {
						parent.children.splice( index+1, i-index-1, newNode );
						break;
					}
				}
				if ( i === parent.children.length - 1 ) {
					throw new Error( 'invalid node. Invalid table of contents (toc) comment. Ensure that the Markdown file includes both starting and ending `toc` comments. Node: `' + node.value + '`.' );
				}
				if ( found ) {
					debug( 'Append links to links section...' );
					newNode = {
						'type': 'html',
						'value': res.links.join( '\n\n' )
					};
					for ( i = 0; i < parent.children.length; i++ ) {
						child = parent.children[ i ];
						if (
							child.type === 'html' &&
							child.value === '<!-- <toc-links> -->'
						) {
							parent.children.splice( i+1, 0, newNode );
							break;
						}
					}
				} else {
					debug( 'Create <toc-links> section...' );
					newNodes = [
						{
							'type': 'html',
							'value': '<!-- <toc-links> -->'
						},
						{
							'type': 'html',
							'value': res.links.join( '\n\n' )
						},
						{
							'type': 'html',
							'value': '<!-- </toc-links> -->'
						}
					];
					for ( i = 0; i < parent.children.length; i++ ) {
						child = parent.children[ i ];
						if (
							child.type === 'html' &&
							child.value === '<!-- /.links -->'
						) {
							c = parent.children;
							c.splice.apply( c, [ i-1, 0 ].concat( newNodes ) );
							found = true;
							break;
						}
					}
				}
			}
		}
	}
}


// EXPORTS //

module.exports = transformer;
