#!/usr/bin/env node

/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-console */

'use strict';

// MODULES //

var join = require( 'path' ).join;
var tmpdir = require( 'os' ).tmpdir;
var argv = require( '@stdlib/process/argv' );
var createWorkflowDispatch = require( '@stdlib/_tools/github/dispatch-workflow' );
var readJSON = require( '@stdlib/fs/read-json' ).sync;
var contains = require( '@stdlib/assert/contains' );
var replace = require( '@stdlib/string/replace' );
var startsWith = require( '@stdlib/string/starts-with' );
var ENV = require( '@stdlib/process/env' );
var toposort = require( '@stdlib/_tools/pkgs/toposort' ).sync;


// VARIABLES //

var START_PKG_INDEX = 0;
var END_PKG_INDEX = 5000;


// FUNCTIONS //

/**
* Creates a workflow dispatch event in for the respective GitHub repository.
*
* @private
* @param {string} pkg - package name
* @param {Function} clbk - callback function
* @returns {void}
*/
function dispatch( pkg, clbk ) {
	var slug;
	var opts;

	slug = 'stdlib-js/'+replace( pkg, '/', '-' );
	opts = {
		'token': ENV.GITHUB_TOKEN
	};
	console.log( 'Creating workflow dispatch events for `'+slug+'`.' );
	createWorkflowDispatch( slug, 'test.yml', opts, onTest );

	/**
	* Callback invoked upon creating a test workflow dispatch event.
	*
	* @private
	* @param {(Error|null)} error - encountered error
	* @param {Object} info - rate limit info
	* @returns {void}
	*/
	function onTest( error, info ) {
		var currentTime;
		var waitTime;
		if ( error ) {
			console.error( error );
		}
		console.log( 'Rate limit information: '+JSON.stringify( info ) );

		if ( info.remaining <= 1 ) {
			currentTime = new Date().getTime();
			waitTime = new Date( info.reset * 1000 ).getTime() - currentTime;
			return setTimeout( clbk, waitTime );
		}
		return clbk();
	}
}


// MAIN //

/**
* Main execution sequence.
*
* @private
* @returns {void}
*/
function main() {
	var onlyToplevel;
	var fpath;
	var pkgs;
	var pkg;
	var tmp;
	var i;

	fpath = join( tmpdir(), 'stdlib_ordered_pkg_list.json' );
	pkgs = readJSON( fpath );
	if ( pkgs instanceof Error ) {
		console.log( 'Encountered an error: %s. Recreating ordered package list.', pkgs.message );
		pkgs = toposort({
			'ignore': [
				'**/_tools/**'
			]
		});
		if ( pkgs instanceof Error ) {
			throw pkgs;
		}
	}
	pkgs = pkgs.slice( START_PKG_INDEX, END_PKG_INDEX );
	for ( i = 0; i < pkgs.length; i++ ) {
		pkgs[ i ] = replace( pkgs[ i ], '@stdlib/', '' );
	}
	// Filter out unpublished packages:
	tmp = [];
	for ( i = 0; i < pkgs.length; i++ ) {
		if (
			!startsWith( pkgs[ i ], '_tools' ) &&
			!startsWith( pkgs[ i ], 'plot/' ) &&
			!startsWith( pkgs[ i ], 'strided/common' )
		) {
			tmp.push( pkgs[ i ] );
		}
	}
	pkgs = tmp;
	onlyToplevel = contains( argv, '--only-toplevel' );
	if ( onlyToplevel ) {
		tmp = [];
		for ( i = 0; i < pkgs.length; i++ ) {
			if ( !contains( pkgs[ i ], '/' ) ) {
				tmp.push( pkgs[ i ] );
			}
		}
		pkgs = tmp;
	}

	console.log( 'Triggering events for %d `stdlib` packages...', pkgs.length );
	pkg = pkgs.shift();

	dispatch( pkg, onCallback );

	/**
	* Callback invoked once workflow dispatch events have been created.
	*
	* @private
	*/
	function onCallback( ) {
		pkg = pkgs.shift();
		if ( pkg ) {
			console.log( 'Now processing the following package: %s', pkg );
			dispatch( pkg, onCallback );
		}
	}
}

main();
