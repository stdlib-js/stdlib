/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var proxyquire = require( 'proxyquire' );
var copy = require( '@stdlib/utils/copy' );
var defaults = require( './../lib/defaults.json' );
var request = require( './../lib/request.js' );


// FIXTURES //

var http = require( './fixtures/http.js' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof request, 'function', 'main export is a function' );
	t.end();
});

tape( 'if unable to query an endpoint, an error is returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = copy( defaults );
	opts.protocol = 'http:';

	mock = http( new Error( 'beep' ) );

	request = proxyquire( './../lib/request.js', {
		'http': mock
	});

	request( opts, clbk );

	function clbk( error ) {
		t.equal( typeof error, 'object', 'error is an object' );
		t.equal( error.status, 500, '500 status' );
		t.equal( error.message, 'Request error: beep', 'message contains error message' );
		t.end();
	}
});

tape( 'if an endpoint returns a status code other than 200, an error containing the status code, the HTTP response object, and the response body are returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = copy( defaults );
	opts.protocol = 'http:';

	mock = http( null, 404 );

	request = proxyquire( './../lib/request.js', {
		'http': mock
	});

	request( opts, clbk );

	function clbk( error, response, body ) {
		t.equal( error.status, 404, 'equal status codes' );
		t.equal( error.message, 'bad request', 'equal messages' );

		t.equal( typeof response, 'object', 'second argument is an object' );

		t.equal( typeof body, 'string', 'third argument is a string' );

		t.end();
	}
});

tape( 'if a query is successful, the response body is returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = copy( defaults );
	opts.protocol = 'http:';

	mock = http( null, 200 );

	request = proxyquire( './../lib/request.js', {
		'http': mock
	});

	request( opts, clbk );

	function clbk( error, response, body ) {
		if ( error ) {
			t.ok( false, error.message );
			t.end();
			return;
		}
		t.equal( typeof response, 'object', 'second argument is an object' );

		t.equal( typeof body, 'string', 'body is a string' );

		t.equal( body, 'beep', 'body equals beep' );

		t.end();
	}
});

tape( 'HTTPS is supported', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = copy( defaults );
	opts.protocol = 'https:';

	mock = http( null, 200 );

	request = proxyquire( './../lib/request.js', {
		'https': mock
	});

	request( opts, clbk );

	function clbk( error, response, body ) {
		if ( error ) {
			t.ok( false, error.message );
			t.end();
			return;
		}
		t.equal( typeof response, 'object', 'second argument is an object' );

		t.equal( typeof body, 'string', 'body is a string' );

		t.equal( body, 'beep', 'body equals beep' );

		t.end();
	}
});
