/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var getOptions = require( './options.js' );
var request = require( './request.js' );


// VARIABLES //

var debug = logger( 'github-fetch-file:resolve' );
var NUM_CONCURRENT_REQUESTS = 3; // NOTE: heuristic to avoid being flagged for abusive behavior. If 100ms avg response time, 3x10 = 30rps.


// MAIN //

/**
* Fetches a file from one or more repositories.
*
* @param {string} filepath - relative filepath of the file to fetch
* @param {StringArray} repos - array of repo slugs indicating the repositories from which to fetch a file
* @param {Object} opts - request options
* @param {Function} clbk - callback to invoke after query completion
* @returns {void}
*/
function resolve( filepath, repos, opts, clbk ) {
	var options;
	var scount;
	var fcount;
	var count;
	var eFLG;
	var out;
	var idx;
	var len;
	var i;

	// Output data store:
	out = {};
	out.meta = {};
	out.data = {};
	out.failures = {};

	// Number of completed requests:
	count = 0;
	scount = 0; // success
	fcount = 0; // failures

	// Request id:
	idx = 0;

	// Request options:
	options = getOptions( opts );

	len = repos.length;

	debug( 'Number of repositories: %d.', len );
	out.meta.total = len;

	debug( 'Beginning queries...' );
	for ( i = 0; i < NUM_CONCURRENT_REQUESTS; i++ ) {
		next();
	}
	/**
	* Requests a file from the next repository in the queue. Once requests for all desired repos have completed, invokes the provided callback.
	*
	* @private
	* @returns {void}
	*/
	function next() {
		var repo;
		if ( count === len ) {
			debug( 'Finished all queries.' );
			out.meta.success = scount;
			out.meta.failure = fcount;
			return clbk( null, out );
		}
		if ( idx < len ) {
			repo = repos[ idx ];
			debug( 'Querying repository `%s` (%d).', repo, idx );

			options.path = '/'+repo+'/'+opts.branch+'/'+filepath;
			debug( 'Path: %s', options.path );

			request( options, responseFactory( repo, idx ) );
			idx += 1;
		}
	}
	/**
	* Returns a response callback.
	*
	* @private
	* @param {string} repo - repository
	* @param {number} idx - request index
	* @returns {Function} response callback
	*/
	function responseFactory( repo, idx ) {
		return onResponse;
		/**
		* Callback invoked upon receiving a request response.
		*
		* @private
		* @param {(Error|null)} error - error object
		* @param {Object} response - HTTP response object
		* @param {string} body - response body
		* @returns {void}
		*/
		function onResponse( error, response, body ) {
			if ( eFLG ) {
				return;
			}
			debug( 'Response received for repository `%s` (%d).', repo, idx );
			if ( arguments.length === 1 ) {
				eFLG = true;
				debug( 'Encountered an application-level error for repository `%s` (%d): %s', repo, idx, error.message );
				return clbk( error );
			}
			if ( error ) {
				debug( 'Failed to resolve file for repository `%s` (%d): %s', repo, idx, error.message );
				out.failures[ repo ] = error.message;
				fcount += 1;
			} else {
				debug( 'Successfully resolved file for repository `%s` (%d).', repo, idx );
				out.data[ repo ] = body;
				scount += 1;
			}
			count += 1;
			debug( 'Request %d of %d complete.', count, len );
			next();
		}
	}
}


// EXPORTS //

module.exports = resolve;
