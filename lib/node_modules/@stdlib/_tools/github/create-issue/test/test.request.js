/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var proxyquire = require( 'proxyquire' );
var string2buffer = require( '@stdlib/buffer/from-string' );
var request = require( './../lib/request.js' );


// FIXTURES //

var getOpts = require( './fixtures/opts.js' );
var http = require( './fixtures/http.js' );
var data = require( './fixtures/results.json' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.equal( typeof request, 'function', 'main export is a function' );
	t.end();
});

tape( 'if unable to query an endpoint, an error is returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = getOpts();
	opts.protocol = 'http:';

	mock = http( new Error( 'beep' ) );

	request = proxyquire( './../lib/request.js', {
		'http': mock
	});

	request( opts, string2buffer( '{"body":"beep"}' ), clbk );

	function clbk( error ) {
		t.equal( typeof error, 'object', 'error is an object' );
		t.equal( error.status, 500, '500 status' );
		t.equal( error.message, 'Request error: beep', 'message contains error message' );
		t.end();
	}
});

tape( 'if an endpoint returns a status code other than 201, an error containing the status code, the HTTP response object, and the response body are returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = getOpts();
	opts.protocol = 'http:';

	mock = http( null, 404 );

	request = proxyquire( './../lib/request.js', {
		'http': mock
	});

	request( opts, string2buffer( '{"body":"beep"}' ), clbk );

	function clbk( error, response, body ) {
		t.equal( error.status, 404, 'equal status codes' );
		t.equal( error.message, 'bad request', 'equal messages' );
		t.equal( typeof response, 'object', 'second argument is an object' );
		t.equal( typeof body, 'string', 'third argument is a string' );
		t.end();
	}
});

tape( 'if an endpoint returns an invalid JSON response, an error with a status code of 502 (bad gateway; invalid response from upstream server), the HTTP response object, and the response body are returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = getOpts();
	opts.protocol = 'http:';

	mock = http( null, 201 );

	request = proxyquire( './../lib/request.js', {
		'http': mock,
		'@stdlib/utils/parse-json': parse
	});

	request( opts, string2buffer( '{"body":"beep"}' ), clbk );

	function parse() {
		return new Error( 'bad json' );
	}

	function clbk( error, response, body ) {
		t.equal( error.status, 502, 'equal status codes' );
		t.equal( typeof error.message, 'string', 'error message' );
		t.equal( typeof response, 'object', 'second argument is an object' );
		t.equal( typeof body, 'string', 'third argument is a string' );
		t.end();
	}
});

tape( 'if a query is successful, a JSON object is returned to a provided callback', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = getOpts();
	opts.protocol = 'http:';

	mock = http( null, 201 );

	request = proxyquire( './../lib/request.js', {
		'http': mock
	});

	request( opts, string2buffer( '{"body":"beep"}' ), clbk );

	function clbk( error, response, body ) {
		if ( error ) {
			t.fail( error.message );
		} else {
			t.equal( typeof response, 'object', 'second argument is an object' );
			t.equal( typeof body, 'object', 'returns an object' );
			t.deepEqual( body, data, 'returns expected value' );
		}
		t.end();
	}
});

tape( 'the function supports HTTPS', function test( t ) {
	var request;
	var mock;
	var opts;

	opts = getOpts();
	opts.protocol = 'https:';

	mock = http( null, 201 );

	request = proxyquire( './../lib/request.js', {
		'https': mock
	});

	request( opts, string2buffer( '{"body":"beep"}' ), clbk );

	function clbk( error, response, body ) {
		if ( error ) {
			t.fail( error.message );
		} else {
			t.equal( typeof response, 'object', 'second argument is an object' );
			t.equal( typeof body, 'object', 'returns an object' );
			t.deepEqual( body, data, 'returns expected value' );
		}
		t.end();
	}
});
