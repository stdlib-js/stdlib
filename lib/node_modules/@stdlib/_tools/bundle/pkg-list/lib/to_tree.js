'use strict';

// MODULES //

var logger = require( 'debug' );
var replace = require( '@stdlib/string/replace' );
var pkg2alias = require( './pkg_to_alias.js' );
var camelcase = require( './camelcase.js' );


// VARIABLES //

var debug = logger( 'bundle-pkg-list:to-tree-namespace' );
var RE_SCOPED = /(@.+?\/)/;


// MAIN //

/**
* Converts a list of packages to a (flattened) package tree.
*
* @private
* @param {StringArray} pkgs - list of packages (sorted lexicographically)
* @returns {ArrayArray} (flattened) package tree where the first element is the tree path and the second element is the package identifier
*
* @example
* var pkgs = [
*     '@stdlib/math/base/special/erf',
*     '@stdlib/math/base/special/erfc'
*     'tape'
* ];
*
* var out = toTree( pkgs );
* // e.g., returns [ [ 'math.base.special.erf', '@stdlib/math/base/special/erf' ], [ 'math.base.special.erf', '@stdib/math/base/special/erf' ], [ 'tape', 'tape' ] ]
*/
function toTree( pkgs ) {
	var alias;
	var out;
	var v;
	var i;
	var j;

	out = new Array( pkgs.length );
	for ( i = 0; i < pkgs.length; i++ ) {
		v = pkgs[ i ];

		debug( 'Converting package %s to an alias...', v );
		alias = pkg2alias( v, false );

		// Remove the scope portion from the package name (if it exists; e.g., `@stdlib/math/special/erf` => `math/special/erf`):
		v = replace( v, RE_SCOPED, '' );

		// Split a `/` separated path:
		v = v.split( '/' );

		// Convert each segment to camelcase (e.g., `foo/beep-boop/bar` => `[ 'foo', 'beepBoop', 'bar' ]`):
		for ( j = 0; j < v.length; j++ ) {
			v[ j ] = camelcase( v[ j ] );
		}
		// Replace the final segment with the resolved alias:
		v[ v.length-1 ] = alias;

		// Convert a `/` separated path to `.` separated (as in object property access; e.g., assuming a resolved alias, `math/special/riemann-zeta` => `math.special.zeta`):
		v = v.join( '.' );
		debug( 'Mapping package %s to alias %s.', pkgs[ i ], v );

		// Update the output array:
		out[ i ] = [ v, pkgs[ i ] ];
	}
	return out;
}


// EXPORTS //

module.exports = toTree;
