/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var indexOf = require( '@stdlib/utils/index-of' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var namespaces = require( './namespaces.js' );
var aliases = require( './aliases.js' );


// VARIABLES //

var debug = logger( 'bundle-pkg-list:tree-filter' );


// MAIN //

/**
* Filters a (unique) sorted list of packages by excluding those stdlib namespace packages with children in the list.
*
* ## Notes
*
* -   If namespace packages with listed children were allowed, we would end up trying to override namespace properties which are read-only. So, our stance is that, if you want a namespace, you should provide a namespace only. And if you only want certain children, then provide the children, but not the namespace. Providing both signals confusion.
* -   The one exception we allow is when a namespace has an alias in the global alias namespace, which indicates that a package is not a "traditional" namespace, possibly providing a function API to namespace packages (e.g., `@stdlib/datasets`).
*
* @private
* @param {StringArray} pkgs - list of packages (unique and sorted lexicographically)
* @returns {StringArray} filtered list
*
* @example
* var pkgs = [
*     '@stdlib/math/base',
*     '@stdlib/random/base',
*     '@stdlib/math/base/special/erf'
* ];
*
* var out = filter( pkgs );
* // returns [ '@stdlib/math/base', '@stdlib/random/base', '@stdlib/math/base/special/erf' ]
*/
function filter( pkgs ) {
	var out;
	var tmp;
	var N;
	var i;

	N = pkgs.length;
	out = [];
	for ( i = 0; i < N; i++ ) {
		// Only bother filtering known `stdlib` namespaces to avoid things like `beep/lib` and `beep/lib/foo` from being filtered...
		if (
			// If we are the last package, we can skip filtering as no other package comes after to compare to:
			i < N-1 &&

			// Check if the package is a known namespace:
			indexOf( namespaces, pkgs[ i ] ) !== -1 &&

			// The package is a known namespace, but make sure it is not aliased and thus a "non-traditional" namespace:
			!hasOwnProp( aliases, pkgs[ i ] )
		) {
			// Note that we use `length+1` in order to capture a trailing slash (if present).
			tmp = pkgs[ i+1 ].substring( 0, pkgs[i].length+1 );

			// Note that comparing with the ending slash is key; otherwise, `@stdlib/math/base/special/erf` would be considered a namespace when followed by `@stdlib/math/base/special/erfc`.
			if ( ( pkgs[i]+'/' ) === tmp ) {
				debug( 'Excluding %s.', pkgs[ i ] );
			} else {
				out.push( pkgs[ i ] );
			}
		} else {
			out.push( pkgs[ i ] );
		}
	}
	return out;
}


// EXPORTS //

module.exports = filter;
