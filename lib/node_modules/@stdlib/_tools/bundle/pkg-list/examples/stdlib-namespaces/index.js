'use strict';

var logger = require( 'debug' );
var join = require( 'path' ).join;
var writeFile = require( 'fs' ).writeFileSync;
var mkdirp = require( 'mkdirp' ).sync;
var collapse = require( 'bundle-collapser/plugin' );
var uglifyify = require( 'uglifyify' );
var uglify = require( 'uglify-es' );
var pkgNames = require( '@stdlib/_tools/pkgs/names' ).sync;
var instanceOf = require( '@stdlib/assert/instance-of' );
var bundle = require( './../../lib' );

var debug = logger( 'bundle-pkg-list:examples:stdlib-namespaces' );

function include( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) >= 0 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

function exclude( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) === -1 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

// Define package resolution options:
var fopts = {
	'pattern': '**/package.json',
	'ignore': [
		'**/_**/**'     // ignore "private" packages
	]
};

// Resolve packages:
var names = pkgNames( fopts );
if ( instanceOf( names, Error ) ) {
	throw names;
}

// Create an output build directory:
var dir = join( __dirname, 'build' );
mkdirp( dir );

// Define bundle options:
var uopts = {
	'global': true
};

var bopts = {
	'namespace': 'none',
	'transforms': [
		[ uglifyify, uopts ] // minify modules individually
	],
	'plugins': [
		collapse             // convert bundle paths to IDs
	]
};

// Define the list of bundles:
var bundles = [
	[ '@stdlib/array', 'array', true ],
	[ '@stdlib/assert', 'assert', true ],
	[ '@stdlib/bench', 'bench', true ],
	[ '@stdlib/buffer', 'buffer', true ],
	[ '@stdlib/complex', 'complex', true ],
	[ '@stdlib/crypto', 'crypto', true ],
	[ '@stdlib/datasets', 'datasets', false ],
	[ '@stdlib/error', 'error', true ],
	[ '@stdlib/fastmath', 'fastmath', true ],
	[ '@stdlib/fs', 'fs', true ],
	[ '@stdlib/math', 'math', true ],
	[ '@stdlib/ml', 'ml', true ],
	[ '@stdlib/namespace', 'namespace', true ],
	[ '@stdlib/ndarray', 'ndarray', true ],
	[ '@stdlib/net', 'net', true ],
	[ '@stdlib/nlp', 'nlp', true ],
	[ '@stdlib/number', 'number', true ],
	[ '@stdlib/plot', 'plot', true ],
	[ '@stdlib/regexp', 'regexp', true ],
	[ '@stdlib/repl', 'repl', true ],
	[ '@stdlib/streams', 'streams', true ],
	[ '@stdlib/string', 'string', true ],
	[ '@stdlib/time', 'time', true ],
	[ '@stdlib/tools', 'tools', true ],
	[ '@stdlib/utils', 'utils', true ]
];

// Generate bundles...
var pkgs;
var b;
var i;
for ( i = 0; i < bundles.length; i++ ) {
	b = bundles[ i ];
	debug( 'Bundle: %s', b[ 0 ] );

	bopts.exportName = b[ 0 ];
	pkgs = exclude( names, b[ 0 ] ); // packages to exclude
	debug( 'Number of packages to exclude: %d', pkgs.length );
	if ( pkgs.length ) {
		bopts.external = pkgs;
	} else {
		delete bopts.external;
	}
	pkgs = include( names, b[ 0 ] ); // packages to include
	debug( 'Number of packages to include: %d', pkgs.length );

	bundle( pkgs, bopts, clbk( b[ 1 ], b[ 2 ] ) );
}

function clbk( filename, bool ) {
	return onBundle;

	function onBundle( error, bundle ) {
		var fpath;
		if ( error ) {
			throw error;
		}
		debug( 'Finished creating bundle: %s', filename );

		if ( bool ) {
			debug( 'Minifying...' );
			bundle = uglify.minify( bundle.toString() );
			debug( 'Finished minifying bundle: %s', filename );
			debug( 'Minification errors: %s', ( bundle.error ) ? bundle.error : '(none)' );
			bundle = bundle.code;
		}
		debug( 'Writing bundle to file...' );
		fpath = join( dir, filename+'.min.js' );
		writeFile( fpath, bundle );
		debug( 'Finished writing bundle to file.' );
	}
}
