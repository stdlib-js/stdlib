/* eslint-disable stdlib/jsdoc-doctest */

/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var dirname = require( 'path' ).dirname;
var resolve = require( 'path' ).resolve;
var join = require( 'path' ).join;
var logger = require( 'debug' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var objectKeys = require( '@stdlib/utils/keys' );
var startsWith = require( '@stdlib/string/starts-with' );
var replace = require( '@stdlib/string/replace' );
var readJSON = require( '@stdlib/fs/read-json' ).sync;
var resolveParentPath = require( '@stdlib/fs/resolve-parent-path' ).sync;
var format = require( '@stdlib/string/format' );
var copy = require( '@stdlib/utils/copy' );
var pkgDeps = require( '@stdlib/_tools/modules/pkg-deps' ).sync;
var rootDir = require( '@stdlib/_tools/utils/root-dir' );
var validate = require( './validate.js' );
var DEFAULTS = require( './defaults.json' );


// VARIABLES //

var debug = logger( 'release-package-json' );
var OPTS = {
	'builtins': false,
	'walk': true
};
var PKG = readJSON( resolve( rootDir(), 'package.json' ) );


// FUNCTIONS //

/**
* Sorting function for dependencies.
*
* ## Notes
*
* -   External packages are placed before `@stdlib` packages
* -   Package names are sorted in alphabetical order
*
* @private
* @param {string} a - first package name
* @param {string} b - second package name
* @returns {integer} `1` to indicate `a` should be placed before `b`, `-1` if `b` should be placed before `a`, `0` otherwise
*/
function pkgNameSorter( a, b ) {
	if ( startsWith( a, '@stdlib' ) ) {
		if ( startsWith( b, '@stdlib' ) ) {
			return a.localeCompare( b );
		}
		return 1;
	}
	if ( startsWith( b, '@stdlib' ) ) {
		return -1;
	}
	return a.localeCompare( b );
}

/**
* Replaces backslashes in a `@sdtlib` package name with dashes.
*
* @private
* @param {string} pkg - package name
* @returns {string} updated package name
*/
function slashesToDashes( pkg ) {
	const namespace = '@stdlib/';
	return namespace + replace( pkg.substr( namespace.length ), '/', '-' );
}

/**
* Comparator function to sort values in ascending order.
*
* @private
* @param {number} a - first number
* @param {number} b - second number
* @returns {number} difference between `a` and `b`
*/
function ascending( a, b ) {
	return a - b;
}

/**
* Removes duplicate values from a numeric array.
*
* ## Notes
*
* -   The input array is mutated.
*
* @private
* @param {Array} arr - array to be deduped
* @param {boolean} sorted - boolean flag indicating if the input array is sorted
*/
function unique( arr, sorted ) {
	var len = arr.length;
	var val;
	var i;
	var j;

	if ( !len ) {
		return;
	}
	if ( !sorted ) {
		arr.sort( ascending );
	}
	// Loop through the array, only incrementing a pointer when successive values are different. When a succeeding value is different, move the pointer and set the next value. In the trivial case where all array elements are unique, we incur a slight penalty in resetting the element value for each unique value. In other cases, we simply move a unique value to a new position in the array. The end result is a sorted array with unique values.
	for ( i = 1, j = 0; i < len; i++ ) {
		val = arr[ i ];
		if ( arr[ j ] !== val ) {
			j += 1;
			arr[ j ] = val;
		}
	}
	// Truncate the array:
	arr.length = j+1;
}


// MAIN //

/**
* Prepares the `package.json` of a package for individual release.
*
* @param {string} pkgName - package name
* @param {Options} options - function options
* @param {Array} [options.devDependencies] - development dependencies to be added
* @throws {TypeError} first argument must be an object
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Object} updated `package.json` object
*
* @example
* var out = prepare( '@stdlib/plot/ctor' );
* // returns {...}
*/
function prepare( pkgName, options ) {
	var dependencies;
	var binPath;
	var mpath;
	var deps;
	var keys;
	var opts;
	var dir;
	var err;
	var pkg;
	var val;
	var i;
	var j;

	if ( !isString( pkgName ) ) {
		throw new TypeError( format( 'invalid argument. First argument must be a string. Value: `%s`.', pkgName ) );
	}
	opts = copy( DEFAULTS );
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	mpath = require.resolve( pkgName );
	pkg = resolveParentPath( 'package.json', {
		'dir': dirname( mpath )
	});
	dir = dirname( pkg );
	pkg = readJSON( pkg );

	// Replace forward slashes with dashes for package name to be valid for npm release:
	pkg.name = slashesToDashes( pkg.name );

	// Set package version to global version:
	pkg.version = PKG.version;

	keys = objectKeys( pkg.bin );
	dependencies = [];
	for ( i = 0; i < keys.length; i++ ) {
		binPath = join( dir, pkg.bin[ keys[ i ] ] );
		deps = pkgDeps( binPath, OPTS );
		for ( j = 0; j < deps.length; j++ ) {
			dependencies = dependencies.concat( deps[ j ].deps );
		}
	}
	deps = pkgDeps( mpath, OPTS );
	for ( i = 0; i < deps.length; i++ ) {
		dependencies = dependencies.concat( deps[ i ].deps );
	}
	unique( dependencies );

	// Sort the package names with external dependencies on top and `@stdlib` ones afterwards:
	dependencies.sort( pkgNameSorter );

	debug( 'Found '+dependencies.length+' unique dependencies to add: '+dependencies.join( ', ' ) );
	for ( i = 0; i < dependencies.length; i++ ) {
		val = dependencies[ i ];
		if ( startsWith( val, '@stdlib' ) ) {
			pkg.dependencies[ slashesToDashes( val ) ] = PKG.version;
		} else {
			pkg.dependencies[ val ] = PKG.dependencies[ val ];
		}
	}
	for ( i = 0; i < opts.devDependencies.length; i++ ) {
		val = opts.devDependencies[ i ];
		pkg.devDependencies[ val ] = PKG.devDependencies[ val ];
	}
	return pkg;
}


// EXPORTS //

module.exports = prepare;
