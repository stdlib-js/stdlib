/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var join = require( 'path' ).join;
var doctrine = require( 'doctrine' );
var parse = require( 'acorn' ).parse;
var licenseHeader = require( '@stdlib/_tools/licenses/header' );
var insertHeader = require( '@stdlib/_tools/licenses/insert-header' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var hasOwn = require( '@stdlib/assert/has-own-property' );
var contains = require( '@stdlib/assert/contains' );
var isObject = require( '@stdlib/assert/is-object' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var isBuffer = require( '@stdlib/assert/is-buffer' );
var startsWith = require( '@stdlib/string/starts-with' );
var replace = require( '@stdlib/string/replace' );
var format = require( '@stdlib/string/format' );
var currentYear = require( '@stdlib/time/current-year' );
var DESCRIPTIONS = require( './descriptions.json' );
var VALID_VALS = require( './valid_values.json' );
var VALUES = require( './values.json' );


// VARIABLES //

var RE_JSDOC = /@param {Options} [{0,1}options]{0,1}/;
var UNRECOGNIZED = readFile( join( __dirname, 'templates', 'unrecognized.txt' ) ).toString();
var VALID = readFile( join( __dirname, 'templates', 'valid.txt' ) ).toString();
var START = readFile( join( __dirname, 'templates', 'start.txt' ) ).toString();
var TEST = readFile( join( __dirname, 'templates', 'test.txt' ) ).toString();
var CURRENT_YEAR = currentYear();


// FUNCTIONS //

/**
* Returns an array of elements that are common to both input arrays.
*
* @private
* @param {Array} a - first array
* @param {Array} b - second array
* @returns {Array} intersection array
*/
function intersect( a, b ) {
	var out;
	var i;

	out = [];
	for ( i = 0; i < a.length; i++ ) {
		if ( contains( b, a[ i ] ) ) {
			out.push( a[ i ] );
		}
	}
	return out;
}

/**
* Returns the JSDoc comment containing the function options.
*
* @private
* @param {ObjectArray} comments - array of comment objects
* @returns {(string|null)} JSDoc options comment
*/
function extractOptionsJSDoc( comments ) {
	var comment;
	var i;
	for ( i = 0; i < comments.length; i++ ) {
		comment = comments[ i ];
		if ( comment.type === 'Block' && RE_JSDOC.test( comment.value ) ) {
			return comment.value;
		}
	}
	return null;
}

/**
* Creates a test for a parameter of a given type.
*
* @private
* @param {string} param - parameter name
* @param {string} type - parameter type
* @returns {string} generated test
*/
function createTest( param, type ) {
	var desc;
	var tmpl;
	var vals;

	tmpl = replace( TEST, '{{param}}', param );
	desc = DESCRIPTIONS[ type ] || '{{TODO:desc}}';
	tmpl = replace( tmpl, '{{desc}}', desc );

	vals = VALUES[ type ] || [ '// TODO: change elements' ];
	vals = vals.join( ',\n\t\t' );
	tmpl = replace( tmpl, '{{values}}', vals );
	return tmpl;
}

/**
* Creates a test for a parameter of a union type.
*
* @private
* @param {string} param - parameter name
* @param {ObjectArray} elements - union elements
* @returns {string} generated test
*/
function createUnionTest( param, elements ) {
	var vals;
	var desc;
	var tmpl;
	var type;
	var i;

	desc = '';
	for ( i = 0; i < elements.length; i++ ) {
		if ( i > 0 ) {
			desc += ' or ';
		}
		type = elements[ i ].name;
		desc += DESCRIPTIONS[ type ] || '{{TODO:desc}}';
		if ( vals ) {
			vals = intersect( vals, VALUES[ type ] );
		} else {
			vals = VALUES[ type ];
		}
	}
	vals = vals.join( ',\n\t\t' );

	tmpl = replace( TEST, '{{param}}', param );
	tmpl = replace( tmpl, '{{desc}}', desc );
	tmpl = replace( tmpl, '{{values}}', vals );
	return tmpl;
}


// MAIN //

/**
* Returns contents of a `test.validate.js` file.
*
* @param {(string|Buffer)} src - source code
* @returns {string} validate.js tests
*
* @example
* var create = require( '@stdlib/_tools/scaffold/test-validate-js' );
*
* var code = [
*     '/**',
*     '* Validates function options.',
*     '*',
*     '* @private',
*     '* @param {Object} opts - destination object',
*     '* @param {Options} options - function options',
*     '* @param {string} [options.sep] - separator',
*     '* @returns {(Error|null)} null or an error object',
*     '*\/'
* ];
* code = code.join( '\n' );
*
* var tests = create( code );
*/
function create( src ) {
	var validVals;
	var comments;
	var jsdoc;
	var param;
	var opts;
	var tags;
	var type;
	var ast;
	var out;
	var tag;
	var h;
	var i;

	if ( isBuffer( src ) ) {
		src = src.toString();
	}
	else if ( !isString( src ) ) {
		throw new TypeError( format( 'invalid argument. Must provide either a string or Buffer. Value: `%s`.', src ) );
	}
	comments = [];
	parse( src, {
		'ecmaVersion': 'latest',
		'onComment': comments
	});
	jsdoc = extractOptionsJSDoc( comments );
	if ( !isString( jsdoc ) ) {
		throw new Error( 'invalid argument. Source code does not contain JSDoc comment with function options.' );
	}
	ast = doctrine.parse( jsdoc, {
		'sloppy': true,
		'unwrap': true
	});
	tags = ast.tags;
	out = START;
	validVals = [];
	for ( i = 0; i < tags.length; i++ ) {
		tag = tags[ i ];
		if (
			isObject( tag.type ) &&
			tag.type.type === 'OptionalType' &&
			startsWith( tag.name, 'options.' )
		) {
			param = replace( tag.name, 'options.', '' );
			out += '\n';
			if ( tag.type.expression.type === 'NameExpression' ) {
				type = tag.type.expression.name;
				if ( hasOwn( VALID_VALS, type ) ) {
					validVals.push( '\''+param+'\': '+VALID_VALS[ type ] );
				}
				out += createTest( param, type );
			}
			else if ( tag.type.expression.type === 'UnionType' ) {
				out += createUnionTest( param, tag.type.expression.elements );
			}
		}
	}
	out += '\n';
	out += replace( VALID, '{{valid}}', validVals.join( ',\n\t\t' ) );
	out += '\n';
	out += UNRECOGNIZED;

	// Generate a license header:
	opts = {
		'year': CURRENT_YEAR,
		'copyright': 'The Stdlib Authors'
	};
	h = licenseHeader( 'Apache-2.0', 'js', opts );

	// Insert the header:
	out = insertHeader( out, h );
	return out;
}


// EXPORTS //

module.exports = create;
