#!/usr/bin/env bash
#
# @license Apache-2.0
#
# Copyright (c) 2021 The Stdlib Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# shellcheck disable=SC2181

# Script for creating one or more packages which each expose an interface which applies a unary mathematical function to a strided array according to a callback function.
#
# Usage: runner.h
#

# USER-DEFINED VARIABLES #

# Define the destination package parent directory path:
pkg_path="@stdlib/math/strided/special"

# Define a list of "base" aliases (i.e., without any prefixes):
alias=(
	'besselj0'
	'besselj1'
	'bessely0'
	'bessely1'
	'binet'
)

# Define a list of brief descriptions:
desc=(
	'Bessel function of the first kind of order zero'
	'Bessel function of the first kind of order one'
	'Bessel function of the second kind of order zero'
	'Bessel function of the second kind of order one'
	"Binet's formula extended to real numbers"
)

# Define a list of package descriptions:
pkg_desc_suffix='each element retrieved from an input strided array via a callback function.'
pkg_desc=(
	"Compute the ${desc[0]} for ${pkg_desc_suffix}"
	"Compute the ${desc[1]} for ${pkg_desc_suffix}"
	"Compute the ${desc[2]} for ${pkg_desc_suffix}"
	"Compute the ${desc[3]} for ${pkg_desc_suffix}"
	"Evaluate ${desc[4]} for ${pkg_desc_suffix}"
)

# Define a list of module descriptions:
# shellcheck disable=SC2016
module_desc_suffix='each element retrieved from an input strided array `x` via a callback function and assign each result to an element in an output strided array `y`.'
module_desc=(
	"Compute the ${desc[0]} for ${module_desc_suffix}"
	"Compute the ${desc[1]} for ${module_desc_suffix}"
	"Compute the ${desc[2]} for ${module_desc_suffix}"
	"Compute the ${desc[3]} for ${module_desc_suffix}"
	"Evaluate ${desc[4]} for ${module_desc_suffix}"
)

# Define a list of main export descriptions:
# shellcheck disable=SC2016
main_desc_suffix='each element retrieved from an input strided array `x` via a callback function and assigns each result to an element in an output strided array `y`.'
main_desc=(
	"Computes the ${desc[0]} for ${main_desc_suffix}"
	"Computes the ${desc[1]} for ${main_desc_suffix}"
	"Computes the ${desc[2]} for ${main_desc_suffix}"
	"Computes the ${desc[3]} for ${main_desc_suffix}"
	"Evaluates ${desc[4]} for ${main_desc_suffix}"
)

# Define a list of test descriptions:
test_desc_suffix='via a callback function'
test_desc=(
	"computes the ${desc[0]} ${test_desc_suffix}"
	"computes the ${desc[1]} ${test_desc_suffix}"
	"computes the ${desc[2]} ${test_desc_suffix}"
	"computes the ${desc[3]} ${test_desc_suffix}"
	"evaluates ${desc[4]} ${test_desc_suffix}"
)

# Define a list of description text (found in a package README) which should be a link to a corresponding unary package (NOTE: to not include a link, set to an empty string):
desc_link_text=(
	"${desc[0]}"
	"${desc[1]}"
	"${desc[2]}"
	"${desc[3]}"
	"${desc[4]}"
)

# Define a list of keywords for each package (package keywords should be comma-separated values):
keywords=(
	'stdmath,mathematics,math,special,bessel,j0'
	'stdmath,mathematics,math,special,bessel,j1'
	'stdmath,mathematics,math,special,bessel,y0'
	'stdmath,mathematics,math,special,bessel,y1'
	'stdmath,mathematics,math,special,binet,fibonacci,fib,fibo,reals'
)

# Define a list of minimum values for generated values when benchmarking and testing each package:
rand_min=(
	'0.0'
	'0.0'
	'0.0'
	'0.0'
	'-10.0'
)

# Define a list of maximum values for generated values when benchmarking and testing each package:
rand_max=(
	'10.0'
	'10.0'
	'10.0'
	'10.0'
	'10.0'
)

# Define a list of input array values for each package (input array values should be comma-separated values):
x_values_len_8=(
	'0.0,1.0,0.1,0.25,0.5,0.67,0.75,0.99'
	'0.0,1.0,0.1,0.25,0.5,0.67,0.75,0.99'
	'0.0,1.0,0.1,0.25,0.5,0.67,0.75,0.99'
	'0.0,1.0,0.1,0.25,0.5,0.67,0.75,0.99'
	'0.0,1.0,2.0,3.0,-1.0,3.14,-2.0,-3.0'
)


# COMPUTED VARIABLES #

# Determine the directory of this script:
dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"

# Define the path to the scaffolding script:
scaffold="${dir}/scaffold.sh"

# Determine the root project directory:
root_dir="$(git rev-parse --show-toplevel)"

# Define the project source code directory:
base_dir="${root_dir}/lib/node_modules"


# FUNCTIONS #

# Converts from camel case to a underscored delineated string.
#
# $1 - string to convert
camelcase_to_snakecase() {
	echo "$1" | sed 's/\([^A-Z]\)\([A-Z]\)/\1_\2/g' | sed 's/\([A-Z]\)\([A-Z]\)\([^A-Z]\)/\1_\2\3/g' | tr '[:upper:]' '[:lower:]'
}

# Runs package tasks (e.g., compilation, tests, examples, benchmarks, etc).
#
# $1 - package
pkg_tasks() {
	echo '' >&2
	echo 'Running tests...' >&2
	cd "${root_dir}" && make test TESTS_FILTER=".*/$1/.*" > /dev/null >&2
	if [[ "$?" -ne 0 ]]; then
		echo '' >&2
		echo 'ERROR: encountered an error when running tests.' >&2
		return 1
	fi
	echo 'Successfully ran tests.' >&2
	echo '' >&2
	echo 'Running examples...' >&2
	cd "${root_dir}" && make examples EXAMPLES_FILTER=".*/$1/.*" > /dev/null >&2
	if [[ "$?" -ne 0 ]]; then
		echo '' >&2
		echo 'ERROR: encountered an error when running examples.' >&2
		return 1
	fi
	echo 'Successfully ran examples.' >&2
	echo '' >&2
	echo 'Running benchmarks...' >&2
	cd "${root_dir}" && make benchmark BENCHMARKS_FILTER=".*/$1/.*" > /dev/null >&2
	if [[ "$?" -ne 0 ]]; then
		echo '' >&2
		echo 'ERROR: encountered an error when running benchmarks.' >&2
		return 1
	fi
	echo 'Successfully ran benchmarks.' >&2
	echo '' >&2
	return 0
}


# MAIN #

# Main execution sequence.
main() {
	echo '' >&2
	echo 'Generating packages...' >&2
	echo '' >&2
	for i in "${!alias[@]}"; do
		echo '' >&2
		echo 'Generating package...' >&2
		echo '' >&2
		tmp_alias="${alias[${i}]}By" >&2
		echo "  alias: ${tmp_alias}" >&2
		alias_snakecase=$(camelcase_to_snakecase "${tmp_alias}")
		pkg="${pkg_path}/${alias_snakecase//_/-}"
		echo "  pkg: ${pkg}" >&2
		echo '' >&2
		echo 'Creating package files...' >&2
		ALIAS="${tmp_alias}" PKG_DESC="${pkg_desc[${i}]}" MODULE_DESC="${module_desc[${i}]}" MAIN_DESC="${main_desc[${i}]}" TEST_DESC="${test_desc[${i}]}" DESC_LINK_TEXT="${desc_link_text[${i}]}" KEYWORDS="${keywords[${i}]}" RAND_MIN="${rand_min[${i}]}" RAND_MAX="${rand_max[${i}]}" X_VALUES_LEN_8="${x_values_len_8[${i}]}" "${scaffold}"
		if [[ "$?" -ne 0 ]]; then
			echo '' >&2
			echo 'ERROR: encountered an error when attempting to create package files.' >&2
			echo '' >&2
			exit 1
		fi
		echo 'Successfully created package files.' >&2
		echo '' >&2
		echo 'Running package tasks...' >&2
		pkg_tasks "${pkg}"
		if [[ "$?" -ne 0 ]]; then
			echo '' >&2
			exit 1
		fi
		echo 'Successfully completed package tasks.' >&2
		echo '' >&2
		echo 'Staging changes...' >&2
		git add "${base_dir}/${pkg}" > /dev/null >&2
		if [[ "$?" -ne 0 ]]; then
			sleep 1m
			git add "${base_dir}/${pkg}" > /dev/null >&2
			if [[ "$?" -ne 0 ]]; then
				echo '' >&2
				echo 'ERROR: encountered an error when attempting to stage package files.' >&2
				echo '' >&2
				exit 1
			fi
		fi
		echo 'Successfully staged changes.' >&2
		echo '' >&2
		echo 'Committing changes...' >&2
		git commit -m "Add strided interface which ${test_desc[${i}]}" > /dev/null >&2
		if [[ "$?" -ne 0 ]]; then
			sleep 1m
			git commit -m "Add strided interface which ${test_desc[${i}]}" > /dev/null >&2
			if [[ "$?" -ne 0 ]]; then
				echo '' >&2
				echo 'ERROR: encountered an error when attempting to commit changes.' >&2
				echo '' >&2
				exit 1
			fi
		fi
		echo 'Successfully committed changes.' >&2
		echo '' >&2
		echo 'Finished generating package.' >&2
		echo '' >&2
	done
	echo 'Successfully generated all packages.' >&2
	echo '' >&2
	exit 0
}

# Run main:
main
