/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var join = require( 'path' ).join;
var doctrine = require( 'doctrine' );
var parse = require( 'acorn' ).parse;
var licenseHeader = require( '@stdlib/_tools/licenses/header' );
var insertHeader = require( '@stdlib/_tools/licenses/insert-header' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var contains = require( '@stdlib/assert/contains' );
var isObject = require( '@stdlib/assert/is-object' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var isBuffer = require( '@stdlib/assert/is-buffer' );
var startsWith = require( '@stdlib/string/starts-with' );
var capitalize = require( '@stdlib/string/capitalize' );
var replace = require( '@stdlib/string/replace' );
var format = require( '@stdlib/string/format' );
var rtrim = require( '@stdlib/string/right-trim' );
var currentYear = require( '@stdlib/time/current-year' );
var DESCRIPTIONS = require( './descriptions.json' );
var VALID_VALS = require( './valid_values.json' );
var REQUIRES = require( './requires.json' );


// VARIABLES //

var RE_JSDOC = /@param {Options} [{0,1}options]{0,1}/;
var VALIDATE = readFile( join( __dirname, 'templates', 'validate.txt' ) ).toString();
var WILDCARD = readFile( join( __dirname, 'templates', 'wildcard.txt' ) ).toString();
var CHECK = readFile( join( __dirname, 'templates', 'check.txt' ) ).toString();
var CURRENT_YEAR = currentYear();


// FUNCTIONS //

/**
* Returns the JSDoc comment containing the function options.
*
* @private
* @param {ObjectArray} comments - array of comment objects
* @returns {(string|null)} JSDoc options comment
*/
function extractOptionsJSDoc( comments ) {
	var comment;
	var i;
	for ( i = 0; i < comments.length; i++ ) {
		comment = comments[ i ];
		if ( comment.type === 'Block' && RE_JSDOC.test( comment.value ) ) {
			return comment.value;
		}
	}
	return null;
}

/**
* Adds a require statement if not already present.
*
* @private
* @param {StringArray} requires - array of require statements
* @param {string} type - parameter type
*/
function addRequire( requires, type ) {
	var stmt = 'var is'+capitalize( type )+' = '+REQUIRES[ type ];
	if ( !contains( requires, stmt ) ) {
		requires.push( stmt );
	}
}

/**
* Creates a test for a parameter of a given type.
*
* @private
* @param {string} param - parameter name
* @param {Object} tag - JSDoc tag
* @param {StringArray} requires - array of require statements
* @param {StringArray} jsdocs - array of JSDoc annotations
* @param {StringArray} exampleOpts - array of options in example code
* @returns {string} generated test
*/
function createTest( param, tag, requires, jsdocs, exampleOpts ) {
	var desc;
	var type;
	var tmpl;

	type = tag.type.expression.name;
	addRequire( requires, type );
	jsdocs.push( '* @param {'+type+'} [' + tag.name + '] - '+ tag.description );
	exampleOpts.push( '\''+param+'\': '+VALID_VALS[ type ] );
	desc = DESCRIPTIONS[ type ] || '{{TODO:desc}}';
	tmpl = CHECK;
	tmpl = replace( tmpl, '{{param}}', param );
	tmpl = replace( tmpl, '{{asserts}}', '!is'+capitalize( type )+'( opts.'+param+' )' );
	tmpl = replace( tmpl, '{{desc}}', desc );
	return tmpl;
}

/**
* Creates a test for a parameter of a union type.
*
* @private
* @param {string} param - parameter name
* @param {Object} tag - JSDoc tag
* @param {StringArray} requires - array of require statements
* @param {StringArray} jsdocs - array of JSDoc annotations
* @returns {string} generated test
*/
function createUnionTest( param, tag, requires, jsdocs ) {
	var elements;
	var asserts;
	var jsdoc;
	var desc;
	var tmpl;
	var type;
	var i;

	elements = tag.type.expression.elements;
	desc = '';
	asserts = '';
	jsdoc = '* @param {(';
	for ( i = 0; i < elements.length; i++ ) {
		if ( i > 0 ) {
			desc += ' or ';
			asserts += ' || ';
			jsdoc += '|';
		}
		type = elements[ i ].name;
		jsdoc += type;
		addRequire( requires, type );
		desc += DESCRIPTIONS[ type ] || '{{TODO:desc}}';
		asserts += '!is'+capitalize( type )+'( opts.'+param+' )';
	}
	jsdoc += ')} [' + tag.name + '] - '+ tag.description;
	jsdocs.push( jsdoc );
	tmpl = replace( CHECK, '{{param}}', param );
	tmpl = replace( tmpl, '{{asserts}}', asserts );
	tmpl = replace( tmpl, '{{desc}}', desc );
	return tmpl;
}


// MAIN //

/**
* Returns contents of a `validate.js` file.
*
* @param {(string|Buffer)} src - source code
* @throws {TypeError} must provide a string or Buffer
* @throws {Error} source code must contain a JSDoc comment with options
* @returns {string} validate.js contents
*
* @example
* var create = require( '@stdlib/_tools/scaffold/validate-js' );
*
* var code = [
*     '/**',
*     '* Sets a nested property value.',
*     '*',
*     '* @param {ObjectLike} obj - input object',
*     '* @param {(string|Array)} path - key path',
*     '* @param {*} value - value to set',
*     '* @param {Options} [options] - function options',
*     '* @param {boolean} [options.create=false] - boolean indicating whether to * create a path if the key path does not already exist',
*     '* @param {string} [options.sep=\'.\'] - key path separator',
*     '* @returns {boolean} boolean indicating if the property was successfully set',
*     '*\/'
* ];
* code = code.join( '\n' );
*
* var validate = create( code );
*/
function create( src ) {
	var exampleOpts;
	var comments;
	var requires;
	var comment;
	var jsdocs;
	var param;
	var tests;
	var opts;
	var tags;
	var test;
	var ast;
	var out;
	var tag;
	var h;
	var i;

	if ( isBuffer( src ) ) {
		src = src.toString();
	}
	else if ( !isString( src ) ) {
		throw new TypeError( format( 'invalid argument. Must provide either a string or Buffer. Value: `%s`.', src ) );
	}
	comments = [];
	parse( src, {
		'ecmaVersion': 'latest',
		'onComment': comments
	});
	comment = extractOptionsJSDoc( comments );
	if ( !isString( comment ) ) {
		throw new Error( 'invalid argument. Source code does not contain JSDoc comment with function options.' );
	}
	ast = doctrine.parse( comment, {
		'sloppy': true,
		'unwrap': true
	});
	tags = ast.tags;
	requires = [];
	jsdocs = [];
	tests = [];
	exampleOpts = [];
	out = VALIDATE;
	for ( i = 0; i < tags.length; i++ ) {
		tag = tags[ i ];
		if (
			isObject( tag.type ) &&
			tag.type.type === 'OptionalType' &&
			startsWith( tag.name, 'options.' )
		) {
			param = replace( tag.name, 'options.', '' );
			if ( tag.type.expression.type === 'NameExpression' ) {
				test = createTest( param, tag, requires, jsdocs, exampleOpts );
			}
			else if ( tag.type.expression.type === 'AllLiteral' ) {
				jsdocs.push( '* @param {*} [' + tag.name + '] - '+ tag.description );
				test = WILDCARD;
				test = replace( test, '{{param}}', param );
			}
			else if ( tag.type.expression.type === 'UnionType' ) {
				test = createUnionTest( param, tag, requires, jsdocs );
			}
			test = rtrim( test );
			tests.push( test );
		}
	}
	out = replace( out, '{{requires}}', requires.join( '\n' ) );
	out = replace( out, '{{exampleOpts}}', exampleOpts.join( ',\n*     ' ) );
	out = replace( out, '{{jsdocs}}', jsdocs.join( '\n' ) );
	out = replace( out, '{{tests}}', tests.join( '\n' ) );

	// Generate a license header:
	opts = {
		'year': CURRENT_YEAR,
		'copyright': 'The Stdlib Authors'
	};
	h = licenseHeader( 'Apache-2.0', 'js', opts );

	// Insert the header:
	out = insertHeader( out, h );
	return out;
}


// EXPORTS //

module.exports = create;
