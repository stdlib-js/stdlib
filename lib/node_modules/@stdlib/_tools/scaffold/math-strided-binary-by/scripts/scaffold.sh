#!/usr/bin/env bash
#
# @license Apache-2.0
#
# Copyright (c) 2022 The Stdlib Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Script for scaffolding a package exposing an interface which applies a binary mathematical function to a strided array according to a callback function.
#
# Usage: scaffold.h
#
# Environment Variables:
#
#   ALIAS                    Main export alias.
#   NAMESPACE                Package namespace.
#   PKG_DESC                 Package description.
#   MODULE_DESC              Module description.
#   MAIN_DESC                Main export description.
#   TEST_DESC                Test description.
#   DESC_LINK_TEXT           README link text.
#   KEYWORDS                 List of keywords.
#   RAND_MIN                 Minimum value for generated values.
#   RAND_MAX                 Maximum value for generated values.
#   X_VALUES_LEN_8           List of values for first input array.
#   Y_VALUES_LEN_8           List of values for second input array.
#   TS_CALLBACK_RET_1_DTYPE  First callback return value data type.
#   TS_CALLBACK_RET_2_DTYPE  Second callback return value data type.
#

## USER-DEFINED VARIABLES ##

# Define the main export alias:
alias=${ALIAS:-'addBy'}

# Define the package namespace:
namespace=${NAMESPACE:-'math/strided/ops'}

# Define the package description:
# shellcheck disable=SC2016
pkg_desc=${PKG_DESC:-'Element-wise addition of two strided arrays via a callback function.'}

# Define the module description:
# shellcheck disable=SC2016
module_desc=${MODULE_DESC:-'Perform element-wise addition of two strided arrays via a callback function and assign each result to an element in an output strided array.'}

# Define main export description:
# shellcheck disable=SC2016
main_desc=${MAIN_DESC:-'Performs element-wise addition of two strided arrays via a callback function and assigns each result to an element in an output strided array.'}

# Define the test description:
# shellcheck disable=SC2016
test_desc=${TEST_DESC:-'performs element-wise addition via a callback function'}

# Define description text (found in the README) which should be a link to the binary package (NOTE: to not include a link, set to an empty string):
desc_link_text=${DESC_LINK_TEXT:-'addition'}

# Define a list of keywords:
if [[ -z "${KEYWORDS:-}" ]]; then
keywords=(
    "stdmath"
    "mathematics"
    "math"
    "add"
    "sum"
    "addition"
    "arithmetic"
    "summation"
)
else
	IFS=','; read -ra keywords <<< "${KEYWORDS}"; IFS=' ';
fi

# Define the minimum value of generated values when benchmarking and testing the implementation:
rand_min=${RAND_MIN:-'-10.0'}

# Define the maximum value of generated values when benchmarking and testing the implementation:
rand_max=${RAND_MAX:-'10.0'}

# Define a list of values for first input array:
if [[ -z "${X_VALUES_LEN_8:-}" ]]; then
x_values_len_8=(
    '1.0'
    '2.0'
    '3.0'
    '4.0'
    '5.0'
    '6.0'
    '7.0'
    '8.0'
)
else
	IFS=','; read -ra x_values_len_8 <<< "${X_VALUES_LEN_8}"; IFS=' ';
fi

# Define a list of values for second input array:
if [[ -z "${Y_VALUES_LEN_8:-}" ]]; then
y_values_len_8=(
    '11.0'
    '12.0'
    '13.0'
    '14.0'
    '15.0'
    '16.0'
    '17.0'
    '18.0'
)
else
	IFS=','; read -ra y_values_len_8 <<< "${Y_VALUES_LEN_8}"; IFS=' ';
fi

# Define callback return data types:
ts_callback_ret_1_dtype=${TS_CALLBACK_RET_1_DTYPE:-'number'}
ts_callback_ret_2_dtype=${TS_CALLBACK_RET_2_DTYPE:-'number'}


## COMPUTED VARIABLES ##

# Converts from camel case to a underscored delineated string.
#
# $1 - string to convert
camelcase_to_snakecase() {
	echo "$1" | sed 's/\([^A-Z]\)\([A-Z]\)/\1_\2/g' | sed 's/\([A-Z]\)\([A-Z]\)\([^A-Z]\)/\1_\2\3/g' | tr '[:upper:]' '[:lower:]'
}

# Convert the alias to snakecase:
alias_snakecase=$(camelcase_to_snakecase "${alias}")

# Define the destination package alias:
pkg_alias="${alias_snakecase//_/-}"

# Define the destination package parent directory path:
pkg_path="stdlib/${namespace}"

# Define the full destination package name:
pkg="${pkg_path}/${pkg_alias}"

# Determine the root project directory:
root_dir="$(git rev-parse --show-toplevel)"

# Define the project source code directory:
base_dir="${root_dir}/lib/node_modules"

# Define the destination path:
dest_dir="${base_dir}/@${pkg}"

# Define the location of this scaffold:
this_dir="${base_dir}/@stdlib/_tools/scaffold/math-strided-binary-by"

# Define the location of a utility for wrapping REPL text descriptions:
wrap="${base_dir}/@stdlib/_tools/repl-txt/wrap-desc/bin/cli"

# Define the binary function alias:
binary_alias="${alias:0:${#alias}-2}"

# Convert the binary function alias to snakecase:
binary_alias_snakecase=$(camelcase_to_snakecase "${binary_alias}")

# Define the binary package "alias":
binary_pkg_alias="${binary_alias_snakecase//_/-}"

# Define the binary package parent directory path:
binary_pkg_path="stdlib/math/base/ops"

# Define the package containing the binary function to apply:
binary_pkg="${binary_pkg_path}/${binary_pkg_alias}"

# Define the ndarray method description:
# shellcheck disable=SC2001
ndarray_desc=$(echo "${main_desc}" | sed 's/\.$//')
ndarray_desc="${ndarray_desc} using alternative indexing semantics."

# Define the REPL text main export description (note: 4 space indent and wrap at 80 characters):
repl_text_main_desc=$(echo -n "${main_desc}" | "${wrap}")
repl_text_main_desc="${repl_text_main_desc/    /}"

# Define the REPL text ndarray method description (note: 4 space indent and wrap at 80 characters):
repl_text_ndarray_desc=$(echo -n "${ndarray_desc}" | "${wrap}")
repl_text_ndarray_desc="${repl_text_ndarray_desc/    /}"

# Define the copyright year:
year=$(date +'%Y')

# Define the copyright holders:
copyright='The Stdlib Authors'

# Define lists of array values:
x_values_len_4=(
	"${x_values_len_8[0]}"
	"${x_values_len_8[1]}"
	"${x_values_len_8[2]}"
	"${x_values_len_8[3]}"
)
x_values_len_5=("${x_values_len_4[@]}" "${x_values_len_8[4]}")
x_values_len_6=("${x_values_len_5[@]}" "${x_values_len_8[5]}")

y_values_len_4=(
	"${y_values_len_8[0]}"
	"${y_values_len_8[1]}"
	"${y_values_len_8[2]}"
	"${y_values_len_8[3]}"
)
y_values_len_5=("${y_values_len_4[@]}" "${y_values_len_8[4]}")
y_values_len_6=("${y_values_len_5[@]}" "${y_values_len_8[5]}")

# Define a (row-major) matrix of expected values:
expected_script="var roundn = require( '${base_dir}/@stdlib/math/base/special/roundn' );var isInteger = require( '${base_dir}/@stdlib/assert/is-integer' ).isPrimitive;var f = require( '${base_dir}/@${binary_pkg}' );var x = '${x_values_len_6[*]}'.split( ' ' );var y = '${y_values_len_6[*]}'.split( ' ' );var expected = new Array( x.length*y.length );for ( var i = 0; i < x.length; i++ ) {for ( var j = 0; j < y.length; j++ ) {var v1 = f( parseFloat( x[ i ] ), parseFloat( y[ j ] ) );var v2 = roundn( v1, -3 );if ( v1 == v2 ) {v = v1.toString();if ( isInteger( v1 ) ) {v += '.0';}} else {v = '~' + v2.toString();if ( isInteger( v2 ) ) {v += '.0';}}expected[ (i*y.length)+j ] = v;}}console.log( expected.join( ',' ) );"

tmp=$(node -e "${expected_script}")
IFS=','; read -ra expected_values <<< "${tmp}"; IFS=' ';

# Extract the elements along the diagonal:
expected_len_6=(
	"${expected_values[0]}"
	"${expected_values[7]}"
	"${expected_values[14]}"
	"${expected_values[21]}"
	"${expected_values[28]}"
	"${expected_values[35]}"
)
expected_len_4=(
	"${expected_len_6[0]}"
	"${expected_len_6[1]}"
	"${expected_len_6[2]}"
	"${expected_len_6[3]}"
)
expected_len_5=("${expected_len_4[@]}" "${expected_len_6[4]}")

# Expected values when `x` has stride `2`, `y` has stride `-1`, and `z` has stride `1` (x0y1, x2y0):
expected_len_2_x2_ym1_z1=(
	"${expected_values[1]}"
	"${expected_values[12]}"
)

# Expected values when starting at 2nd element of `x` and the 3rd element of `y` and where `x` has stride `-2`, `y` has stride `1`, and `z` has stride `1` (x3y2, x1y3):
expected_len_2_xm2_y1_z1=(
	"${expected_values[20]}"
	"${expected_values[9]}"
)

# Expected values when `x` has stride `2`, `y` has stride `-1`, and `z` has stride `1` (x0y2, x2y1, x4y0):
expected_len_3_x2_ym1_z1=(
	"${expected_values[2]}"
	"${expected_values[13]}"
	"${expected_values[24]}"
)

# Expected values when starting at 2nd element of `x` and the 4th element of `y` and where `x` has stride `-2`, `y` has stride `1`, and `z` has stride `1` (x5y3, x3y4, x1y5):
expected_len_3_xm2_y1_z1=(
	"${expected_values[33]}"
	"${expected_values[22]}"
	"${expected_values[11]}"
)


## SCRIPT ##

# Define the list of scaffold directories:
dirs=(
	"benchmark"
	"docs"
	"docs/types"
	"examples"
	"lib"
	"test"
)

# Define the list of scaffold files:
files=(
	"benchmark/benchmark.js"
	"benchmark/benchmark.ndarray.js"
	"docs/types/index.d.ts"
	"docs/types/test.ts"
	"docs/repl.txt"
	"examples/index.js"
	"lib/index.js"
	"lib/main.js"
	"lib/ndarray.js"
	"test/test.js"
	"test/test.main.js"
	"test/test.ndarray.js"
	"package.json"
	"README.md"
)

# Create the destination directories...

for dir in "${dirs[@]}"; do
	mkdir -p "${dest_dir}/${dir}"
done

# Copy the scaffold files to the destination directory...
for file in "${files[@]}"; do
	cp "${this_dir}/data/${file//\./__}.txt" "${dest_dir}/${file}"
done

# Performs a find and replace across the destination directory.
#
# $1 - regular expression
find_and_replace() {
	find "${dest_dir}" -type f -print0 | xargs -0 perl -pi -w -e "$1"
}

# Performs a find and replace across a specified file.
#
# $1 - file
# $2 - regular expression
file_find_and_replace() {
	find "${dest_dir}/$1" -type f -print0 | xargs -0 perl -pi -w -e "$2"
}

# Joins a list of strings.
#
# $1 - separator
# $* - list of strings to join
join() {
	local d=$1; shift; local f=$1; shift; printf %s "$f" "${@/#/$d}";
}

# For each of the variables defined above, insert into the scaffold files...
regex="s/\\{\\{YEAR\\}\\}/${year}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{COPYRIGHT\\}\\}/${copyright}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{ALIAS\\}\\}/${alias}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{ALIAS_SNAKECASE\\}\\}/${alias_snakecase}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG\\}\\}/${pkg//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG_DESC\\}\\}/${pkg_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MODULE_DESC\\}\\}/${module_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MAIN_DESC\\}\\}/${main_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{NDARRAY_DESC\\}\\}/${ndarray_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TEST_DESC\\}\\}/${test_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{REPL_TEXT_MAIN_DESC\\}\\}/${repl_text_main_desc}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{REPL_TEXT_NDARRAY_DESC\\}\\}/${repl_text_ndarray_desc}/g;"
find_and_replace "${regex}"

if [ -n "${desc_link_text}" ]; then
	# WARNING: we assume that the description link text does *not* include any special regular expression characters...
	regex="s/${desc_link_text}/[${desc_link_text}][\\@${binary_pkg//\//\\/}]/g;"
	file_find_and_replace "README.md" "${regex}"

	regex="s/\\{\\{DESC_LINK_TEXT_LABEL\\}\\}/\\n\\n[\\@${binary_pkg//\//\\/}]: https:\\/\\/github.com\\/stdlib-js\\/stdlib/g;"
	file_find_and_replace "README.md" "${regex}"
else
	regex="s/\\{\\{DESC_LINK_TEXT_LABEL\\}\\}//g;"
	file_find_and_replace "README.md" "${regex}"
fi

regex="s/\\{\\{BINARY_PKG\\}\\}/${binary_pkg//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{BINARY_ALIAS\\}\\}/${binary_alias}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{BINARY_ALIAS_SNAKECASE\\}\\}/${binary_alias_snakecase}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{RAND_MIN\\}\\}/${rand_min}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{RAND_MAX\\}\\}/${rand_max}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TS_CALLBACK_RET_1_DTYPE\\}\\}/${ts_callback_ret_1_dtype}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TS_CALLBACK_RET_2_DTYPE\\}\\}/${ts_callback_ret_2_dtype}/g;"
find_and_replace "${regex}"

keywords_sep='",\n    "'
if [ "${#keywords[*]}" -eq 0 ]; then
	words=''
else
	words=$(join "${keywords_sep}" "${keywords[@]}")
	words="\\n    \"${words}\","
fi
regex="s/\\{\\{KEYWORDS\\}\\}/${words}/g;"
find_and_replace "${regex}"

expected_values_sep=', '

values=$(join "${expected_values_sep}" "${x_values_len_4[@]}")
regex="s/\\{\\{X_VALUES_LEN_4\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${x_values_len_5[@]}")
regex="s/\\{\\{X_VALUES_LEN_5\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${x_values_len_6[@]}")
regex="s/\\{\\{X_VALUES_LEN_6\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${x_values_len_8[@]}")
regex="s/\\{\\{X_VALUES_LEN_8\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${y_values_len_4[@]}")
regex="s/\\{\\{Y_VALUES_LEN_4\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${y_values_len_5[@]}")
regex="s/\\{\\{Y_VALUES_LEN_5\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${y_values_len_6[@]}")
regex="s/\\{\\{Y_VALUES_LEN_6\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${y_values_len_8[@]}")
regex="s/\\{\\{Y_VALUES_LEN_8\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${expected_len_4[@]}")
regex="s/\\{\\{EXPECTED_LEN_4\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${expected_len_5[@]}")
regex="s/\\{\\{EXPECTED_LEN_5\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${expected_len_2_x2_ym1_z1[@]}")
regex="s/\\{\\{EXPECTED_LEN_2_X2_YM1_Z1\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${expected_len_2_xm2_y1_z1[@]}")
regex="s/\\{\\{EXPECTED_LEN_2_XM2_Y1_Z1\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${expected_len_3_x2_ym1_z1[@]}")
regex="s/\\{\\{EXPECTED_LEN_3_X2_YM1_Z1\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${expected_len_3_xm2_y1_z1[@]}")
regex="s/\\{\\{EXPECTED_LEN_3_XM2_Y1_Z1\\}\\}/${values}/g;"
find_and_replace "${regex}"
