/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle */

'use strict';

// MODULES //

var rl = require( 'readline' );
var longestCommonPrefix = require( './longest_common_prefix.js' );


// MAIN //

/**
* Handles the gray preview that displays when there is only one possible tab completion.
*
* @private
* @param {REPL} repl repl instance
* @returns {Object} object containing two event listeners that handle drawing the preview
*/
function previewCompleter( repl ) {
	// This represents the preview currently being displayed
	var completionCache = '';

	/**
	* Clears the gray preview, so that it is no longer shown to the user.
	* @private
	*/
	function clearPreview() {
		var charactersToEnd;
		if ( completionCache !== '' ) {
			charactersToEnd = repl._rli.line.length - repl._rli.cursor;
			rl.moveCursor( repl._ostream, charactersToEnd );
			repl._rli.output.write( ' '.repeat( completionCache.length ) );
			rl.moveCursor( repl._ostream, -completionCache.length - charactersToEnd );
			completionCache = '';
		}
	}

	/**
	* This event fires before the keypress is processed by the readline input and ensures.
	* the following interactions:
	* If the user pressed 'return' while a preview is showing, and the user has the cursor
	* at the end of the line, the preview is filled in before the line is executed.
	* If the user pressed 'right' while the caret is at the end of the line and a preview is
	* showing, the preview is filled in.
	*
	* @param {*} _ not used
	* @param {Object} key the key the user pressed
	*/
	function beforeKeypress( _, key ) {
		if ( key && ( key.name === 'return' || key.name === 'enter' ) && completionCache !== '' ) {
			if ( repl._rli.cursor === repl._rli.line.length ) {
				repl._rli.write( completionCache );
				completionCache = '';
			} else {
				clearPreview();
			}
		}
		if ( key && key.name === 'right' &&
			repl._rli.cursor === repl._rli.line.length &&
			completionCache !== '' ) {
			repl._rli.write( completionCache );
			completionCache = '';
		}
	}

	/**
	* Event listener which fires after a key is pressed.
	*/
	function onKeypress() {
		// Get the possible tab completions from the completer
		repl._rli.completer( repl._rli.line, callback );
	}

	/**
	* Callback function passed to the completer.
	* @private
	*
	* @param {*} _ not used
	* @param {*} completions the possible completions passed by the completer
	*/
	function callback( _, completions ) {
		var charactersToEnd;
		var commonPrefix;
		var completion;

		// If there is only one possible tab completion
		if ( completions[ 0 ].length === 1 ) {
			completion = completions[ 0 ][ 0 ];

			// Find the part of the completion the user hasn't typed yet
			commonPrefix = longestCommonPrefix( completion, completions[ 1 ] );
			completion = completion.substring( commonPrefix.length );
			if ( completion !== '' ) {
				charactersToEnd = repl._rli.line.length - repl._rli.cursor;

				// Write the completion at the end of the line regardless of where the cursor was
				rl.moveCursor( repl._ostream, charactersToEnd );

				// The ASCII escape codes make the text grayed out
				repl._rli.output.write( '\x1b[90m' + completion + '\x1b[0m' );

				// Move cursor back to original posittion
				rl.moveCursor( repl._ostream, -completion.length - charactersToEnd );
			}
			completionCache = completion;
		} else {
			clearPreview();
		}
	}

	return {
		'beforeKeypress': beforeKeypress,
		'onKeypress': onKeypress
	};
}


// EXPORTS //

module.exports = previewCompleter;
