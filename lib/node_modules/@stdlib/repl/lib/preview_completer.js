/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle, no-invalid-this */

'use strict';

// MODULES //

var rl = require( 'readline' );
var repeat = require( '@stdlib/string/repeat' );
var longestCommonPrefix = require( './longest_common_prefix.js' );


// MAIN //

/**
* Handles the gray preview that displays when there is only one possible tab completion.
*
* @private
* @param {REPL} repl repl instance
* @returns {Object} object containing two event listeners that handle drawing the preview
*/
function PreviewCompleter( repl ) {
	if ( !(this instanceof PreviewCompleter) ) {
		return new PreviewCompleter( repl );
	}

	// This represents the preview currently being displayed.
	this.completionCache = '';

	// Keep the repl this instance is associated with.
	this.repl = repl;

	// We need to pass a bound callback to the completer, so we calculate it here.
	this.completerCallback = completerCallback.bind( this );

	return this;
}

PreviewCompleter.prototype.clearPreview = clearPreview;
PreviewCompleter.prototype.beforeKeypress = beforeKeypress;
PreviewCompleter.prototype.onKeypress = onKeypress;

/**
* Clears the gray preview, so that it is no longer shown to the user.
*/
function clearPreview() {
	var charactersToEnd;
	if ( this.completionCache !== '' ) {
		charactersToEnd = this.repl._rli.line.length - this.repl._rli.cursor;
		rl.moveCursor( this.repl._ostream, charactersToEnd );
		this.repl._rli.output.write( repeat(' ', this.completionCache.length) );
		rl.moveCursor( this.repl._ostream, -this.completionCache.length - charactersToEnd );
		this.completionCache = '';
	}
}

/**
* This event fires before the keypress is processed by the readline input and ensures.
* the following interactions:
* If the user pressed 'return' while a preview is showing, and the user has the cursor
* at the end of the line, the preview is filled in before the line is executed.
* If the user pressed 'right' while the caret is at the end of the line and a preview is
* showing, the preview is filled in.
*
* @param {*} _ not used
* @param {Object} key the key the user pressed
*/
function beforeKeypress( _, key ) {
	if ( key && ( key.name === 'return' || key.name === 'enter' ) && this.completionCache !== '' ) {
		if ( this.repl._rli.cursor === this.repl._rli.line.length ) {
			this.repl._rli.write( this.completionCache );
			this.completionCache = '';
		} else {
			this.clearPreview();
		}
	}
	if ( key && key.name === 'right' &&
		this.repl._rli.cursor === this.repl._rli.line.length &&
		this.completionCache !== '' ) {
		this.repl._rli.write( this.completionCache );
		this.completionCache = '';
	}
}

/**
* Event listener which fires after a key is pressed.
*/
function onKeypress() {
	// Get the possible tab completions from the completer
	this.repl._rli.completer( this.repl._rli.line, this.completerCallback );
}

/**
* Callback function passed to the completer.
* @private
*
* @param {*} _ not used
* @param {*} completions the possible completions passed by the completer
*/
function completerCallback( _, completions ) {
	var charactersToEnd;
	var commonPrefix;
	var completion;

	// If there is only one possible tab completion
	if ( completions[ 0 ].length === 1 ) {
		completion = completions[ 0 ][ 0 ];

		// Find the part of the completion the user hasn't typed yet
		commonPrefix = longestCommonPrefix( completion, completions[ 1 ] );
		completion = completion.substring( commonPrefix.length );
		if ( completion !== '' ) {
			charactersToEnd = this.repl._rli.line.length - this.repl._rli.cursor;

			// Write the completion at the end of the line regardless of where the cursor was
			rl.moveCursor( this.repl._ostream, charactersToEnd );

			// The ASCII escape codes make the text grayed out
			this.repl._rli.output.write( '\x1b[90m' + completion + '\x1b[0m' );

			// Move cursor back to original posittion
			rl.moveCursor( this.repl._ostream, -completion.length - charactersToEnd );
		}
		this.completionCache = completion;
	} else {
		this.clearPreview();
	}
}


// EXPORTS //

module.exports = PreviewCompleter;
