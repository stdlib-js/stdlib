/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var startsWith = require( '@stdlib/string/starts-with' );
var lowercase = require( '@stdlib/string/lowercase' );


// VARIABLES //

var PENALTIES = {
	'wrong_case': -1, // Penalty for a matching character that is in the wrong case
	'not_start': -4, // Penalty if the first letter of the completion and input are different
	'gap_between': -4, // Penalty for a gap between matching characters of input in the completion
	'gap_beginning': -1, // Penalty for a gap, before a character from input is encountered
	'missing_char': -19 // Penalty for a character in input that doesn't exist in the completion (to tackle possible spelling mistakes)
};
var LENIENCY_FACTOR = 0.27; // Controls how lenient the algorithm is


// MAIN //

/**
* Checks if the completion is strictly a fuzzy match for the input and returns a score representing the extent of the match.
*
* ## Notes
*
* -   The algorithm is based on a penalty based scoring mechanism that charges a penalty for unfavorable characteristics in the completion string that make it less ideal of a match to the input string.
*
* -   The algorithm takes the following variables into account:
*
*     -   Casing mismatch: Low penalty
*     -   First character doesn't match: Medium penalty
*     -   Gap between matching characters: Medium penalty
*     -   Gap before the input was encountered: Low penalty
*     -   Missing character: High penalty
*
* @private
* @param {string} completion - completion string
* @param {string} input - input string
* @returns {(boolean|Object)} false if not a fuzzy match. If a fuzzy match, an object with the completion and score (<=0) representing the extent of the match. Lower scores (negative) indicate a worse match. A score of 0 indicates a perfect match.
*
* @example
* var score = fuzzyMatch( 'pizza', 'zz' );
* // returns { 'score': -6.0, 'completion': 'pizza' }
*
* score = fuzzyMatch( 'pizza', 'ab' );
* // returns false
*/
function fuzzyMatch( completion, input ) {
	var lastMatchedIndex;
	var foundFirstMatch;
	var completionIndex;
	var gapsBetween;
	var inputIndex;
	var worstScore;
	var score;

	worstScore = input.length * PENALTIES.missing_char;

	// If the input is an exact prefix of the completion, reject it as it will be handled by the non-fuzzy logic...
	if ( startsWith( completion, input ) ) {
		return false;
	}
	// If the completion is shorter than the input, don't match...
	if ( completion.length < input.length ) {
		return false;
	}
	// If the input is just a single character, don't try to fuzzy match...
	if ( input.length === 1 ) {
		return false;
	}

	score = 0;
	inputIndex = 0;
	completionIndex = 0;
	lastMatchedIndex = -1; // buffer to store the index in the completion string where the last match was found
	gapsBetween = 0;
	foundFirstMatch = false; // flag that tracks if we have found a single character from the input in the completion, so that we can check for `gap_between` penalties

	// If the first character of the input and completion do not match, charge the penalty...
	if ( lowercase( input[inputIndex] ) !== lowercase( completion[completionIndex] ) ) { // eslint-disable-line max-len
		score += PENALTIES.not_start;
	}
	// Traverse the completion string looking for characters in the input (in the same order)
	while ( inputIndex < input.length && completionIndex < completion.length ) {
		if ( lowercase( input[inputIndex] ) === lowercase( completion[completionIndex] ) ) { // eslint-disable-line max-len
			// If we find an input character match in the completion, check if the case doesn't match and charge a penalty accordingly...
			if ( input[inputIndex] !== completion[completionIndex] ) {
				score += PENALTIES.wrong_case;
			}
			foundFirstMatch = true;
			lastMatchedIndex = completionIndex;
			score += gapsBetween * PENALTIES.gap_between;
			gapsBetween = 0;
			inputIndex += 1;
		} else if ( completionIndex + 1 === completion.length ) {
			// Failed to find the input character in the completion string after full traversal, charge a penalty and check for the next character in the input string from the buffer index in the completion
			score += PENALTIES.missing_char;
			gapsBetween = 0;
			inputIndex += 1;
			completionIndex = lastMatchedIndex + 1;
		} else if ( foundFirstMatch ) {
			// If input and completion character do not match in this iteration and atleast one input character has been found before, track the gaps till the next match
			gapsBetween += 1;
		} else {
			// If input and completion character do not match in the iteration and no input character is found yet, track the gaps till the first match
			score += PENALTIES.gap_beginning;
		}
		completionIndex += 1;

		// Check for early rejections...
		if ( score < LENIENCY_FACTOR * worstScore ) {
			return false;
		}
	}

	// Charge penalty for the input characters that are still remaining but the completion string is fully checked for input characters (e.g., input: abcd, completion: xayzb, charge penalty for the remaining c and d )
	score += ( input.length - inputIndex ) * PENALTIES.missing_char;

	if ( score < LENIENCY_FACTOR * worstScore ) {
		return false;
	}
	return {
		'score': score,
		'completion': completion
	};
}


// EXPORTS //

module.exports = fuzzyMatch;
