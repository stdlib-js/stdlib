{"repl":{"name":"repl","text":"| \\*Tutorial: REPL\\s\n\n\nHow to use this tutorial...\n\n• Enter\n\n  ```javascript\n  next();\n  ```\n\n  followed by \\*RETURN\\s to advance the tutorial.\n\n---\n\n• At the command prompt, enter\n\n  ```javascript\n  pres();\n  ```\n\n  followed by \\*RETURN\\s to see the list of available tutorial commands.\n\n---\n\n• As documented when running \\*pres()\\s, you can use command shortcuts.\n  For example, enter\n\n  ```javascript\n  n();\n  ```\n\n  followed by \\*RETURN\\s to advance the tutorial.\n\n---\n\n• Use the up/down arrow keys to cycle through previously run commands.\n  Feel free to try using the arrow keys below...\n\n---\n\n• When entering and running commands, the tutorial presentation slide is\n  likely to scroll out of view.\n\n  To return to the slide, simply scroll up. :grinning:\n\n---\n\n• As this tutorial is a REPL presentation, enter\n\n  ```javascript\n  presentationStop();\n  ```\n\n  followed by \\*RETURN\\s to end this tutorial at any time.\n\n• Enter\n\n  ```javascript\n  quit();\n  ```\n\n  to exit the REPL altogether.\n\n---\n\n| Enough preliminaries, let's start the tutorial!\n\n---\n\n| This tutorial introduces you to the REPL environment.\n\n---\n\n| REPL stands for \\*r\\sead-\\*e\\sval-\\*p\\srint \\*l\\soop\\s.\n\n---\n\n| A REPL...\n\n\\s\n\n--\n\n• ...is an interactive programming environment\n\n--\n\n• ...which receives individual user inputs (e.g., single expressions)\n\n--\n\n• ...evaluates those inputs\n\n--\n\n• ...and returns the result.\n\n---\n\n\n| Accordingly, an entered program is executed piecewise and sequentially.\n\n---\n\nIn this tutorial, you've already been using the REPL when you've advanced\nthe tutorial and printed the list of available commands.\n\nAs another simple example, evaluate the following input\n\n```javascript\n1+1\n```\n\n--\n\n\\s\nIn this case, we entered `1+1` (user inputs) and instructed the REPL to evaluate\nthose inputs (\\*RETURN\\s), and the REPL returned (and printed) the result.\n\n--\n\n\\s\nAfter returning the result, the REPL provides another prompt, thus completing\nthe \\*r\\sead-\\*e\\sval-\\*p\\srint \\*l\\soop.\n\n---\n\n| REPLs are useful for...\n\\s\n\n--\n\n• learning programming languages (such as JavaScript)\n\n--\n\n• debugging (including when embedded in running applications)\n\n--\n\n• demos (including live coding)\n\n--\n\n• interactivity (such as during iterative development)\n\n---\n\nTo get started using this REPL, a few commands will prove immensely useful.\n\n---\n\nThe first command is\n\n```javascript\nhelp()\n```\n\nRun the above command to see a list of REPL commands.\n\n---\n\nTo see the documentation for a specific REPL alias, provide the alias to the\n\\*help()\\s command.\n\nFor example, run\n\n```javascript\nhelp( 'base.sin' )\n```\n\nto see the documentation for the \\*base.sin\\s function.\n\n---\n\nOn the previous slide, you specified the alias via a string representing the\nalias name.\n\nYou can also provide a reference pointing to the aliased value.\n\nFor example, run\n\n```javascript\nhelp( base.sin )\n```\n\nto see the same documentation as before.\n\n---\n\nAdditionally, for objects having known methods, you can print method\ndocumentation.\n\nFor example, run\n\n```javascript\nhelp( base.random.randu.factory )\n```\n\nto see the \\*factory()\\s method documentation.\n\n---\n\nLastly, for select objects having a known constructor, you can provide\ninstances.\n\nFor example, create a \\*Float64Array\\s\n\n```javascript\nvar x = new Float64Array( 10 );\n```\n\nand then run\n\n```javascript\nhelp( x )\n```\n\nwhich will print the documentation for \\*Float64Array\\s.\n\n---\n\nThe \\*help()\\s command provides detailed API documentation.\n\nSometimes, you just want to know the function signature and a brief\ndescription.\n\nFor this use case, you can use another command: \\*info()\\s.\n\nFor example, run\n\n```javascript\ninfo( 'base.sin' )\n```\n\nto see abbreviated API documentation for \\*base.sin\\s.\n\n---\n\nSimilar to \\*help()\\s, you can provide a variable reference.\n\nFor example, run\n\n```javascript\ninfo( base.sin )\n```\n\nto see the same abbreviated API documentation.\n\n---\n\nAnother useful command is \\*example()\\s, which runs the example code found in\nthe documentation printed by \\*help()\\s.\n\nFor example, run\n\n```javascript\nexample( 'base.sin' )\n```\n\nto run the example code found in the documentation for \\*base.sin\\s.\n\n---\n\nSimilarly to \\*help()\\s and \\*info()\\s, you can provide a variable reference.\n\nFor example, run\n\n```javascript\nexample( base.sin )\n```\n\nto again run the example code for \\*base.sin\\s.\n\n---\n\nFinally, two other commands are useful when wanting to resolve aliases and\npackage implementations.\n\n---\n\nTo determine which package corresponds to a specified alias, use\n\\*alias2pkg()\\s.\n\nFor example, run\n\n```javascript\nalias2pkg( 'base.sin' )\n```\n\nor\n\n```javascript\nalias2pkg( base.sin )\n```\n\nto resolve the package for \\*base.sin\\s.\n\n---\n\nTo determine which alias corresponds to a specified package, use\n\\*pkg2alias()\\s.\n\nFor example, run\n\n```javascript\npkg2alias( '@stdlib/math/base/special/sin' )\n```\n\nto resolve the alias for \\*@stdlib/math/base/special/sin\\s.\n\n---\n\nWhen you're working in a REPL, you're often interested in viewing the\nresults of the previously invoked command.\n\nAccordingly, when you run\n\n```javascript\n1+1\n```\n\nyou should see the result \\*2\\s.\n\n---\n\nHowever, at other times you'll want to silence printed output.\n\nTo do so, add a \\*semicolon\\s to any statement.\n\nFor example, when you add a semicolon to the previous statement\n\n```javascript\n1+1;\n```\n\nno result is printed.\n\n---\n\nDuring iterative development, you'll occasionally forget to assign the\nresults of the last expression or statement.\n\nFortunately, the REPL has a special variable which stores the last result:\n\\*ans\\s.\n\nFor example, run the previous statement\n\n```javascript\n1+1;\n```\n\nfollowed by\n\n```javascript\nans\n```\n\nto see that \\*ans\\s is assigned the value \\*2\\s.\n\n---\n\nWhile not encouraged for general use, \\*ans\\s can be used just like any\nother variable within the top-level scope.\n\n---\n\nAnother common occurrence during iterative development within a REPL\nenvironment is forgetting variable names or failing to remember what\nvariables have already been declared.\n\nThankfully, you can run\n\n```javascript\nvars()\n```\n\nto return a list of user-defined variable names. For additional variable\ndetails, run\n\n```javascript\nhelp( vars )\n```\n\nto see function options.\n\n---\n\nTo facilitate working with long variable names and nested property access,\nthe REPL supports \\*TAB\\s completion.\n\nFor example, enter\n\n```javascript\nbase.r\n```\n\nfollowed by \\*TAB\\s to generate a list of auto-completions which begin\nwith the letter \\*r\\s.\n\n---\n\nSimilarly, if you create a nested object\n\n```javascript\nvar obj = { 'beep': { 'boop': { 'foo': 'bar' } } };\n```\n\nand then enter\n\n```javascript\nobj.beep.b\n```\n\nfollowed by \\*TAB\\s, the nested property \\*boop\\s should auto-complete.\n\n---\n\n\\*TAB\\s completion also works with computed properties. For example, enter\n\n```javascript\nobj[ 'beep' ][ 'b\n```\n\nfollowed by \\*TAB\\s to auto-complete the nested property \\*boop\\s as done\nin the previous slide.\n\n---\n\nFor select APIs interacting with the filesystem, \\*TAB\\s completion is\nsupported for file paths.\n\nFor example, enter\n\n```javascript\nreadFile.sync( './\n```\n\nfollowed by \\*TAB\\s to generate a list of applicable file paths.\n\n---\n\nAdditionally, \\*TAB\\s completion is supported for variables defined in a\nnested scope.\n\nFor example, enter\n\n```javascript\nfunction foo() { var beep = 5; be\n```\n\nfollowed by \\*TAB\\s to auto-complete the variable \\*beep\\s.\n\nSimilarly, entering\n\n```javascript\nfunction foo( beep ) { console.log( be\n```\n\nfollowed by \\*TAB\\s auto-completes the parameter \\*beep\\s.\n\n---\n\nWhen working in a REPL, you'll often times want to explore and test\nfunctions and workflows using different parameterizations and variable\nvalues.\n\nManaging the various variables can be messy and difficult.\n\nTo this end, this REPL introduces the concept of workspaces.\n\n---\n\nA \\*workspace\\s is simply a named collection of user-defined variables.\n\n---\n\nTo print the name of the current workspace, run\n\n```javascript\ncurrentWorkspace\n```\n\nTake note of this workspace name.\n\n---\n\nTo retrieve a list of all workspaces, run\n\n```javascript\nworkspaces()\n```\n\n---\n\nTo either switch to or create a workspace, you can use the \\*workspace()\\s\ncommand. For example, enter\n\n```javascript\nworkspace( '\n```\n\nfollowed by \\*TAB\\s to see a list of existing workspaces to which you can\nswitch.\n\n---\n\nTo switch to the \"base\" workspace, run\n\n```javascript\nworkspace( 'base' )\n```\n\nIf you now run\n\n```javascript\nvars()\n```\n\nnotice that the variables defined in the previous workspace are no longer\npresent.\n\nReturn back to the tutorial workspace.\n\n---\n\nRun the \\*help()\\s command to see additional workspace-related commands.\n\n---\n\nJavaScript is single-threaded and asynchronous.\n\nTo support asynchronous APIs, the REPL supports top-level \\*async\\s/\\*await\\s.\n\n---\n\nIn Node.js environments supporting \\*async\\s/\\*await\\s, run\n\n```javascript\nawait new Promise((resolve) => setTimeout(() => resolve( 'beep' ), 2000))\n```\n\nwhich will return the resolved value.\n\n---\n\nIn older Node.js environments and when using non-promise APIs, you can\ninvoke a \\*__done__\\s callback.\n\nFor example, define the following function\n\n```javascript\nfunction foo() {setTimeout(() => __done__(null, 'beep'), 2000)};\n```\n\nTo asynchronously resolve the value, run\n\n```javascript\n\"async\"; foo()\n```\n\nwhere the special directive \\*\"async\";\\s indicates that a command is\nasynchronous.\n\n---\n\nDuring iterative development, you'll frequently want to rerun one or more\ncommands.\n\nFor example, let's say you want to simulate the rolling of two fair dice\n\n```javascript\nvar dice = base.random.discreteUniform.factory( 1, 6, {'seed': 1234} );\nfunction roll() { return [ dice(), dice() ]; };\n```\n\nTo roll the dice, enter the following command one or more times\n\n```javascript\nroll()\n```\n\n---\n\nTo regenerate the same dice roll sequence, run\n\n```javascript\nrerun( [ X, Y ] )\n```\n\nwhere \\*X\\s is the line number where you declared \\*dice\\s and \\*Y\\s is\na line number where you invoked \\*roll()\\s.\n\n\\*rerun\\s is especially useful for saving keystrokes when rerunning\narbitrary sequences of commands.\n\n---\n\nWhen working in a REPL, you'll have use cases where you'll want to\nencapsulate extended logic in external files.\n\nThese files will typically export functionality and/or data which you\ncan then import into the REPL environment.\n\nFor example, open up your favorite editor, create a new file, and paste\nthe following code\n\n```javascript\nfunction beep() {\n    return 'boop';\n}\n\nmodule.exports = beep;\n```\n\n---\n\nTo load your newly created file, enter\n\n```javascript\nvar beep = require( './\n```\n\nfollowed by \\*TAB\\s to use \\*TAB\\s completion to locate your file.\n\nOnce you've resolved the file's path and executed the command, run\n\n```javascript\nbeep()\n```\n\nwhich should return the value \\*'boop'\\s.\n\n---\n\nNow modify your file to match the following contents\n\n```javascript\nfunction beep() {\n    return 'beepboop';\n}\n\nmodule.exports = beep;\n```\n\nRerun the \\*require()\\s statement you entered above and run\n\n```javascript\nbeep()\n```\n\nDid the command return \\*'beepboop'\\s?\n\n---\n\n\\*require()\\s works by caching the exports of previously required modules.\n\nTo explicitly reload your modified file, enter\n\n```javascript\nbeep = rerequire( './\n```\n\nfollowed by \\*TAB\\s to use \\*TAB\\s completion to once again locate your file.\n\nOnce you've resolved the file's path and executed the command, run\n\n```javascript\nbeep()\n```\n\nwhich should return the expected value.\n\n---\n\nFor those use cases where you need to reload a module and all of its module\ndependencies, use \\*deeprerequire()\\s.\n\n---\n\nWorking in a REPL frequently involves working with data.\n\nTo facilitate exploring that data, the REPL provides a plot API.\n\n---\n\nAs a simple example, define two 1-dimensional data arrays corresponding\nto the x- and y-axis plot data, respectively.\n\n```javascript\nvar x = inmap( new Int32Array(100), (v,i) => i );\nvar y = [ ...random.iterators.randu({'iter':x.length}) ];\n```\n\n---\n\nNext, define a new \\*Plot\\s instance by running\n\n```javascript\nvar plt = new Plot( [x], [y] );\n```\n\nTo view the plot in a separate window, run\n\n```javascript\nplt.view( 'window' )\n```\n\n---\n\nTo further explore the \\*Plot\\s API, run\n\n```javascript\nhelp( Plot )\n```\n\n---\n\n| \\*Congratulations!\\s\n\nYou've now reached the end of this tutorial.\n\nHopefully, by now, you've realized how powerful (and fun!) programming in\na REPL can be! :grinning:\n\n---\n\n| Happy REPLing!\n\n---\n\n| The End\n\n---\n\n• To exit this tutorial and return to the \"base\" workspace, run\n\n  ```javascript\n  presentationStop();\n  ```\n\n• To exit the REPL altogether, run\n\n  ```javascript\n  quit();\n  ```\n","desc":"Learn how to use the REPL environment."}}