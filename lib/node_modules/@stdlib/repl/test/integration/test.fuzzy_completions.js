/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var DebugStream = require( '@stdlib/streams/node/debug' );
var contains = require( '@stdlib/assert/contains' );
var replace = require( '@stdlib/string/replace' );
var repl = require( './fixtures/repl.js' );


// VARIABLES //

var RE_ANSI = /[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d/#&.:=?%@~_]*)*)?\u0007)|(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))/g; // eslint-disable-line no-control-regex


// FUNCTIONS //

/**
* Returns default settings.
*
* @private
* @returns {Object} default settings
*/
function defaultSettings() {
	return {
		'autoDeletePairs': false,
		'autoClosePairs': false,
		'completionPreviews': false,
		'fuzzyCompletions': false
	};
}

/**
* Removes ANSI escape codes from a string.
*
* @private
* @param {string} str - input string
* @returns {string} string with ANSI escape codes removed
*/
function stripANSI( str ) {
	return replace( str, RE_ANSI, '' );
}

/**
* Extract completions from a TAB completions output string.
*
* @private
* @param {string} str - completions output
* @returns {Array} array of completions
*/
function extractCompletions( str ) {
	var cleanOutput;
	var out = [];
	var i;

	cleanOutput = str.split('\r\n');
	for ( i = 0; i < cleanOutput.length; i++ ) {
		if ( cleanOutput[i] !== '' ) {
			out.push( cleanOutput[ i ] );
		}
	}
	return out;
}


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof repl, 'function', 'main export is a function' );
	t.end();
});

tape( 'a REPL instance supports displaying TAB completions of user-defined variables', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with unique names in order to prevent namespace collisions:
	istream.write( 'var zzxyz = 1;' );
	istream.write( 'var zzabc = 2;' );
	istream.write( 'var zzpqr = 3;' );

	// Write the common beginning of the variable names in order to generate TAB completions:
	istream.write( 'zz' );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		var actual;

		if ( error ) {
			t.fail( error.message );
			return;
		}

		actual = extractCompletions( stripANSI( data[ data.length-2 ] ) );

		// Check for three completions in the output:
		t.strictEqual( actual.length, 3, 'returns expected value' );

		// Check for the declared variables (sorted lexicographically) in the completions:
		t.strictEqual( actual[ 0 ], 'zzabc', 'returns expected value' );
		t.strictEqual( actual[ 1 ], 'zzpqr', 'returns expected value' );
		t.strictEqual( actual[ 2 ], 'zzxyz', 'returns expected value' );

		// `data[ data.length-1 ]` brings the cursor to the current line...

		t.end();
	}
});

tape( 'a REPL instance supports displaying `fuzzy` TAB completions of user-defined variables', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with unique names in order to prevent namespace collisions:
	istream.write( 'var pizza = 1;' );
	istream.write( 'var jazz = 2;' );

	// Write the common substring of the variable names in order to generate fuzzy completions:
	istream.write( 'zz' );

	// Enable Fuzzy completions:
	r.settings( 'fuzzyCompletions', true );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		var actual;

		if ( error ) {
			t.fail( error.message );
			return;
		}

		actual = extractCompletions( stripANSI( data[ data.length-2 ] ) );

		// Check for two fuzzy completions in the output:
		t.strictEqual( actual.length, 2, 'returns expected value' );

		// Check for the declared variables (sorted lexicographically) in the completions:
		t.strictEqual( actual[ 0 ], 'jazz', 'returns expected value' );
		t.strictEqual( actual[ 1 ], 'pizza', 'returns expected value' );

		// `data[ data.length-1 ]` brings the cursor to the current line...

		t.end();
	}
});

tape( 'a REPL instance doesn\'t display `fuzzy` completions if `exact` completions exist', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with `zz` as an exact prefix:
	istream.write( 'var zzxyz = 1;' );
	istream.write( 'var zzabc = 2;' );
	istream.write( 'var zzpqr = 3;' );

	// Declare variables with `zz` not as an exact prefix:
	istream.write( 'var pizza = 1;' );
	istream.write( 'var jazz = 2;' );

	// Write the common substring of the variable names in order to generate TAB completions:
	istream.write( 'zz' );

	// Enable Fuzzy completions:
	r.settings( 'fuzzyCompletions', true );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		var actual;

		if ( error ) {
			t.fail( error.message );
			return;
		}

		actual = extractCompletions( stripANSI( data[ data.length-2 ] ) );

		// Check for three exact completions in the output:
		t.strictEqual( actual.length, 3, 'returns expected value' );

		// Check for the declared variables with exact prefixes in the completions:
		t.strictEqual( actual[ 0 ], 'zzabc', 'returns expected value' );
		t.strictEqual( actual[ 1 ], 'zzpqr', 'returns expected value' );
		t.strictEqual( actual[ 2 ], 'zzxyz', 'returns expected value' );

		// `data[ data.length-1 ]` brings the cursor to the current line...

		t.end();
	}
});

tape( 'a REPL instance supports displaying TAB completions with input characters highlighted', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with unique names in order to prevent namespace collisions:
	istream.write( 'var pizza = 1;' );
	istream.write( 'var jazz = 2;' );

	// Write the common substring of the variable names in order to generate fuzzy completions:
	istream.write( 'zz' );

	// Enable Fuzzy completions:
	r.settings( 'fuzzyCompletions', true );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		var actual;

		if ( error ) {
			t.fail( error.message );
			return;
		}

		actual = extractCompletions( data[ data.length-2 ] );

		// Check for two fuzzy completions in the output:
		t.strictEqual( actual.length, 2, 'returns expected value' );

		// Check for the declared variables in the completions with input characters highlighted:
		t.strictEqual( actual[ 0 ], 'ja\x1B[1mz\x1B[0m\x1B[1mz\x1B[0m', 'returns expected value' );
		t.strictEqual( actual[ 1 ], 'pi\x1B[1mz\x1B[0m\x1B[1mz\x1B[0ma', 'returns expected value' );

		// `data[ data.length-1 ]` brings the cursor to the current line...

		t.end();
	}
});

tape( 'a REPL instance supports hiding the completions panel upon pressing TAB again', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with unique names in order to prevent namespace collisions:
	istream.write( 'var pizza = 1;' );
	istream.write( 'var jazz = 2;' );

	// Write the common substring of the variable names in order to generate fuzzy completions:
	istream.write( 'zz' );

	// Enable Fuzzy completions:
	r.settings( 'fuzzyCompletions', true );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Write TAB again to hide completions:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Check if the completions were cleared:
		t.strictEqual( data[ data.length-2 ], '\x1B[0J', 'returns expected value' );

		// `data[ data.length-1 ]` adds the remaining string to the right of the cursor because of the abnormal behaviour of `clearScreenDown`...

		t.end();
	}
});

tape( 'a REPL instance supports navigating the TAB completions using arrow keys', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with unique names in order to prevent namespace collisions:
	istream.write( 'var pizza = 1;' );
	istream.write( 'var jazz = 2;' );

	// Write the common substring of the variable names in order to generate fuzzy completions:
	istream.write( 'zz' );

	// Enable Fuzzy completions:
	r.settings( 'fuzzyCompletions', true );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Navigate down using down arrow:
	istream.write('\u001B[B');

	// Navigate right to the next completion using right arrow:
	istream.write('\u001B[C');

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		var actual;

		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Check for completions before navigation:
		actual = extractCompletions( stripANSI( data[ data.length-12 ] ) );
		t.strictEqual( actual.length, 2, 'returns expected value' );
		t.strictEqual( actual[ 0 ], 'jazz', 'returns expected value' );
		t.strictEqual( actual[ 1 ], 'pizza', 'returns expected value' );

		// `data[ data.length-11 ]` brings cursor to the current line...

		// Screen is cleared after `down` arrow key to re-display the navigated output:
		t.strictEqual( data[ data.length-10 ], '\x1B[0J', 'returns expected value' );

		// Check for completions after `down` arrow:
		actual = extractCompletions( data[ data.length-9 ] );

		// First completion should be highlighted:
		t.strictEqual( actual[ 0 ], '\x1B[7mjazz\x1B[27m', 'returns expected value' );

		// `data[ data.length-8 ]` brings cursor to the current line...

		// Current line is cleared and the first completion is inserted:
		t.strictEqual( data[ data.length-7 ], '\x1B[0K', 'returns expected value' );
		t.strictEqual( data[ data.length-6 ], 'var pizza = 1;var jazz = 2;jazz', 'returns expected value' );

		// Screen is cleared after `right` arrow key to re-display the navigated output:
		t.strictEqual( data[ data.length-5 ], '\x1B[0J', 'returns expected value' );

		// Check for completions after `right` arrow key:
		actual = extractCompletions( data[ data.length-4 ] );

		// Second completion should be highlighted:
		t.strictEqual( actual[ 1 ], '\x1B[7mpizza\x1B[27m', 'returns expected value' );

		// `data[ data.length-3 ]` brings cursor to the current line...

		// Current line is cleared and the second completion is inserted:
		t.strictEqual( data[ data.length-2 ], '\x1B[0K', 'returns expected value' );
		t.strictEqual( data[ data.length-1 ], 'var pizza = 1;var jazz = 2;pizza', 'returns expected value' );

		t.end();
	}
});

tape( 'a REPL instance supports navigating the TAB completions using arrow keys', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with unique names in order to prevent namespace collisions:
	istream.write( 'var zzabc = 1;' );
	istream.write( 'var zzpqr = 2;' );

	// Write the common beginning of the variable names in order to generate TAB completions:
	istream.write( 'zz' );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Navigate down using down arrow:
	istream.write('\u001B[B');

	// Navigate up towards the line to bring back the original line:
	istream.write('\u001B[A');

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Current line is cleared and the original line is inserted:
		t.strictEqual( data[ data.length-2 ], '\x1B[0K', 'returns expected value' );
		t.strictEqual( data[ data.length-1 ], 'var zzabc = 1;var zzpqr = 2;zz', 'returns expected value' );

		t.end();
	}
});

tape( 'a REPL instance supports displaying highlighted arguement TAB completions', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Write the common beginning of the settings in order to generate TAB completions:
	istream.write( 'settings(\'auto' );

	// Write TAB to display completions:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		var actual;

		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Check for settings name completions in the output:
		actual = extractCompletions( data[ data.length-2 ] );
		t.ok( contains( actual, '\x1B[1mauto\x1B[0mClosePairs' ), 'returns expected value' );
		t.ok( contains( actual, '\x1B[1mauto\x1B[0mDeletePairs' ), 'returns expected value' );

		// `data[ data.length-1 ]` brings the cursor to the current line...

		t.end();
	}
});

tape( 'a REPL instance supports auto-completing common prefixes when hitting TAB', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare variables with `zzzz` as an exact prefix:
	istream.write( 'var zzzz = 1;' );
	istream.write( 'var zzzzabc = 2;' );
	istream.write( 'var zzzzpqr = 3;' );

	// Partially write the common beginning of the variable names in order to generate a TAB auto-completion:
	istream.write( 'zz' );

	// Write TAB to trigger auto-completion:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Check if the completion prefix was cleared:
		t.strictEqual( data[ data.length-2 ], '\b\b', 'returns expected value' );

		// Check if the final completion was auto-inserted:
		t.strictEqual( data[ data.length-1 ], 'zzzz', 'returns expected value' );

		t.end();
	}
});

tape( 'a REPL instance supports auto-completing a single fuzzy completion for the input when hitting TAB', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Declare a variables with `zz` as a substring:
	istream.write( 'var pizza = 1;' );

	// Write the common substring of the variable names in order to generate a fuzzy completion:
	istream.write( 'zz' );

	// Enable Fuzzy completions:
	r.settings( 'fuzzyCompletions', true );

	// Write TAB to trigger auto completion:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Check if the completion prefix was cleared:
		t.strictEqual( data[ data.length-2 ], '\b\b', 'returns expected value' );

		// Check if the final completion was auto-inserted:
		t.strictEqual( data[ data.length-1 ], 'pizza', 'returns expected value' );

		t.end();
	}
});

tape( 'a REPL instance supports auto-completing common arguement prefixes when hitting TAB', function test( t ) {
	var istream;
	var opts;
	var r;

	istream = new DebugStream({
		'name': 'repl-input-stream'
	});
	opts = {
		'input': istream,
		'settings': defaultSettings()
	};
	r = repl( opts, onClose );

	// Write the arguement with just one possible completion:
	istream.write( 'settings(\'fuzzyCompleti' );

	// Write TAB to trigger auto completion:
	istream.write( '\t' );

	// Close the input stream:
	istream.end();

	// Close the REPL:
	r.close();

	function onClose( error, data ) {
		if ( error ) {
			t.fail( error.message );
			return;
		}

		// Check if the completion prefix (`fuzzyCompleti`) was cleared:
		t.strictEqual( data[ data.length-2 ], '\b\b\b\b\b\b\b\b\b\b\b\b\b', 'returns expected value' );

		// Check if the final completion was auto-inserted:
		t.strictEqual( data[ data.length-1 ], 'fuzzyCompletions', 'returns expected value' );

		t.end();
	}
});
