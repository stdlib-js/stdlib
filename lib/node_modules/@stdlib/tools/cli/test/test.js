'use strict';

// MODULES //

var join = require( 'path' ).join;
var tape = require( 'tape' );
var proxyquire = require( 'proxyquire' );
var IS_BROWSER = require( '@stdlib/assert/is-browser' );
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var instanceOf = require( '@stdlib/assert/instance-of' );
var noop = require( '@stdlib/utils/noop' );
var CLI = require( './../lib' );


// VARIABLES //

var opts = {
	'skip': IS_BROWSER
};


// FIXTURES //

var stdout = require( './fixtures/stdout.js' );
var stderr = require( './fixtures/stderr.js' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof CLI, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function is a constructor', function test( t ) {
	t.strictEqual( instanceOf( new CLI(), CLI ), true, 'returns an instance' );
	t.end();
});

tape( 'the constructor does not require the `new` keyword', function test( t ) {
	var ctor;
	var cli;

	ctor = CLI;
	cli = ctor();

	t.strictEqual( instanceOf( cli, CLI ), true, 'returns an instance' );
	t.end();
});

tape( 'the constructor throws an error if provided an `options` argument which is not an object', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		true,
		false,
		null,
		void 0,
		[],
		function noop() {}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			var cli = new CLI( value );
			return cli;
		};
	}
});

tape( 'the constructor throws an error if provided an invalid option', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		true,
		false,
		null,
		void 0,
		[],
		function noop() {}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			var cli = new CLI({
				'pkg': value
			});
			return cli;
		};
	}
});

tape( 'the returned instance exits the process if an error is encountered when writing to `stdout`', function test( t ) {
	var stream;
	var ctor;
	var proc;

	proc = {
		'exit': exit
	};
	stream = stdout();

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stream,
		'@stdlib/streams/base/stderr': stderr()
	});

	ctor();
	stream.emit( 'error' );

	function exit() {
		t.ok( true, 'exits the process' );
		t.end();
	}
});

tape( 'the returned instance exits the process if an error is encountered when writing to `stderr`', function test( t ) {
	var stream;
	var ctor;
	var proc;

	proc = {
		'exit': exit
	};
	stream = stderr();

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stream
	});

	ctor();
	stream.emit( 'error' );

	function exit() {
		t.ok( true, 'exits the process' );
		t.end();
	}
});

tape( 'if the `title` option is `true`, the returned instance sets the process title (bin object)', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'title': true,
		'pkg': {
			'name': 'beep',
			'version': '0.0.0',
			'bin': {
				'demo': './bin/cli'
			}
		}
	};
	ctor( opts );

	t.strictEqual( proc.title, 'demo', 'sets the process title' );
	t.end();
});

tape( 'if the `title` option is `true`, the returned instance sets the process title (bin string)', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'title': true,
		'pkg': {
			'name': 'beep',
			'version': '0.0.0',
			'bin': './bin/cli'
		}
	};
	ctor( opts );

	t.strictEqual( proc.title, 'beep', 'sets the process title' );
	t.end();
});

tape( 'if the `title` option is `true`, the returned instance sets the process title (no bin)', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'title': true,
		'pkg': {
			'name': 'beep',
			'version': '0.0.0'
		}
	};
	ctor( opts );

	t.strictEqual( proc.title, 'beep', 'sets the process title' );
	t.end();
});

tape( 'if the `title` option is `true` and insufficient package meta information is provided, the returned instance does not set the process title', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'title': true,
		'pkg': {}
	};
	ctor( opts );

	t.strictEqual( proc.title, '', 'does not set the process title' );
	t.end();
});

tape( 'if the `title` option is a string, the returned instance sets the process title to the specified string', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'title': 'boop',
		'pkg': {
			'name': 'beep',
			'version': '0.0.0'
		}
	};
	ctor( opts );

	t.strictEqual( proc.title, 'boop', 'sets the process title' );
	t.end();
});

tape( 'if the `title` option is `false`, the returned instance does not set the process title', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'title': false,
		'pkg': {
			'name': 'beep',
			'version': '0.0.0'
		}
	};
	ctor( opts );

	t.strictEqual( proc.title, '', 'does not set the process title' );
	t.end();
});

tape( 'if the `updates` option is `true` and package meta data is provided, the returned instance checks for available updates in the package registry', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'update-notifier': notifier,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'pkg': {
			'name': '@stdlib/tools/cli',
			'version': '0.0.0'
		},
		'updates': true
	};
	ctor( opts );

	function notifier() {
		return {
			'notify': notify
		};
	}

	function notify() {
		t.ok( true, 'checks registry' );
		t.end();
	}
});

tape( 'if the `updates` option is `true` and insufficient package meta data is provided, the returned instance does not check for available updates in the package registry (no pkg name)', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'update-notifier': notifier,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'pkg': {
			'version': '0.0.0'
		},
		'updates': true
	};
	ctor( opts );

	t.ok( true, 'is ok' );
	t.end();

	function notifier() {
		return {
			'notify': notify
		};
	}

	function notify() {
		t.fail( 'should never be called' );
	}
});

tape( 'if the `updates` option is `true` and insufficient package meta data is provided, the returned instance does not check for available updates in the package registry (no pkg version)', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'update-notifier': notifier,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'pkg': {
			'name': '@stdlib/tools/cli'
		},
		'updates': true
	};
	ctor( opts );

	t.ok( true, 'is ok' );
	t.end();

	function notifier() {
		return {
			'notify': notify
		};
	}

	function notify() {
		t.fail( 'should never be called' );
	}
});

tape( 'if the `updates` option is `true` and insufficient package meta data is provided, the returned instance does not check for available updates in the package registry (no pkg data)', function test( t ) {
	var ctor;
	var proc;
	var opts;

	proc = {
		'exit': noop,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'update-notifier': notifier,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'updates': true
	};
	ctor( opts );

	t.ok( true, 'is ok' );
	t.end();

	function notifier() {
		return {
			'notify': notify
		};
	}

	function notify() {
		t.fail( 'should never be called' );
	}
});

tape( 'the instance has a method which returns command-line arguments', function test( t ) {
	var expected;
	var actual;
	var argv;
	var ctor;
	var proc;
	var opts;
	var cli;

	proc = {
		'exit': noop,
		'title': ''
	};
	argv = [
		'/usr/local/bin/node',
		'foo.js',
		'foo',
		'bar',
		'-a=b',
		'--c',
		'd',
		'baz'
	];
	argv[ '@noCallThru' ] = true;

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': argv
	});

	opts = {
		'updates': false
	};
	cli = ctor( opts );

	expected = [ 'foo', 'bar', 'baz' ];
	actual = cli.args();

	t.deepEqual( actual, expected, 'returns expected values' );
	t.end();
});

tape( 'the instance has a method which returns command-line flags', function test( t ) {
	var expected;
	var actual;
	var argv;
	var ctor;
	var proc;
	var opts;
	var cli;

	proc = {
		'exit': noop,
		'title': ''
	};
	argv = [
		'/usr/local/bin/node',
		'foo.js',
		'foo',
		'bar',
		'-a=b',
		'--c',
		'd',
		'--e',
		'-f',
		'-ghi',
		'--beep',
		'boop',
		'baz'
	];
	argv[ '@noCallThru' ] = true;

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': argv
	});

	opts = {
		'updates': false
	};
	cli = ctor( opts );

	expected = {
		'a': 'b',
		'c': 'd',
		'e': true,
		'f': true,
		'g': true,
		'h': true,
		'i': true,
		'beep': 'boop'
	};
	actual = cli.flags();

	t.deepEqual( actual, expected, 'returns expected values' );
	t.end();
});

tape( 'the constructor supports providing an array of command-line arguments', function test( t ) {
	var expected;
	var actual;
	var argv;
	var ctor;
	var proc;
	var opts;
	var cli;

	proc = {
		'exit': noop,
		'title': ''
	};
	argv = [
		'/usr/local/bin/node',
		'foo.js',
		'foo',
		'bar',
		'-a=b',
		'--c',
		'd',
		'--e',
		'-f',
		'-ghi',
		'--beep',
		'boop',
		'baz'
	];
	argv[ '@noCallThru' ] = true;

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'updates': false,
		'argv': argv
	};
	cli = ctor( opts );

	expected = {
		'a': 'b',
		'c': 'd',
		'e': true,
		'f': true,
		'g': true,
		'h': true,
		'i': true,
		'beep': 'boop'
	};
	actual = cli.flags();

	t.deepEqual( actual, expected, 'returns expected flags' );

	expected = [
		'foo',
		'bar',
		'baz'
	];
	actual = cli.args();

	t.deepEqual( actual, expected, 'returns expected arguments' );
	t.end();
});

tape( 'if the flag `-h` is set and is an alias for `--help`, the instance prints help text to `stderr` and exits', opts, function test( t ) {
	var expected;
	var actual;
	var fpath;
	var fopts;
	var ctor;
	var proc;
	var opts;
	var log;

	proc = {
		'exit': exit,
		'title': ''
	};
	log = {
		'error': write
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'./console.js': log,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': [ '/usr/local/bin/node', 'foo.js', '-h' ]
	});

	fpath = join( __dirname, 'fixtures', 'usage.txt' );
	fopts = {
		'encoding': 'utf8'
	};
	expected = readFileSync( fpath, fopts );

	actual = '';

	opts = {
		'updates': false,
		'help': expected,
		'options': {
			'boolean': [
				'help',
				'version'
			],
			'alias': {
				'help': [
					'h'
				],
				'version': [
					'V'
				]
			}
		}
	};
	ctor( opts );

	function write( data ) {
		actual += data.toString();
	}

	function exit( code ) {
		t.strictEqual( actual, expected, 'writes expected text' );
		t.strictEqual( code, 0, 'sets exit code to 0' );
		t.end();
	}
});

tape( 'if the flag `-h` is set and is an alias for `--help`, the instance prints help text to `stderr` and exits (browser)', function test( t ) {
	var expected;
	var actual;
	var ctor;
	var proc;
	var opts;
	var log;

	proc = {
		'exit': exit,
		'title': ''
	};
	log = {
		'error': write
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'./console.js': log,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': [ '/usr/local/bin/node', 'foo.js', '-h' ]
	});

	expected = 'Usage: boop [options] <beep>';
	actual = '';

	opts = {
		'updates': false,
		'help': expected,
		'options': {
			'boolean': [
				'help',
				'version'
			],
			'alias': {
				'help': [
					'h'
				],
				'version': [
					'V'
				]
			}
		}
	};
	ctor( opts );

	function write( data ) {
		actual += data.toString();
	}

	function exit( code ) {
		t.strictEqual( actual, expected, 'writes expected text' );
		t.strictEqual( code, 0, 'sets exit code to 0' );
		t.end();
	}
});

tape( 'if the flag `--help` is set, the instance prints help text to `stderr` and exits', opts, function test( t ) {
	var expected;
	var actual;
	var fpath;
	var fopts;
	var ctor;
	var proc;
	var opts;
	var log;

	proc = {
		'exit': exit,
		'title': ''
	};
	log = {
		'error': write
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'./console.js': log,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': [ '/usr/local/bin/node', 'foo.js', '--help' ]
	});

	fpath = join( __dirname, 'fixtures', 'usage.txt' );
	fopts = {
		'encoding': 'utf8'
	};
	expected = readFileSync( fpath, fopts );

	actual = '';

	opts = {
		'updates': false,
		'help': expected,
		'options': {
			'boolean': [
				'help',
				'version'
			]
		}
	};
	ctor( opts );

	function write( data ) {
		actual += data.toString();
	}

	function exit( code ) {
		t.strictEqual( actual, expected, 'writes expected text' );
		t.strictEqual( code, 0, 'sets exit code to 0' );
		t.end();
	}
});

tape( 'if the flag `--help` is set, the instance prints help text to `stderr` and exits (browser)', function test( t ) {
	var expected;
	var actual;
	var ctor;
	var proc;
	var opts;
	var log;

	proc = {
		'exit': exit,
		'title': ''
	};
	log = {
		'error': write
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'./console.js': log,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': [ '/usr/local/bin/node', 'foo.js', '--help' ]
	});

	expected = 'Usage: boop [options] <beep>';

	actual = '';

	opts = {
		'updates': false,
		'help': expected,
		'options': {
			'boolean': [
				'help',
				'version'
			]
		}
	};
	ctor( opts );

	function write( data ) {
		actual += data.toString();
	}

	function exit( code ) {
		t.strictEqual( actual, expected, 'writes expected text' );
		t.strictEqual( code, 0, 'sets exit code to 0' );
		t.end();
	}
});

tape( 'if the flag `-V` is set and is an alias for `--version`, the instance prints the version to `stderr` and exits', function test( t ) {
	var expected;
	var actual;
	var ctor;
	var proc;
	var opts;
	var log;

	proc = {
		'exit': exit,
		'title': ''
	};
	log = {
		'error': write
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'./console.js': log,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': [ '/usr/local/bin/node', 'foo.js', '-V' ]
	});

	expected = '1.1.1';
	actual = '';

	opts = {
		'version': '1.1.1',
		'updates': false,
		'options': {
			'boolean': [
				'help',
				'version'
			],
			'alias': {
				'help': [
					'h'
				],
				'version': [
					'V'
				]
			}
		}
	};
	ctor( opts );

	function write( data ) {
		actual += data.toString();
	}

	function exit( code ) {
		t.strictEqual( actual, expected, 'writes expected text' );
		t.strictEqual( code, 0, 'sets exit code to 0' );
		t.end();
	}
});

tape( 'if the flag `--version` is set, the instance prints the version to `stderr` and exits', function test( t ) {
	var expected;
	var actual;
	var ctor;
	var proc;
	var opts;
	var log;

	proc = {
		'exit': exit,
		'title': ''
	};
	log = {
		'error': write
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'./console.js': log,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr(),
		'@stdlib/utils/argv': [ '/usr/local/bin/node', 'foo.js', '--version' ]
	});

	expected = '1.1.1';
	actual = '';

	opts = {
		'version': '1.1.1',
		'updates': false,
		'options': {
			'boolean': [
				'help',
				'version'
			],
			'alias': {
				'help': [
					'h'
				],
				'version': [
					'V'
				]
			}
		}
	};
	ctor( opts );

	function write( data ) {
		actual += data.toString();
	}

	function exit( code ) {
		t.strictEqual( actual, expected, 'writes expected text' );
		t.strictEqual( code, 0, 'sets exit code to 0' );
		t.end();
	}
});

tape( 'the instance provides a method to forcefully exit and provide an exit code', function test( t ) {
	var ctor;
	var proc;
	var opts;
	var cli;

	proc = {
		'exit': exit,
		'title': ''
	};

	ctor = proxyquire( './../lib/cli.js', {
		'./process.js': proc,
		'@stdlib/streams/base/stdout': stdout(),
		'@stdlib/streams/base/stderr': stderr()
	});

	opts = {
		'updates': false
	};
	cli = ctor( opts );
	cli.exit( 5 );

	function exit( code ) {
		t.strictEqual( code, 5, 'is provided expected value' );
		t.end();
	}
});
