'use strict';

// MODULES //

var ndarray = require( '@stdlib/ndarray' );
var linspace = require( '@stdlib/math/utils/linspace' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isNumericArray = require( '@stdlib/assert/is-numeric-array' );
var isMatrixLike = require( '@stdlib/assert/is-matrix-like' );
var pickBandwidth = require( './pick-bandwidth.js' );
var validate = require( './validate.js' );
var ndarrayLike = require( './nd-array-like.js' );
var min = require( './min.js' );
var max = require( './max.js' );
var gaussian = require( './gaussian.js' );


// MAIN //

/**
* Computes 2-dimensional normal kernel density estimate.
*
* @param {NumericArray} x - array of X values
* @param {NumericArray} y - array of Y values
* @param {Options} [options] - function options
* @param {NumericArray} [options.h] - array of length 2 containing the bandwidth values for X and Y respectively.
* @param {number} [options.n] - The number of partitions on the X and Y axises
* @param {number} [options.xMin] - A number indicating the lower limit of X
* @param {number} [options.xMax] - A number indicating the upper limit of X
* @param {number} [options.yMin] - A number indicating the lower limit of Y
* @param {number} [options.yMax] - A number indicating the upper limit of Y
* @param {(string | Function)} [options.kernel] - Either a string or function to specify the kernel
* @throws {Error} when supplying matrix or ndarray there can be at most 2 parameters
* @throws {TypeError} first argument must be an array or matrixLike
* @throws {TypeError} second argument must be an array
* @throws {Error} first and second arguments must be same length
* @throws {Error} argument length must not exceed a certain value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} x min must be strictly less than x max
* @throws {RangeError} y min must be strictly less than y max
* @returns {Object} Object containing the gx, gy and z estimates
*
* @example
* var x = [ 0.6333, 0.8643, 1.0952, 1.3262, 1.5571, 1.7881, 2.019, 2.25, 2.481, 2.7119 ];
* var y = [ -0.0468, 0.8012, 1.6492, 2.4973, 3.3454, 4.1934, 5.0415, 5.8896, 6.7376, 7.5857 ];
* var out = kde2d( x, y );
*/
function kde2d() {
	var kernelFunction;
	var inputArgMax; // number of arguments by case
	var zScoreX;
	var zScoreY;
	var gridX;
	var gridY;
	var xMin;
	var xMax;
	var yMin;
	var yMax;
	var xVal; // For gridspace loop
	var yVal; // For gridspace loop
	var subX;
	var subY;
	var opts;
	var arr;
	var err;
	var ans;
	var out;
	var gx;
	var gy;
	var hX;
	var hY;
	var ix;
	var iy;
	var x;
	var y;
	var i;
	var n;
	var z;

	opts = {};

	if (isMatrixLike(arguments[0])) {
		// Case of ndarray, opts
		arr = arguments[0];
		inputArgMax = 1;
	} else {
		x = arguments[0];
		y = arguments[1];

		if ( !isNumericArray(x) ) {
			throw new TypeError('x must be a non-empty numeric array');
		}

		if ( !isNumericArray(y) ) {
			throw new TypeError('y must be a non-empty numeric array');
		}

		if (x.length !== y.length) {
			throw new Error('x and y must have the same length');
		}

		arr = ndarrayLike(x, y);
		inputArgMax = 2;
	}

	if (arguments.length > inputArgMax + 1) {
		throw new Error('Maximum number of parameters exceeded');
	}

	// Otherwise we know X, Y

	if (arguments.length > inputArgMax) {
		err = validate(opts, arguments[inputArgMax]);
		if ( err ) {
			throw err;
		}
	}

	if (opts.h) {
		hX = opts.h[0];
		hY = opts.h[1];
	} else {
		hX = pickBandwidth(arr, 0);
		hY = pickBandwidth(arr, 1);
	}

	n = opts.n || 25; // Default

	// Now we check for x/y min/max
	xMin = opts.xMin || min(arr, 0, arr.shape[0]);
	xMax = opts.xMax || max(arr, 0, arr.shape[0]);
	yMin = opts.yMin || min(arr, 1, arr.shape[0]);
	yMax = opts.yMax || max(arr, 1, arr.shape[0]);

	// Check the min and max
	if (xMin >= xMax) {
		throw new RangeError('X min must be strictly less than max');
	}

	if (yMin >= yMax) {
		throw new RangeError('Y min must be strictly less than max');
	}

	kernelFunction = opts.kernel || gaussian;

	// Make the variables
	z = ndarray({
		'shape': [n, n]
	} );

	// Now make the grid
	gridX = linspace(xMin, xMax, n);
	gridY = linspace(yMin, yMax, n);

	// Loop throufh x and y indices
	for ( ix = 0; ix < gridX.length; ix++ ) {
		gx = gridX[ix];
		for ( iy = 0; iy < gridY.length; iy++ ) {
			gy = gridY[iy];

			ans = 0;

			// Now loop through the data
			for ( i = 0; i < arr.shape[0]; i++ ) {
				xVal = arr.get(i, 0);
				yVal = arr.get(i, 1);

				zScoreX = ((xVal - gx) / hX);
				zScoreY = ((yVal - gy) / hY);

				subX = (1 / hX) * kernelFunction(zScoreX);
				subY = (1 / hY) * kernelFunction(zScoreY);
				ans += (subX * subY);
			}
			// Place it in z
			z.set(ix, iy, ans / arr.shape[0]);
		}
	}

	// Make the return object
	out = {};
	setReadOnly( out, 'gridX', gridX );
	setReadOnly( out, 'gridY', gridY );
	setReadOnly( out, 'z', z );

	return out;
}


// EXPORTS //

module.exports = kde2d;
