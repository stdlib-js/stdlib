/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Add each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
*/
#include <stdint.h>
#include <nan.h>
#include "stdlib/ndarray/base/bytes_per_element.h"
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/strided_binary.h"

/**
* Add-on namespace.
*/
namespace addon_strided_add {

	using Nan::FunctionCallbackInfo;
	using Nan::TypedArrayContents;
	using Nan::ThrowTypeError;
	using Nan::ThrowError;
	using v8::Local;
	using v8::Value;

	/**
	* Adds two doubles.
	*
	* @private
	* @param x  first double
	* @param y  second double
	* @return   sum
	*/
	double add( double x, double y ) {
		return x + y;
	}

	/**
	* Returns a typed array data type.
	*
	* @private
	* @param x  typed array
	* @return   data type
	*/
	enum STDLIB_NDARRAY_DTYPE typed_array_data_type( Local<Value> x ) {
		if ( x->IsFloat64Array() ) {
			return STDLIB_NDARRAY_FLOAT64;
		}
		if ( x->IsFloat32Array() ) {
			return STDLIB_NDARRAY_FLOAT32;
		}
		if ( x->IsInt32Array() ) {
			return STDLIB_NDARRAY_INT32;
		}
		if ( x->IsUint32Array() ) {
			return STDLIB_NDARRAY_UINT32;
		}
		if ( x->IsInt16Array() ) {
			return STDLIB_NDARRAY_INT16;
		}
		if ( x->IsUint16Array() ) {
			return STDLIB_NDARRAY_UINT16;
		}
		if ( x->IsInt8Array() ) {
			return STDLIB_NDARRAY_INT8;
		}
		if ( x->IsUint8Array() ) {
			return STDLIB_NDARRAY_UINT8;
		}
		return STDLIB_NDARRAY_UINT8; // Uint8ClampedArray
	}

	/**
	* Validates, extracts, and transforms arguments provided to the main entry point for a Node.js add-on to native C types.
	*
	* ## Notes
	*
	* -   The function assumes the following argument order:
	*
	*     ```text
	*     [ N, ia1, is1, ia2, is2, ..., oa1, os1, oa2, os2, ... ]
	*     ```
	*
	*     where
	*
	*     -   `N` is the number of elements over which to iterate
	*     -   `ia#` is an input strided array
	*     -   `is#` is a corresponding input strided array stride (in units of elements)
	*     -   `oa#` is an output strided array
	*     -   `os#` is a corresponding output strided array stride (in units of elements)
	*
	* -   We **assume** no more than `64` input strided array arguments, which seems a reasonable assumption, as strided array functions which operate over `65` or more input strided arrays are **exceedingly** unlikely (most strided array functions operate on 3 or fewer input strided arrays).
	*
	* @private
	* @param info     arguments
	* @param nargs    total number of arguments
	* @param nin      number of input strided array arguments
	* @param nout     number of output strided array arguments
	* @param arrays   destination array containing pointers to both input and output strided byte arrays
	* @param shape    destination array containing the array shape (dimensions)
	* @param strides  destination array containing array strides (in bytes) for each strided array
	* @param types    destination array containing strided array argument data types
	* @throws         must provide expected number of input arguments
	* @throws         stride arguments must be numbers
	* @throws         input strided array arguments must be either typed arrays or scalars
	* @throws         output strided array arguments must be typed arrays
	* @throws         must provide at least one input strided array
	* @return         number of scalar strided "array" arguments
	*/
	int64_t stdlib_nan_addon_strided_array_function_arguments( const FunctionCallbackInfo<Value>& info, const int64_t nargs, const int64_t nin, const int64_t nout, uint8_t *arrays[], int64_t *shape, int64_t *strides, enum STDLIB_NDARRAY_DTYPE *types ) {
		int64_t nsargs;
		int64_t sargs;
		int64_t iout;
		int64_t i;
		int64_t j;

		// Compute the index of the first output strided array argument:
		iout = ( nin*2 ) + 1;

		// Initialize variables used to track scalar input arguments:
		nsargs = 0;
		sargs = 0;

		if ( info.Length() != nargs ) {
			ThrowError( "invalid invocation. Incorrect number of arguments." );
			return -1;
		}

		// The first argument is always the number of elements over which to iterate...
		if ( !info[ 0 ]->IsNumber() ) {
			ThrowTypeError( "invalid input argument. First argument must be a number." );
			return -1;
		} else {
			shape[ 0 ] = static_cast<int64_t>( info[ 0 ]->IntegerValue() );
		}

		// Stride arguments for both input and output strided arrays are every other argument beginning from the third argument...
		for ( i = 2; i < nargs; i += 2 ) {
			if ( !info[ i ]->IsNumber() ) {
				ThrowTypeError( "invalid input argument. Stride argument must be a number." );
				return -1;
			}
			j = ( i-2 ) / 2;
			strides[ j ] = static_cast<int64_t>( info[ i ]->IntegerValue() );
		}

#if defined(V8_MAJOR_VERSION) && ( V8_MAJOR_VERSION > 4 || ( V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3 ) )

		// Input strided array arguments are every other argument beginning from the second argument...
		for ( i = 1; i < iout; i += 2 ) {
			j = ( i-1 ) / 2;
			if ( info[ i ]->IsArrayBufferView() ) {
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;
				types[ j ] = typed_array_data_type( info[ i ] );
				strides[ j ] *= stdlib_ndarray_bytes_per_element( types[ j ] );
			} else if ( info[ i ]->IsNumber() ) {
				sargs |= (1<<j);
				nsargs += 1;
			} else {
				ThrowTypeError( "invalid input argument. Input strided array argument must be a typed array or scalar." );
				return -1;
			}
		}

		// Output strided array arguments are every other argument beginning from the argument following the last input strided array stride argument...
		for ( i = iout; i < nargs; i += 2 ) {
			j = ( i-1 ) / 2;
			if ( !info[ i ]->IsArrayBufferView() ) {
				ThrowTypeError( "invalid input argument. Output strided array arguments must be typed arrays." );
				return -1;
			} else {
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;
				types[ j ] = typed_array_data_type( info[ i ] );
				strides[ j ] *= stdlib_ndarray_bytes_per_element( types[ j ] );
			}
		}

#else

		// TODO: add support for older Node versions (type verification and strides; see https://github.com/nodejs/node/blob/v0.10.39-release/src/v8_typed_array.cc and https://github.com/nodejs/nan/blob/master/nan_typedarray_contents.h)

		// Input strided array arguments are every other argument beginning from the second argument...
		for ( i = 1; i < iout; i += 2 ) {
			j = ( i-1 ) / 2;
			if ( info[ i ]->IsNumber() ) {
				sargs |= (1<<j);
				nsargs += 1;
			} else if ( info[ i ]->IsObject() && !info[ i ]->IsNull() ) {
				// Assume a typed array:
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;

				types[ j ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type (will require determining the typed array "class"; see https://github.com/nodejs/node/blob/v0.10.39-release/src/v8_typed_array.cc#L462)
				strides[ j ] *= 8; // TODO: compute based on data type (or glean directly from the typed array instance)
			} else {
				ThrowTypeError( "invalid input argument. Input strided array argument must be a typed array or scalar." );
				return -1;
			}
		}

		// Output strided array arguments are every other argument beginning from the argument following the last input strided array stride argument...
		for ( i = iout; i < nargs; i += 2 ) {
			j = ( i-1 ) / 2;
			if ( info[ i ]->IsObject() && !info[ i ]->IsNull() ) {
				// Assume a typed array:
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;

				types[ j ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type (will require determining the typed array "class"; see https://github.com/nodejs/node/blob/v0.10.39-release/src/v8_typed_array.cc#L462)
				strides[ j ] *= 8; // TODO: compute based on data type (or glean directly from typed array instance)
			} else {
				ThrowTypeError( "invalid input argument. Output strided array arguments must be typed arrays." );
				return -1;
			}
		}

#endif

		// Check if we have been provided only scalar input arguments...
		if ( nin > 0 && nsargs == nin ) {
			ThrowError( "invalid input arguments. Must provide at least one input strided array argument." );
			return -1;
		}
		return nsargs;
	}

	/**
	* Adds each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
	*
	* When called from JavaScript, the function expects the following arguments:
	*
	* * __N__: number of elements.
	* * __X__: input typed array.
	* * __strideX__: `X` stride length.
	* * __Y__: input typed array.
	* * __strideY__: `Y` typed array stride length.
	* * __Z__: destination typed array.
	* * __strideZ__: destination typed array stride length.
	*
	* @param info   arguments
	*/
	void node_add( const FunctionCallbackInfo<Value>& info ) {
		enum STDLIB_NDARRAY_DTYPE types[3];
		uint8_t *arrays[3];
		int64_t strides[3];
		int64_t shape[1];
		int64_t nsargs;
		int64_t nargs;
		int64_t nout;
		int64_t nin;

		// Total number of input arguments:
		nargs = 7;

		// Number of input and output strided array arguments:
		nin = 2;
		nout = 1;

		// Process the provided arguments:
		nsargs = stdlib_nan_addon_strided_array_function_arguments( info, nargs, nin, nout, arrays, shape, strides, types );
		if ( nsargs < 0 ) {
			return;
		}

		// Broadcasting of scalar arguments...
		if ( nsargs > 0 ) {
			// Create an array having the closest "compatible" type...
			// arrays[ 0 ] = broadcast( static_cast<double>( info[ 1 ]->NumberValue() ), types[ 0 ] );
		}
		// Perform addition:
		stdlib_strided_dd_d( arrays, shape, strides, (void *)add );
	}

	NAN_MODULE_INIT( Init ) {
		Nan::Export( target, "add", node_add );
	}

	NODE_MODULE( addon, Init )
} // end namespace addon_strided_add
