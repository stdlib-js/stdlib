/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Functionality for creating ndarrays.
*/
#include <stdlib.h>
#include <stdint.h>
#include "stdlib/ndarray.h"
#include "stdlib/strided_dtypes.h"

/**
* Returns the number of elements in an ndarray.
*
* @param ndims  number of dimensions
* @param shape  array shape (dimensions)
* @return       number of elements
*
* @example
* #include "stdlib/ndarray.h"
*
* uint64_t ndims = 2;
* int64_t shape = { 10, 8 };
*
* uint64_t n = ndarray_numel( ndims, shape );
* // returns 80
*/
uint64_t ndarray_numel( uint64_t ndims, int64_t *shape ) {
	uint64_t n;
	uint64_t i;

	if ( ndims == 0 ) {
		return 0;
	}
	n = 1;
	for ( i = 0; i < ndims; i++ ) {
		n *= shape[ i ];
	}
	return n;
}

/**
* Returns the number of bytes per element for a given data type.
*
* @param dtype  data type (number)
* @return       number of bytes per element
*
* @example
* #include "stdlib/ndarray.h"
* #include "stdlib/strided_dtypes.h"
*
* uint8_t nbytes = ndarray_bytes_per_element( STDLIB_STRIDED_FLOAT64 );
* // returns 8
*/
uint8_t ndarray_bytes_per_element( enum STDLIB_STRIDED_DTYPES dtype ) {
	switch ( dtype ) {
	case STDLIB_STRIDED_FLOAT64:
		return STDLIB_STRIDED_FLOAT64_NBYTES;
	case STDLIB_STRIDED_FLOAT32:
		return STDLIB_STRIDED_FLOAT32_NBYTES;
	case STDLIB_STRIDED_FLOAT16:
		return STDLIB_STRIDED_FLOAT16_NBYTES;
	case STDLIB_STRIDED_FLOAT128:
		return STDLIB_STRIDED_FLOAT128_NBYTES;
	case STDLIB_STRIDED_BOOL:
		return STDLIB_STRIDED_BOOL_NBYTES;
	case STDLIB_STRIDED_INT8:
		return STDLIB_STRIDED_INT8_NBYTES;
	case STDLIB_STRIDED_UINT8:
		return STDLIB_STRIDED_UINT8_NBYTES;
	case STDLIB_STRIDED_INT16:
		return STDLIB_STRIDED_INT16_NBYTES;
	case STDLIB_STRIDED_UINT16:
		return STDLIB_STRIDED_UINT16_NBYTES;
	case STDLIB_STRIDED_INT32:
		return STDLIB_STRIDED_INT32_NBYTES;
	case STDLIB_STRIDED_UINT32:
		return STDLIB_STRIDED_UINT32_NBYTES;
	case STDLIB_STRIDED_INT64:
		return STDLIB_STRIDED_INT64_NBYTES;
	case STDLIB_STRIDED_UINT64:
		return STDLIB_STRIDED_UINT64_NBYTES;
	case STDLIB_STRIDED_INT128:
		return STDLIB_STRIDED_INT128_NBYTES;
	case STDLIB_STRIDED_UINT128:
		return STDLIB_STRIDED_UINT128_NBYTES;
	case STDLIB_STRIDED_INT256:
		return STDLIB_STRIDED_INT256_NBYTES;
	case STDLIB_STRIDED_UINT256:
		return STDLIB_STRIDED_UINT256_NBYTES;
	}
}

/**
* Returns the one letter character abbreviation for a given data type.
*
* @param dtype  data type (number)
* @return       one letter character abbreviation
*
* @example
* #include "stdlib/ndarray.h"
* #include "stdlib/strided_dtypes.h"
*
* int ltr = ndarray_dtype_char( STDLIB_STRIDED_FLOAT64 );
* // returns 100
*/
int ndarray_dtype_char( enum STDLIB_STRIDED_DTYPES dtype ) {
	switch ( dtype ) {
	case STDLIB_STRIDED_FLOAT64:
		return STDLIB_STRIDED_FLOAT64_CHAR;
	case STDLIB_STRIDED_FLOAT32:
		return STDLIB_STRIDED_FLOAT32_CHAR;
	case STDLIB_STRIDED_FLOAT16:
		return STDLIB_STRIDED_FLOAT16_CHAR;
	case STDLIB_STRIDED_FLOAT128:
		return STDLIB_STRIDED_FLOAT128_CHAR;
	case STDLIB_STRIDED_BOOL:
		return STDLIB_STRIDED_BOOL_CHAR;
	case STDLIB_STRIDED_INT8:
		return STDLIB_STRIDED_INT8_CHAR;
	case STDLIB_STRIDED_UINT8:
		return STDLIB_STRIDED_UINT8_CHAR;
	case STDLIB_STRIDED_INT16:
		return STDLIB_STRIDED_INT16_CHAR;
	case STDLIB_STRIDED_UINT16:
		return STDLIB_STRIDED_UINT16_CHAR;
	case STDLIB_STRIDED_INT32:
		return STDLIB_STRIDED_INT32_CHAR;
	case STDLIB_STRIDED_UINT32:
		return STDLIB_STRIDED_UINT32_CHAR;
	case STDLIB_STRIDED_INT64:
		return STDLIB_STRIDED_INT64_CHAR;
	case STDLIB_STRIDED_UINT64:
		return STDLIB_STRIDED_UINT64_CHAR;
	case STDLIB_STRIDED_INT128:
		return STDLIB_STRIDED_INT128_CHAR;
	case STDLIB_STRIDED_UINT128:
		return STDLIB_STRIDED_UINT128_CHAR;
	case STDLIB_STRIDED_INT256:
		return STDLIB_STRIDED_INT256_CHAR;
	case STDLIB_STRIDED_UINT256:
		return STDLIB_STRIDED_UINT256_CHAR;
	}
}

/**
* Returns a pointer to a dynamically allocated ndarray.
*
* ## Notes
*
* -   The user is responsible for freeing the allocated memory.
*
* @param data     pointer to the underlying byte array
* @param ndims    number of dimensions
* @param shape    array shape (dimensions)
* @param strides  array strides (in bytes)
* @param offset   byte offset specifying the location of the first element
* @param order    specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param dtype    data type
* @return         pointer to a dynamically allocated ndarray or, if unable to allocate memory, a null pointer
*
* @example
* #include <stdlib.h>
* #include <stdio.h>
* #include <stdint.h>
* #include "stdlib/ndarray.h"
* #include "stdlib/ndarray_order.h"
* #include "stdlib/strided_dtypes.h"
*
* // Create an underlying byte array:
* uint8_t buffer[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
*
* // Specify the underlying data type:
* enum STDLIB_STRIDED_DTYPES dtype = STDLIB_STRIDED_FLOAT64;
*
* // Specify the number of array dimensions:
* uint64_t ndims = 1;
*
* // Specify the array shape:
* int64_t shape[] = { 3 }; // vector consisting of 3 doubles
*
* // Specify the array strides:
* int64_t strides[] = { 8 }; // 8 bytes per double
*
* // Specify the byte offset:
* uint64_t offset = 0;
*
* // Specify the array order (note: this does not matter for a 1-dimensional array):
* enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;
*
* // Create an `ndarray`:
* struct ndarray *x = ndarray_constructor( buffer, ndims, shape, strides, offset, order, dtype );
* if ( x == NULL ) {
*     printf( "Error allocating memory.\n" );
*     exit( 1 );
* }
*
* // Free allocated memory:
* free( x );
*/
struct ndarray * ndarray_constructor( uint8_t *data, uint64_t ndims, int64_t *shape, int64_t *strides, uint64_t offset, enum STDLIB_NDARRAY_ORDER order, enum STDLIB_STRIDED_DTYPES dtype ) {
	struct ndarray *arr = malloc( sizeof( struct ndarray ) );
	if ( arr == NULL ) {
		return NULL;
	}
	arr->data = data;
	arr->dtype = dtype;
	arr->ndims = ndims;
	arr->offset = offset;
	arr->order = order;
	arr->shape = shape;
	arr->strides = strides;

	arr->BYTES_PER_ELEMENT = ndarray_bytes_per_element( dtype );
	arr->length = ndarray_numel( ndims, shape );
	arr->byteLength = (arr->length) * (arr->BYTES_PER_ELEMENT);

	arr->ltr = ndarray_dtype_char( dtype );

	// TODO: compute flags

	// TODO: determine iteration order (see base JS implementation)

	return arr;
}
