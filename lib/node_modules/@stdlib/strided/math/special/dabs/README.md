<!--

@license Apache-2.0

Copyright (c) 2018 The Stdlib Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-->

# dabs

> Compute the [absolute value][@stdlib/math/base/special/abs] for each element in a strided array.

<section class="intro">

</section>

<!-- /.intro -->

<section class="usage">

## Usage

```javascript
var dabs = require( '@stdlib/strided/math/special/dabs' );
```

#### dabs( N, x, strideX, y, strideY )

Computes the [absolute value][@stdlib/math/base/special/abs] for each element in `x` and assigns the result to an element in `y`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );

// Compute the absolute values in-place:
dabs( x.length, x, 1, x, 1 );
// x => <Float64Array>[ 2.0, 1.0, 3.0, 5.0, 4.0, 0.0, 1.0, 3.0 ]
```

The function accepts the following arguments:

-   **N**: number of elements to sum.
-   **x**: input [`Float64Array`][@stdlib/array/float64].
-   **strideX**: index increment for `x`.
-   **y**: output [`Float64Array`][@stdlib/array/float64].
-   **strideY**: index increment for `y`.

The `N` and `stride` parameters determine which elements in `x` and `y` are accessed at runtime. For example, to compute the [absolute value][@stdlib/math/base/special/abs] for every other value in `x` and to set the first `N` elements of `y` in reverse order,

```javascript
var Float64Array = require( '@stdlib/array/float64' );
var floor = require( '@stdlib/math/base/special/floor' );

var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0, -6.0 ] );
var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );

var N = floor( x.length / 2 );

dabs( N, x, 2, y, -1 );
// y => <Float64Array>[ 5.0, 3.0, 1.0, 0.0, 0.0, 0.0 ]
```

Note that indexing is relative to the first index. To introduce an offset, use [`typed array`][@stdlib/array/float64] views.

```javascript
var Float64Array = require( '@stdlib/array/float64' );
var floor = require( '@stdlib/math/base/special/floor' );

// Initial arrays...
var x0 = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0, -6.0 ] );
var y0 = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );

// Create offset views...
var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 ); // start at 2nd element
var y1 = new Float64Array( y0.buffer, y0.BYTES_PER_ELEMENT*3 ); // start at 4th element

var N = floor( x0.length / 2 );

dabs( N, x1, -2, y1, 1 );
// y0 => <Float64Array>[ 0.0, 0.0, 0.0, 6.0, 5.0, 4.0 ]
```

#### dabs.ndarray( N, x, strideX, offsetX, y, strideY, offsetY )

Computes the [absolute value][@stdlib/math/base/special/abs] for each element in `x` and assigns the result to an element in `y`, using alternative indexing semantics.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );
var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );

dabs.ndarray( x.length, x, 1, 0, y, 1, 0 );
// y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]
```

The function accepts the following additional arguments:

-   **offsetX**: starting index for `x`.
-   **offsetY**: starting index for `y`.

While [`typed array`][@stdlib/array/float64] views mandate a view offset based on the underlying `buffer`, the `offsetX` and `offsetY` parameters support indexing semantics based on starting indices. For example, to compute the [absolute value][@stdlib/math/base/special/abs] for every other value in `x` starting from the second value and to set the last `N` elements in `y` where `x[i] -> y[n]`, `x[i+2] -> y[n-1]`,...,

```javascript
var Float64Array = require( '@stdlib/array/float64' );
var floor = require( '@stdlib/math/base/special/floor' );

var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0, -6.0 ] );
var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );

var N = floor( x.length / 2 );

dabs.ndarray( N, x, 2, 1, y, -1, y.length-1 );
// y => <Float64Array>[ 0.0, 0.0, 0.0, 6.0, 4.0, 2.0 ]
```

#### dabs.wasm( \[options] )

Returns a memory managed function to compute the [absolute value][@stdlib/math/base/special/abs].

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = dabs.wasm();

// Number of data elements:
var N = 5;

// Allocate space on the heap:
var xbytes = wasm.malloc( N * 8 ); // 8 bytes per double
var ybytes = wasm.malloc( N * 8 );

// Create Float64Array views:
var x = new Float64Array( xbytes.buffer, xbytes.byteOffset, N );
var y = new Float64Array( ybytes.buffer, ybytes.byteOffset, N );

// Copy data to the heap:
x.set( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );
y.set( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );

// Compute absolute values:
wasm( N, xbytes, 1, ybytes, 1 );
// y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]

// Extract the results from the heap:
var r = new Float64Array( y.length );
var i;
for ( i = 0; i < y.length; i++ ) {
    r[ i ] = y[ i ];
}

// Free the memory:
wasm.free( xbytes );
wasm.free( ybytes );
```

For externally defined [typed arrays][@stdlib/array/float64], data must be copied to the heap.

```javascript
var Uint8Array = require( '@stdlib/array/uint8' );
var Float64Array = require( '@stdlib/array/float64' );

var wasm = dabs.wasm();

// Number of data elements:
var N = 5;

// Externally defined data arrays:
var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );
var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );

// Allocate space on the heap:
var xbytes = wasm.malloc( x.length * x.BYTES_PER_ELEMENT );
var ybytes = wasm.malloc( y.length * y.BYTES_PER_ELEMENT );

// Copy data to the heap:
xbytes.set( new Uint8Array( x.buffer ) );
ybytes.set( new Uint8Array( y.buffer ) );

// Compute absolute values:
wasm( N, xbytes, 1, ybytes, 1 );

// Extract the results from the heap:
var view = new Float64Array( ybytes.buffer, ybytes.byteOffset, y.length );
var i;
for ( i = 0; i < y.length; i++ ) {
    y[ i ] = view[ i ];
}
// y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]

// Free the memory:
wasm.free( xbytes );
wasm.free( ybytes );
```

The method accepts the following `options`:

-   **memory**: total memory. If not provided a `buffer`, setting the `memory` option instructs the returned function to allocate an internal memory store of the specified size.
-   **stack**: total stack size. Must be less than the `memory` option and large enough for a program's needs. Default: `1024` bytes.
-   **buffer**: `ArrayBuffer` serving as the underlying memory store. If not provided, each returned function will allocate and manage its own memory. If provided a `memory` option, the buffer `byteLength` must equal the specified total memory.

To create a function using an externally defined memory buffer, set the `buffer` option.

<!-- FIXME: glue code seems to require more than just setting a `buffer` property: https://github.com/kripken/emscripten/blob/655cec1975e784985d25bc80c5438d715ac5ec13/src/preamble.js#L2155 and https://github.com/kripken/emscripten/blob/655cec1975e784985d25bc80c5438d715ac5ec13/src/preamble.js#L1141 -->

<!-- run-disable -->

```javascript
var ArrayBuffer = require( '@stdlib/array/buffer' );
var buffer = new ArrayBuffer( 16777216 ); // ~16MB

var wasm = dabs.wasm({
    'buffer': buffer
});
```

Providing external memory can be advantageous when wanting to a) centrally manage memory allocation, b) share memory between multiple memory managed functions, and/or c) limit the total amount of allocated memory within an application or library. 

##### wasm.malloc( nbytes )

Allocates space on the heap and returns a bytes-wise [`typed array`][@stdlib/array/uint8] view ([`Uint8Array`][@stdlib/array/uint8]).

```javascript
var wasm = dabs.wasm();

// Allocate 64 bytes:
var bytes = wasm.malloc( 64 );
```

##### bytes.getValue( ptr\[, type] )

Returns a value at a specific memory address (represented by a byte index). By default, the function returns a `double`. Possible types include: `'i8'`, `'i16'`, `'i32'`, `'i64'`, `'float'`, and `'double'`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = dabs.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ -1.0, -2.0, -3.0 ] );

var ptr = 1 * 8; // 8 bytes per double
var y = bytes.getValue( ptr );
// returns -2.0

wasm.free( bytes );
```

While this method may be convenient when interacting with the bytes view directly, using a [`typed array`][@stdlib/array/float64] view is likely to be more performant.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = dabs.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ -1.0, -2.0, -3.0 ] );

var y = view[ 1 ];
// returns -2.0

wasm.free( bytes );
```

##### bytes.setValue( ptr, value\[, type] )

Sets a value at a specific memory address (represented by a byte index). By default, the function sets a `double`. Possible types include: `'i8'`, `'i16'`, `'i32'`, `'i64'`, `'float'`, and `'double'`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = dabs.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ -1.0, -2.0, -3.0 ] );

var ptr = 1 * 8; // 8 bytes per double
var y = bytes.getValue( ptr );
// returns -2.0

bytes.setValue( ptr, -10.0 );

y = bytes.getValue( ptr );
// returns -10.0

wasm.free( bytes );
```

While this method may be convenient when interacting with the bytes view directly, using a [`typed array`][@stdlib/array/float64] view is likely to be more performant.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = dabs.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ -1.0, -2.0, -3.0 ] );

var y = view[ 1 ];
// returns -2.0

view[ 1 ] = -10.0;

y = view[ 1 ];
// returns -10.0

wasm.free( bytes );
```

##### wasm.free( heap )

Frees allocated space.

```javascript
var wasm = dabs.wasm();

var bytes = wasm.malloc( 64 );

// ...

// Free the space and allow reallocation:
wasm.free( bytes );
```

</section>

<!-- /.usage -->

<section class="notes">

</section>

<!-- /.notes -->

<section class="examples">

## Examples

<!-- eslint no-undef: "error" -->

```javascript
var round = require( '@stdlib/math/base/special/round' );
var randu = require( '@stdlib/random/base/randu' );
var Float64Array = require( '@stdlib/array/float64' );
var dabs = require( '@stdlib/strided/math/special/dabs' );

var rand;
var sign;
var x;
var y;
var i;

x = new Float64Array( 10 );
y = new Float64Array( 10 );
for ( i = 0; i < x.length; i++ ) {
    rand = round( randu()*100.0 );
    sign = randu();
    if ( sign < 0.5 ) {
        sign = -1.0;
    } else {
        sign = 1.0;
    }
    x[ i ] = sign * rand;
}
console.log( x );
console.log( y );

console.log( dabs.ndarray( x.length, x, 1, 0, y, -1, y.length-1 ) );
```

</section>

<!-- /.examples -->

<section class="links">

[@stdlib/array/float64]: https://github.com/stdlib-js/stdlib

[@stdlib/array/uint8]: https://github.com/stdlib-js/stdlib

[@stdlib/math/base/special/abs]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/math/base/special/abs

</section>

<!-- /.links -->
