/**
 * @license Apache-2.0
 *
 * Copyright (c) 2024 The Stdlib Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";

// MODULES //

var tape = require("tape");
var hammingCodePointsDistance = require("./../lib");

// TESTS //

tape("main export is a function", function test(t) {
  t.ok(true, __filename);
  t.strictEqual(
    typeof hammingCodePointsDistance,
    "function",
    "main export is a function"
  );
  t.end();
});

tape(
  "the function throws an error if not provided a string as its first argument",
  function test(t) {
    var values = [
      5,
      NaN,
      true,
      false,
      null,
      void 0,
      [],
      {},
      function noop() {},
    ];

    for (var i = 0; i < values.length; i++) {
      t.throws(
        badValue(values[i]),
        TypeError,
        "throws an error when provided " + values[i]
      );
    }
    t.end();

    function badValue(value) {
      return function badValue() {
        hammingCodePointsDistance(value, "foo");
      };
    }
  }
);

tape(
  "the function throws an error if not provided a string as its second argument",
  function test(t) {
    var values = [
      5,
      NaN,
      true,
      false,
      null,
      void 0,
      [],
      {},
      function noop() {},
    ];

    for (var i = 0; i < values.length; i++) {
      t.throws(
        badValue(values[i]),
        TypeError,
        "throws an error when provided " + values[i]
      );
    }
    t.end();

    function badValue(value) {
      return function badValue() {
        hammingCodePointsDistance("foo", value);
      };
    }
  }
);

tape(
  "the function returns -1 as a sentinel value if provided strings of unequal length",
  function test(t) {
    t.strictEqual(
      hammingCodePointsDistance("length", "differs"),
      -1,
      "returns expected value"
    );
    t.end();
  }
);

tape(
  "the function calculates the Hamming Code Points Distance distance between two equal-length unicode code points.",
  function test(t) {
    var values = [
      ["", ""], // Expected: 0
      ["a", "a"], // Expected: 0
      ["a", "b"], // Expected: 1
      ["xy", "xy"], // Expected: 0
      ["xx", "xy"], // Expected: 1
      ["Hello, world!", "Héllö, wörld!"], // Expected: 3 (Unicode differences in accented characters)
      ["a😊c", "a😃c"], // Expected: 1 (Difference in emoji)
      ["नमस्ते", "नमस्का"], // Expected: 2 (Devanagari characters)
      ["你好", "世界"], // Expected: 2 (Chinese characters)
      ["こんにちは", "さようなら"], // Expected: 5 (Japanese characters)
    ];

    var expected = [0, 0, 1, 0, 1, 3, 1, 2, 2, 5];

    for (var i = 0; i < values.length; i++) {
      t.strictEqual(
        hammingCodePointsDistance(values[i][0], values[i][1]),
        expected[i],
        "returns expected value"
      );
    }
    t.end();
  }
);
