/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var CR = require( './constants.js' ).CR;
var LF = require( './constants.js' ).LF;
var Control = require( './constants.js' ).Control;
var Extend = require( './constants.js' ).Extend;
var RegionalIndicator = require( './constants.js' ).Regional_Indicator;
var SpacingMark = require( './constants.js' ).SpacingMark;
var L = require( './constants.js' ).L;
var V = require( './constants.js' ).V;
var T = require( './constants.js' ).T;
var LV = require( './constants.js' ).LV;
var LVT = require( './constants.js' ).LVT;
var Prepend = require( './constants.js' ).Prepend;
var ZWJ = require( './constants.js' ).ZWJ;
var NotBreak = require( './constants.js' ).NotBreak;
var BreakStart = require( './constants.js' ).BreakStart;
var Break = require( './constants.js' ).Break;
var BreakLastRegional = require( './constants.js' ).BreakLastRegional;
var BreakPenultimateRegional = require( './constants.js' ).BreakPenultimateRegional;
var ExtendedPictographic = require( './constants.js' ).Extended_Pictographic;


// MAIN //

/**
* Returns whether a break is allowed between the two given grapheme breaking classes according to UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters.
*
* @param {number} start - start
* @param {Array<number>} mid - mid
* @param {number} end - end
* @param {number} startEmoji - startEmoji
* @param {Array<number>} midEmoji - midEmoji
* @param {number} endEmoji - endEmoji
* @returns {number} break type
*/
function shouldBreak( start, mid, end, startEmoji, midEmoji, endEmoji ) {
	var prevNonExtendIdx;
	var regIndRange;
	var nextEmoji;
	var allEmoji;
	var previous;
	var next;
	var all;
	/**
	* Function expression.
	* @private
	* @param {number} c - temp
	* @returns {boolean} - check if extend
	*/
	function checker( c ) {
		return c === RegionalIndicator;
	}
	/**
	* Function expression.
	* @private
	* @param {number} c - temp
	* @returns {boolean} - check if Extend
	*/
	function checkerE( c ) {
		return c === Extend;
	}
	all = [ start ].concat( mid ).concat( [ end ] );
	allEmoji = [ startEmoji ].concat( midEmoji ).concat( [ endEmoji ] );
	previous = all[ all.length - 2 ];
	next = end;
	nextEmoji = endEmoji;

	regIndRange = all.lastIndexOf( RegionalIndicator );
	if ( regIndRange > 0 &&
		all.slice( 1, regIndRange ).every( checker ) &&
		[ Prepend, RegionalIndicator ].indexOf( previous ) === -1 ) {
		if ( all.filter( checker ).length % 2 === 1 ) {
			return BreakLastRegional;
		}
		return BreakPenultimateRegional;
	}

	// GB3: CR × LF
	if ( previous === CR && next === LF ) {
		return NotBreak;
	}
	// GB4: (Control|CR|LF) ÷
	else if ( previous === Control || previous === CR || previous === LF ) { // eslint-disable-line no-else-return
		return BreakStart;
	}
	// GB5: ÷ (Control|CR|LF)
	else if ( next === Control || next === CR || next === LF ) {
		return BreakStart;
	}
	// GB6: L × (L|V|LV|LVT)
	else if ( previous === L &&
		( next === L || next === V || next === LV || next === LVT ) ) {
		return NotBreak;
	}
	// GB7: (LV|V) × (V|T)
	else if ( (previous === LV || previous === V ) &&
		( next === V || next === T ) ) {
		return NotBreak;
	}
	// GB8: (LVT|T) × (T)
	else if ( ( previous === LVT || previous === T ) &&
		next === T ) {
		return NotBreak;
	}
	// GB9: × (Extend|ZWJ)
	else if ( next === Extend || next === ZWJ ) {
		return NotBreak;
	}
	// GB9a: × SpacingMark
	else if ( next === SpacingMark ) {
		return NotBreak;
	}
	// GB9b: Prepend ×
	else if ( previous === Prepend ) {
		return NotBreak;
	}

	// GB11: \p{Extended_Pictographic} Extend* ZWJ × \p{Extended_Pictographic}
	prevNonExtendIdx = allEmoji.slice( 0, -1 ).lastIndexOf( ExtendedPictographic ); // eslint-disable-line max-len
	if ( prevNonExtendIdx !== -1 &&
		allEmoji[ prevNonExtendIdx ] === ExtendedPictographic &&
		all.slice( prevNonExtendIdx + 1, -2 ).every( checkerE ) &&
		previous === ZWJ &&
		nextEmoji === ExtendedPictographic ) {
		return NotBreak;
	}

	// GB12: ^ (RI RI)* RI × RI
	// GB13: [^RI] (RI RI)* RI × RI
	if ( mid.indexOf( RegionalIndicator ) !== -1 ) {
		return Break;
	}
	if ( previous === RegionalIndicator && next === RegionalIndicator ) {
		return NotBreak;
	}

	// GB999: Any ? Any
	return BreakStart;
}


// EXPORTS //

module.exports = shouldBreak;
