/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var resolve = require( 'path' ).resolve;
var join = require( 'path' ).join;
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var writeFileSync = require( '@stdlib/fs/write-file' ).sync;


// FUNCTIONS //

/**
* Returns the UCS-2 encoding from code points.
* @private
* @param {NumericArray} array - array of code points
* @returns {string} - UCS-2 encoded string
*/
function ucs2encode( array ) {
	return array.map( function mapper( value ) {
		var output = '';

		if ( value > 0xFFFF ) {
			value -= 0x10000;
			output += String.fromCharCode( ( ( value >>> 10 ) & 0x3FF ) | 0xD800 ); // eslint-disable-line max-len
			value = 0xDC00 | ( value & 0x3FF );
		}

		output += String.fromCharCode( value );
		return output;
	}).join( '' );
}

/**
* Returns the hexadecimal form of argument.
* @private
* @param {integer} c - temp
* @returns {integer} - hexadecimal form
*/
function convertToHex( c ) {
	return parseInt( c, 16 );
}

/**
* Returns the test data from a single line in the txt as an object.
* @private
* @param {string} line - single line from the txt
* @returns {Object} - test data for the line
*/
function testDataFromLine( line ) {
	var codePoints;
	var expected;
	var input;
	codePoints = line.split( /\s*[×÷]\s*/ ).map( convertToHex );
	input = ucs2encode( codePoints );

	expected = line.split( /\s*÷\s*/ ).map( function mapper( sequence ) {
		var codePoints = sequence.split(/\s*×\s*/).map( convertToHex );
		return ucs2encode( codePoints );
	});

	return {
		'input': input,
		'expected': expected
	};
}

/**
* Writes the test data from the txt fixture into JSON fixture.
* @private
* @param {string} inpTxt - name of input txt file in this directory
* @param {string} outJson - name of output JSON file in this directory
*/
function writeTestDataToJsonFile( inpTxt, outJson ) {
	var testData;
	var outPath;
	testData = readFileSync( resolve( __dirname, inpTxt ), {
		'encoding': 'utf8'
	})
		.split( '\n' )
		.filter( function filterer( line ) {
			return line !== null && line.length > 0 && !line.startsWith( '#' );
		})
		.map( function mapper( line ) { return line.split( '#' )[ 0 ]; } )
		.map( testDataFromLine );

	outPath = join( __dirname, outJson );
	writeFileSync( outPath, JSON.stringify( testData ) );
}

writeTestDataToJsonFile( 'grapheme_break_test.txt', 'test_data.json' );
