/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var resolve = require( 'path' ).resolve;
var join = require( 'path' ).join;
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var writeFileSync = require( '@stdlib/fs/write-file' ).sync;
var startsWith = require( '@stdlib/string/starts-with' );
var inmap = require( '@stdlib/utils/inmap' );


// FUNCTIONS //

/**
* Returns the UCS-2 encoding from code points.
*
* @private
* @param {NumericArray} array - array of code points
* @returns {string} - UCS-2 encoded string
*/
function ucs2encode( array ) {
	var output;
	var temp;
	var i;

	output = '';
	for ( i = 0; i < array.length; i++) {
		temp = array[ i ];
		if ( temp > 0xFFFF ) {
			temp -= 0x10000;
			output += String.fromCharCode( ( ( temp >>> 10 ) & 0x3FF ) | 0xD800 ); // eslint-disable-line max-len
			temp = 0xDC00 | ( temp & 0x3FF );
		}

		output += String.fromCharCode( temp );
	}
	return output;
}

/**
* Returns the hexadecimal form of argument.
*
* @private
* @param {integer} c - temp
* @returns {integer} - hexadecimal form
*/
function convertToHex( c ) {
	return parseInt( c, 16 );
}

/**
* Callback for inmap used for getting expected output.
*
* @private
* @param {string} sequence - temp
* @returns {string} - expected output for a testcase line
*/
function mapper( sequence ) {
	var codePoints = inmap( sequence.split(/\s*×\s*/), convertToHex );
	return ucs2encode( codePoints );
}

/**
* Returns the test data from a single line in the txt as an object.
*
* @private
* @param {string} line - single line from the txt
* @returns {Object} - test data for the line
*/
function testDataFromLine( line ) {
	var codePoints;
	var expected;
	var input;
	codePoints = inmap( line.split( /\s*[×÷]\s*/ ), convertToHex );
	input = ucs2encode( codePoints );

	expected = inmap( line.split( /\s*÷\s*/ ), mapper );

	return {
		'input': input,
		'expected': expected
	};
}

/**
* Callback for inmap used for removing comments from line in txt.
*
* @private
* @param {string} line - temp
* @returns {string} - temp
*/
function removeComments( line ) {
	return line.split( '#' )[ 0 ];
}

/**
* Writes the test data from the txt fixture into JSON fixture.
*
* @private
* @param {string} inpTxt - name of input txt file in this directory
* @param {string} outJson - name of output JSON file in this directory
*/
function main( inpTxt, outJson ) {
	var testData;
	var outPath;
	testData = readFileSync( resolve( __dirname, inpTxt ), {
		'encoding': 'utf8'
	})
		.split( '\n' )
		.filter( function filterer( line ) {
			return line !== null && line.length > 0 && !startsWith( line, '#' );
		});
	inmap( testData, removeComments );
	inmap( testData, testDataFromLine );

	outPath = join( __dirname, outJson );
	writeFileSync( outPath, JSON.stringify( testData ) + '\n' );
}

main( 'grapheme_break_test.txt', 'test_data.json' );
