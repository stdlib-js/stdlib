/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var proxyquire = require( 'proxyquire' );
var ArrayBuffer = require( '@stdlib/array/buffer' );
var Uint8Array = require( '@stdlib/array/uint8' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isArrayBuffer = require( '@stdlib/assert/is-arraybuffer' );
var BooleanArray = require( './../lib' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof BooleanArray, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function is a constructor', function test( t ) {
	var arr = new BooleanArray( 0 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor does not require the `new` keyword', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( 0 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (no argument)', function test( t ) {
	var arr = new BooleanArray();
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (no argument, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor();
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (length)', function test( t ) {
	var arr = new BooleanArray( 10 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (length, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( 10 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (array)', function test( t ) {
	var arr = new BooleanArray( [] );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (array, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( [] );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (typed array)', function test( t ) {
	var arr = new BooleanArray( new Uint8Array( 0 ) );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (typed array, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( new Uint8Array( 0 ) );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (iterable)', function test( t ) {
	var BooleanArray;
	var arr;

	BooleanArray = proxyquire( './../lib/main.js', {
		'@stdlib/assert/has-iterator-symbol-support': hasSupport,
		'@stdlib/symbol/iterator': '__SYMBOL_ITERATOR__'
	});

	arr = new BooleanArray( createIterable() );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();

	function hasSupport() {
		return true;
	}

	function createIterable() {
		var it = {};
		it[ '__SYMBOL_ITERATOR__' ] = iterable;
		return it;

		function iterable() {
			return {
				'next': next
			};
		}

		function next() {
			return {
				'done': true
			};
		}
	}
});

tape( 'the constructor returns a boolean array (iterable, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = proxyquire( './../lib/main.js', {
		'@stdlib/assert/has-iterator-symbol-support': hasSupport,
		'@stdlib/symbol/iterator': '__SYMBOL_ITERATOR__'
	});

	arr = ctor( createIterable() );
	t.strictEqual( arr instanceof ctor, true, 'returns an instance' );

	t.end();

	function hasSupport() {
		return true;
	}

	function createIterable() {
		var it = {};
		it[ '__SYMBOL_ITERATOR__' ] = iterable;
		return it;

		function iterable() {
			return {
				'next': next
			};
		}

		function next() {
			return {
				'done': true
			};
		}
	}
});

tape( 'the constructor returns a boolean array (ArrayBuffer)', function test( t ) {
	var arr = new BooleanArray( new ArrayBuffer( 0 ) );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (ArrayBuffer, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( new ArrayBuffer( 0 ) );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (ArrayBuffer, byte offset)', function test( t ) {
	var arr = new BooleanArray( new ArrayBuffer( 8 ), 8 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (ArrayBuffer, byte offset, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( new ArrayBuffer( 8 ), 8 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'the constructor returns a boolean array (ArrayBuffer, byte offset, length)', function test( t ) {
	var arr = new BooleanArray( new ArrayBuffer( 8 ), 8, 0 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor returns a boolean array (ArrayBuffer, byte offset, length, no new)', function test( t ) {
	var ctor;
	var arr;

	ctor = BooleanArray;

	arr = ctor( new ArrayBuffer( 8 ), 8, 0 );
	t.strictEqual( arr instanceof BooleanArray, true, 'returns an instance' );

	t.end();
});

tape( 'attached to the constructor is a property returning the number of bytes per array element', function test( t ) {
	t.strictEqual( hasOwnProp( BooleanArray, 'BYTES_PER_ELEMENT' ), true, 'has property' );
	t.strictEqual( BooleanArray.BYTES_PER_ELEMENT, 1, 'returns expected value' );
	t.end();
});

tape( 'attached to the constructor is a property returning the constructor name', function test( t ) {
	t.strictEqual( hasOwnProp( BooleanArray, 'name' ), true, 'has property' );
	t.strictEqual( BooleanArray.name, 'BooleanArray', 'returns expected value' );
	t.end();
});

tape( 'the constructor returns an instance having a `BYTES_PER_ELEMENT` property returning the number of bytes per array element', function test( t ) {
	var arr;

	t.strictEqual( hasOwnProp( BooleanArray.prototype, 'BYTES_PER_ELEMENT' ), true, 'has property' );
	t.strictEqual( BooleanArray.prototype.BYTES_PER_ELEMENT, 1, 'returns expected value' );

	arr = new BooleanArray( 0 );
	t.strictEqual( arr.BYTES_PER_ELEMENT, 1, 'returns expected value' );

	t.end();
});

tape( 'the constructor returns an instance having a `buffer` property for returning the underlying memory (i.e., ArrayBuffer)', function test( t ) {
	var arr;
	var buf;

	arr = new BooleanArray( 0 );
	buf = arr.buffer;
	t.strictEqual( isArrayBuffer( buf ), true, 'returns expected value' );
	t.end();
});

tape( 'the constructor returns an instance having a `byteLength` property for returning the number of bytes belonging to the array view', function test( t ) {
	var arr;
	var v;

	arr = new BooleanArray( 0 );
	v = arr.byteLength;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( new ArrayBuffer( 64 ), 8 );
	v = arr.byteLength;
	t.strictEqual( v, 56, 'returns expected value' );

	arr = new BooleanArray( new ArrayBuffer( 64 ), 64 );
	v = arr.byteLength;
	t.strictEqual( v, 0, 'returns expected value' );

	t.end();
});

tape( 'the constructor returns an instance having a `byteOffset` property for returning the byte offset pointing to the first array element in the underlying memory', function test( t ) {
	var arr;
	var v;

	arr = new BooleanArray( 0 );
	v = arr.byteOffset;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( new ArrayBuffer( 64 ), 32 );
	v = arr.byteOffset;
	t.strictEqual( v, 32, 'returns expected value' );

	arr = new BooleanArray( new ArrayBuffer( 64 ), 64 );
	v = arr.byteOffset;
	t.strictEqual( v, 64, 'returns expected value' );

	t.end();
});

tape( 'the constructor returns an instance having a `length` property for returning the number of array elements', function test( t ) {
	var arr;
	var v;

	// No arguments:
	arr = new BooleanArray();
	v = arr.length;
	t.strictEqual( v, 0, 'returns expected value' );

	// Explicit array length:
	arr = new BooleanArray( 0 );
	v = arr.length;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( 10 );
	v = arr.length;
	t.strictEqual( v, 10, 'returns expected value' );

	// Generic array:
	arr = new BooleanArray( [] );
	v = arr.length;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( [ true, false, true, false ] );
	v = arr.length;
	t.strictEqual( v, 4, 'returns expected value' );

	// Typed array:
	arr = new BooleanArray( new Uint8Array( 0 ) );
	v = arr.length;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( new Uint8Array( [ 1, 1 ] ) );
	v = arr.length;
	t.strictEqual( v, 2, 'returns expected value' );

	// Boolean typed array:
	arr = new BooleanArray( new BooleanArray( 0 ) );
	v = arr.length;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( new BooleanArray( [ true, true ] ) );
	v = arr.length;
	t.strictEqual( v, 2, 'returns expected value' );

	// ArrayBuffer:
	arr = new BooleanArray( new ArrayBuffer( 64 ), 32 );
	v = arr.length;
	t.strictEqual( v, 32, 'returns expected value' );

	arr = new BooleanArray( new ArrayBuffer( 64 ), 64 );
	v = arr.length;
	t.strictEqual( v, 0, 'returns expected value' );

	arr = new BooleanArray( new ArrayBuffer( 64 ), 32, 2 );
	v = arr.length;
	t.strictEqual( v, 2, 'returns expected value' );

	t.end();
});

tape( 'the constructor returns an instance having a `length` property for returning the number of array elements (iterable)', function test( t ) {
	var BooleanArray;
	var iter;
	var arr;
	var v;

	BooleanArray = proxyquire( './../lib/main.js', {
		'@stdlib/assert/has-iterator-symbol-support': hasSupport,
		'@stdlib/symbol/iterator': '__SYMBOL_ITERATOR__'
	});

	iter = {
		'next': next,
		'i': 0,
		'N': 4
	};
	arr = new BooleanArray( createIterable( iter ) );
	v = arr.length;
	t.strictEqual( v, iter.N, 'returns expected value' );

	t.end();

	function hasSupport() {
		return true;
	}

	function createIterable( iterator ) {
		var it = {};
		it[ '__SYMBOL_ITERATOR__' ] = iterable;
		return it;

		function iterable() {
			return iterator;
		}
	}

	function next() {
		iter.i += 1;
		if ( iter.i <= iter.N ) {
			return {
				'value': true
			};
		}
		return {
			'done': true
		};
	}
});

tape( 'the constructor throws an error if provided a non-iterable object (non-ES2015+)', function test( t ) {
	var BooleanArray;
	var values;
	var i;

	BooleanArray = proxyquire( './../lib/main.js', {
		'@stdlib/assert/has-iterator-symbol-support': hasSupport
	});

	values = [
		{},
		{
			'0': 1,
			'1': 2,
			'2': 3
		}
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( value );
		};
	}

	function hasSupport() {
		return false;
	}
});

tape( 'the constructor throws an error if provided a non-iterable object (ES2015+)', function test( t ) {
	var BooleanArray;
	var values;
	var i;

	BooleanArray = proxyquire( './../lib/main.js', {
		'@stdlib/assert/has-iterator-symbol-support': hasSupport,
		'@stdlib/symbol/iterator': '__SYMBOL_ITERATOR__'
	});

	values = [
		{},
		{
			'0': 1,
			'1': 2,
			'2': 3
		},
		{
			'__SYMBOL_ITERATOR__': null
		},
		{
			'__SYMBOL_ITERATOR__': 'beep'
		},
		{
			'__SYMBOL_ITERATOR__': nonIterable1
		},
		{
			'__SYMBOL_ITERATOR__': nonIterable2
		}
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( value );
		};
	}

	function hasSupport() {
		return true;
	}

	function nonIterable1() {
		return null;
	}

	function nonIterable2() {
		return {};
	}
});

tape( 'the constructor throws an error if not provided a length, iterable, array-like object, or ArrayBuffer', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		3.14,
		-1,
		NaN,
		true,
		false,
		null,
		void 0,
		function noop() {}
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( value );
		};
	}
});

tape( 'the constructor throws an error if provided more than one argument and the first argument is not an ArrayBuffer', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		true,
		false,
		null,
		void 0,
		[],
		{},
		function noop() {}
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( value, 0 );
		};
	}
});

tape( 'the constructor throws an error if provided a byte offset argument which is not a nonnegative integer', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		-1,
		3.14,
		NaN,
		true,
		false,
		null,
		void 0,
		[],
		{},
		function noop() {}
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( new ArrayBuffer( 64 ), value );
		};
	}
});

tape( 'the constructor throws an error if provided a length argument which is not a nonnegative integer (ArrayBuffer)', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		-1,
		3.14,
		NaN,
		true,
		false,
		null,
		void 0,
		[],
		{},
		function noop() {}
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( new ArrayBuffer( 64 ), 0, value );
		};
	}
});

tape( 'the constructor throws an error if provided insufficient memory to accommodate byte offset and length arguments', function test( t ) {
	var values;
	var i;

	values = [
		8,
		16,
		24,
		32
	];
	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), RangeError, 'throws an error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			return new BooleanArray( new ArrayBuffer( 100 ), value, 1e3 );
		};
	}
});
