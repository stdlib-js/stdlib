Debug Stream
===

> [Transform stream][transform-stream] for [debugging][node-debug] stream pipelines.


<!-- <usage> -->

## Usage

``` javascript
var debugStream = require( '@stdlib/streams/utils/debug' );
```

#### debugStream( \[options,\] \[clbk\] )

Creates a [transform stream][transform-stream] for [debugging][node-debug] stream pipelines.

``` javascript
// Set the `DEBUG` environment variable...
process.env.DEBUG = '*';

var stream = debugStream({
    'name': 'my-stream'
});

stream.write( 'a' );
stream.write( 'b' );
stream.write( 'c' );
stream.end();
```

The function accepts the following `options`:

* __name__: [debug][node-debug] namespace
* __objectMode__: specifies whether a [stream][stream] should operate in [objectMode][object-mode]. Default: `false`.
* __highWaterMark__: specifies the `Buffer` level at which `write()` calls start returning `false`.
* __allowHalfOpen__: specifies whether a [stream][stream] should remain open even if one side ends. Default: `false`.
* __readableObjectMode__: specifies whether the readable side should be in [objectMode][object-mode]. Default: `false`.

To set [stream][stream] `options`,

``` javascript
var opts = {
    'name': 'my-app',
    'objectMode': true,
    'highWaterMark': 64,
    'allowHalfOpen': true,
    'readableObjectMode': false // overridden by `objectMode` option when `objectMode=true`
};

var stream = debugStream( opts );
```

By default, each `chunk` is logged as a JSON stringified `string`, along with the `chunk` index. For more control over logging behavior, provide a `callback`.

``` javascript
function logger( debug, chunk, idx ) {
    debug( 'Received a new chunk...' );
    debug( 'Beep: %s', chunk.beep );
    debug( 'Boop: %s', chunk.boop );
}

var opts = {
    'name': 'my-pipeline'
};

var stream = debugStream( opts, logger );
```


#### debugStream.factory( \[options\] )

Creates a reusable [stream][stream] factory. The factory method ensures [streams][stream] are configured identically by using the same set of provided `options`.

``` javascript
var opts = {
    'objectMode': true,
    'highWaterMark': 64
};

var factory = debugStream.factory( opts );
```

This method accepts all documented `options`, __except__ for `name`, which must be provided __explicitly__.


##### factory( name\[, clbk\] )

Creates a [debug][node-debug] stream.

``` javascript
var streams = [];
var i;

// Assign each stream to a separate debug namespace...
for ( i = 0; i < 10; i++ ) {
    streams.push( factory( 'stream '+i ) );
}
```


#### debugStream.objectMode( \[options,\] \[clbk\] )

This method is a convenience function to create [streams][stream] which always operate in [objectMode][object-mode]. The method will __always__ override the [objectMode][object-mode] option in `options`.

``` javascript
var stream = debugStream.objectMode({
    'name': 'beep-boop'
});

stream.write( {'value': 'a'} );
stream.write( {'value': 'b'} );
stream.write( {'value': 'c'} );
stream.end();
```

This method accepts all documented `options`.

<!-- </usage> -->


<!-- <notes> -->

## Notes

* If the [`DEBUG`][node-debug] environment variable is __not__ set, no data is logged.
* Providing a `name` option is __strongly__ encouraged, as the [`DEBUG`][node-debug] environment variable can be used to filter debuggers.

<!-- </notes> -->


<!-- <examples> -->

## Examples

``` javascript
var stdout = require( '@stdlib/streams/base/stdout' );
var transformFactory = require( '@stdlib/streams/utils/transform' ).factory;
var debug = require( '@stdlib/streams/utils/debug' ).objectMode;

function parse( chunk, enc, clbk ) {
    clbk( null, JSON.parse( chunk ) );
}

function pluck( chunk, enc, clbk ) {
    clbk( null, chunk.value );
}

function square( chunk, enc, clbk ) {
    var v = +chunk;
    clbk( null, v*v );
}

function toString( chunk, enc, clbk ) {
    clbk( null, chunk.toString() );
}

function join( chunk, enc, clbk ) {
    clbk( null, chunk+'\n' );
}

// Create a factory for generating streams running in `object` mode:
var tStream = transformFactory({
    'objectMode': true
});

// Create streams for each transform:
var s1 = tStream( parse );
var d1 = debug( {'name': 'parse'} );
var s2 = tStream( pluck );
var d2 = debug( {'name': 'pluck'} );
var s3 = tStream( square );
var d3 = debug( {'name': 'square'} );
var s4 = tStream( toString );
var d4 = debug( {'name': 'toString'} );
var s5 = tStream( join );
var d5 = debug( {'name': 'join'} );

// Create the pipeline:
s1.pipe( d1 )
    .pipe( s2 )
    .pipe( d2 )
    .pipe( s3 )
    .pipe( d3 )
    .pipe( s4 )
    .pipe( d4 )
    .pipe( s5 )
    .pipe( d5 )
    .pipe( stdout );

// Write data to the pipeline...
var v;
var i;
for ( i = 0; i < 100; i++ ) {
    v = '{"value":'+i+'}';
    s1.write( v, 'utf8' );
}
s1.end();
```

<!-- </examples> -->


<!-- <links> -->

[stream]: https://nodejs.org/api/stream.html
[object-mode]: https://nodejs.org/api/stream.html#stream_object_mode
[transform-stream]: https://nodejs.org/api/stream.html
[node-debug]: https://www.npmjs.com/package/debug

<!-- </links> -->
