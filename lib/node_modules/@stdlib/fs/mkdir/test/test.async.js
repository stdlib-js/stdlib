/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var rmdirSync = require( 'fs' ).rmdirSync; // eslint-disable-line node/no-sync
var statSync = require( 'fs' ).statSync; // eslint-disable-line node/no-sync
var join = require( 'path' ).join;
var tape = require( 'tape' );
var IS_BROWSER = require( '@stdlib/assert/is-browser' );
var mkdir = require( './../lib/async.js' );
var mkdirSync = require( './../lib/sync.js' );


// VARIABLES //

// Don't run tests in the browser...for now...
var opts = {
	'skip': IS_BROWSER // FIXME
};
var dpath = join( __dirname, 'fixtures' );


// FUNCTIONS //

/**
* Removes the directiry created during testing.
*
* @private
* @param {string} dir - directory to remove
*/
function remove( dir ) {
	var opts;

	opts = {
		'recursive': true,
		'force': true
	};
	rmdirSync( dir, opts );
}


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof mkdir, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function throws an error if provided a `path` argument which is not a string', opts, function test( t ) {
	var values;
	var i;

	values = [
		5,
		NaN,
		null,
		void 0,
		true,
		[],
		{},
		function noop() {}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws a type error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			mkdir( value, {} );
		};
	}
});

tape( 'the function throws an error if not provided a integer nor an object as options argurment', opts, function test( t ) {
	var values;
	var i;

	values = [
		null,
		void 0,
		true,
		123.456,
		[],
		function noop() {}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws a type error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			mkdir( './foo', value, function noop() {} );
		};
	}
});

tape( 'the function throws an error if not provided a callback function', function test( t ) {
	var values;
	var i;

	values = [
		5,
		NaN,
		null,
		void 0,
		true,
		[],
		{}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws a type error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			mkdir( './foo', value );
		};
	}
});

tape( 'the function throws an error if the third argument is not a callback function', opts, function test( t ) {
	var values;
	var i;

	values = [
		5,
		NaN,
		null,
		void 0,
		true,
		[],
		{}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws a type error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			mkdir( './foo', {}, value );
		};
	}
});

tape( 'the function creates a directory without an options argument', opts, function test( t ) {
	var dir;

	dir = join( dpath, 'foo' );

	mkdir( dir, onDir );
	function onDir( error ) {
		t.strictEqual( error, null, 'create a directory without error' );
		t.strictEqual( statSync( dir ).isDirectory(), true, 'creates a directory' );
		remove( dir );
		t.end();
	}
});

tape( 'the function creates a directory with an options argument', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0755', 8 ),
		'recursive': true
	};
	dir = join( dpath, 'foo/bar' );

	mkdir( dir, opts, onDir );

	function onDir( error ) {
		t.strictEqual( error, null, 'create a directory without error' );
		t.strictEqual( statSync( dir ).isDirectory(), true, 'creates a directory' );
		remove( join( dpath, 'foo' ) );
		t.end();
	}
});

tape( 'the function creates a directory with a different options argument', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0777', 8 ),
		'recursive': false
	};
	dir = join( dpath, 'foo' );

	mkdir( dir, opts, onDir );

	function onDir( error ) {
		t.strictEqual( error, null, 'create a directory without error' );
		t.strictEqual( statSync( dir ).isDirectory(), true, 'creates a directory' );
		remove( dir );
		t.end();
	}
});

tape( 'if recursive is `true`, the second argument in callback will be the first directory path created', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0755', 8 ),
		'recursive': true
	};
	dir = join( dpath, 'foo/bar' );

	mkdir( dir, opts, onDir );

	function onDir( error, path ) {
		t.strictEqual( error, null, 'create a directory without error' );
		t.strictEqual( path, join( dpath, 'foo' ), 'returns the first directory path created' );
		t.strictEqual( statSync( dir ).isDirectory(), true, 'creates a directory' );
		remove( join( dpath, 'foo' ) );
		t.end();
	}
});

tape( 'if recursive is `true`, the second argument in callback will be `undefined` if does not create any', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0755', 8 ),
		'recursive': true
	};
	dir = join( dpath, 'foo/bar' );

	mkdirSync( dir, opts );
	mkdir( dir, opts, onDir );

	function onDir( error, path ) {
		t.strictEqual( error, null, 'create a directory without error' );
		t.strictEqual( path, void 0, 'returns undefined' );
		t.strictEqual( statSync( dir ).isDirectory(), true, 'creates a directory' );
		remove( join( dpath, 'foo' ) );
		t.end();
	}
});

tape( 'if the function attempts to create nested directories without an options argument, the first argument in callback will be an error instance (without an options argument)', opts, function test( t ) {
	var dir;

	dir = join( dpath, 'foo/bar' );

	mkdir( dir, onDir );

	function onDir( error ) {
		t.strictEqual( error instanceof Error, true, 'returns an error instance' );
		t.end();
	}
});

tape( 'if the function attempts to create nested directories without setting recursive as `true`, the first argument in callback will be an error instance (without an options argument)', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0755', 8 ),
		'recursive': false
	};
	dir = join( dpath, 'foo/bar' );

	mkdir( dir, opts, onDir );

	function onDir( error ) {
		t.strictEqual( error instanceof Error, true, 'returns an error instance' );
		t.end();
	}
});

tape( 'if the function attempts to create nested directories without an options argument, the first argument in callback will be an error instance (without an options argument)', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0755', 8 ),
		'recursive': true
	};
	dir = join( dpath, 'foo/bar' );

	mkdirSync( dir, opts );

	mkdir( dir, onDir );

	function onDir( error ) {
		t.strictEqual( error instanceof Error, true, 'returns an error instance' );
		remove( join( dpath, 'foo' ) );
		t.end();
	}
});

tape( 'if the function attempts to create nested directories without setting recursive as `true`, the first argument in callback will be an error instance (without an options argument)', opts, function test( t ) {
	var opts;
	var dir;

	opts = {
		'mode': parseInt( '0755', 8 ),
		'recursive': true
	};
	dir = join( dpath, 'foo/bar' );

	mkdirSync( dir, opts );

	opts.recursive = false;
	mkdir( dir, opts, onDir );

	function onDir( error ) {
		t.strictEqual( error instanceof Error, true, 'returns an error instance' );
		remove( join( dpath, 'foo' ) );
		t.end();
	}
});
